<!doctype html>
<head>
<meta charset="utf-8">
<title>5 Overview of SystemC Features</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="connecting-systemc-and-simics-models.html">4 Connecting SystemC and Simics Models</a>
<a href="execution-of-systemc-models-in-the-simics-simulator.html">6 Execution of SystemC Models in the Simics Simulator</a>
</div>
<div class="path">
<a href="index.html">SystemC* Library</a>
&nbsp;/&nbsp;</div>
<h1 id="overview-of-systemc-features">5 <a href="#overview-of-systemc-features">Overview of SystemC Features</a></h1>
<p>This section outlines some of the Simics features that are available when running SystemC models in Simics.</p>
<p>In Simics the SystemC scheduler runs under the control of the Simics framework, meaning that simulation can be started and stopped using the Simics GUI or normal Simics commands such as <code>continue</code> or <code>stop</code>.</p>
<p>All SystemC objects, derived from <code>sc_object</code> class, are visible in Simics as configuration objects. This means that it is possible to interact with the objects from the Simics CLI. </p>
<div class="note">
<p>If some SystemC object is not visible in Simics, check that all the following conditions apply:</p>
<ol>
<li>
<p>The name complies to the recommendation of IEEE 1666-2011 5.17 which is also a requirement for naming Simics objects. Non-compliant names are transformed and the Simics object created under Adapter.renamed using the corresponding hierarchy. Invalid characters are escaped with _0x and replaced with the ASCII value in hex. E.g: a.b.test[A] becomes renamed.a.b.test_0x5B_A_0x5D_</p>
</li>
<li>
<p>The object is not dynamic, as stated in section <a class="reference" href="#dynamic-systemc-objects">5.3.2.1</a>; </p>
</li>
</ol>
</div>
<div class="note">
<p>Use <code>help SystemC</code> to get a list of all supported SystemC CLI commands. And use <code>help</code> on selected command to get detail information. </p>
</div>
<p>Typical operations available on SystemC objects are enabling tracing or breakpoints on sockets and signals. In addition, normal Simics commands work as expected. For example, to find all SystemC ports the command <code>list-objects</code> can be used with sc_port as the <em>type</em> argument.</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -show-port-objects iface=sc_port</strong>
┌─────────────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────────┐
│                       Object                        │                                       Class                                        │
├─────────────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────────┤
│lt.dut.m_at_and_lt_target_1.memory_socket_1_port_0   │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_bus.simple_initiator_socket_tagged_0        │&lt;lt_example_tlm_initiator_socket_dut_m_bus_simple_initiator_socket_tagged_0&gt;        │
│lt.dut.m_bus.simple_initiator_socket_tagged_1        │&lt;lt_example_tlm_initiator_socket_dut_m_bus_simple_initiator_socket_tagged_1&gt;        │
│lt.dut.m_bus.simple_target_socket_tagged_0_port_0    │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_bus.simple_target_socket_tagged_1_port_0    │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_initiator.initiator_socket    │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_m_initiator_initiator_socket&gt;    │
│lt.dut.m_initiator_1.m_initiator.initiator_socket_opt│&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_m_initiator_initiator_socket_opt&gt;│
│lt.dut.m_initiator_1.m_initiator.port_0              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_initiator.port_1              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_traffic_gen.port_0            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_traffic_gen.port_1            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.top_initiator_socket            │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_top_initiator_socket&gt;            │
│lt.dut.m_initiator_2.m_initiator.initiator_socket    │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_m_initiator_initiator_socket&gt;    │
│lt.dut.m_initiator_2.m_initiator.initiator_socket_opt│&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_m_initiator_initiator_socket_opt&gt;│
│lt.dut.m_initiator_2.m_initiator.port_0              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_initiator.port_1              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_traffic_gen.port_0            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_traffic_gen.port_1            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.top_initiator_socket            │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_top_initiator_socket&gt;            │
│lt.dut.m_lt_target_2.memory_socket_2_opt_port_0      │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_lt_target_2.memory_socket_2_port_0          │&lt;lt_example_sc_port&gt;                                                                │
└─────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>SystemC signals and TLM2 sockets can be traced or have breakpoints attached to them. Please refer to section <a class="reference" href="#systemc-library-tools">5.3</a> for more information about trace and break on SystemC objects.</p>
<p>For example, a transaction break-point can be set on a target socket as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>lt.dut.m_lt_target_2.memory_socket_2.break-sc</strong>
simics&gt; <strong>c</strong>
[lt.dut.m_lt_target_2.memory_socket_2 break-b-in] write sz:4 addr:0x0 data:0xefffffff
[lt.dut.m_lt_target_2.memory_socket_2 break-b-out] write sz:4 addr:0x0 data:0xefffffff status:TLM_OK_RESPONSE
[lt.dut.m_lt_target_2.memory_socket_2 break-b-in] write sz:4 addr:0x0 data:0xefffffff
[lt.dut.m_lt_target_2.memory_socket_2 break-b-out] write sz:4 addr:0x0 data:0xefffffff status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>In order to reduce the message length, Simics shortens common SystemC terminology. For instance, in the example above "b_in" refers to an inbound blocking transaction. The table below summarizes all the abbreviations.</p>
<table><thead><tr><th><strong>Simics</strong></th><th><strong>SystemC</strong></th></tr></thead><tbody>
<tr><td>b</td><td>blocking</td></tr>
<tr><td>nb</td><td>non-blocking</td></tr>
<tr><td>in</td><td>inbound</td></tr>
<tr><td>out</td><td>outbound</td></tr>
<tr><td>fw</td><td>forward</td></tr>
<tr><td>bw</td><td>backwards</td></tr>
</tbody></table>
<p>When a new socket type/protocol is used, it is necessary to register the type/protocol with the awareness framework. If it is not registered the commands <code>trace-sc</code> and <code>break-sc</code> will not be available for the new socket. As an example, for a socket that uses width 64 and protocol "MyProtocol", it is necessary to register the socket calling the function <code>registerSocketType&lt;64, MyProtocol&gt;()</code>.</p>
<div class="note">
<p>Tracing and breaking has certain limitations. Please refer to chapter <a class="reference" href="limitations.html">7</a>.</p>
</div>
<h2 id="logging">5.1 <a href="#logging">Logging</a></h2>
<p>SystemC Library implements report handler which forwards SystemC reports to Simics according to <code>sc_report</code> actions. Since SystemC does not have the concept of objects attached to log messages, all messages will be printed on the top-level <code>Adapter</code> object in Simics. It is possible to control SystemC logging level using <code>log-level</code> command on the <code>Adapter</code> object. Also, all the normal Simics logging commands, such as <code>log-setup</code>, <code>log-type</code>, work.</p>
<p>Simics performs a mapping from SystemC log concepts such as verbosity and severity into Simics concepts. The <code>sc_report</code> actions work as defined by IEEE-1666 standard. The most important mapping is the one from the SystemC verbosity to the Simics log-level, as shown in the table below:</p>
<table><thead><tr><th><strong>Simics log-level</strong></th><th><strong>SystemC verbosity</strong></th></tr></thead><tbody>
<tr><td>1</td><td>verbosity &lt; SC_MEDIUM</td></tr>
<tr><td>2</td><td>SC_MEDIUM ≤ verbosity &lt; SC_HIGH</td></tr>
<tr><td>3</td><td>SC_HIGH ≤ verbosity &lt; SC_DEBUG</td></tr>
<tr><td>4</td><td>SC_DEBUG ≤ verbosity</td></tr>
</tbody></table>
<p>Log messages map to the <em>info</em> category in Simics, unless the severity is greater than SC_WARNING, in which case the <em>error</em> category is used. It is also possible to emit <em>unimplemented</em> and <em>spec-violation</em> log categories by ending the message type with "unimplemented" or "unimpl", or "spec-violation" or "spec-viol", respectively. However, a severity greater than SC_WARNING will always generate an <em>error</em> log.</p>
<pre><code class="language-simics">simics&gt; <strong>lt.log-level level = 3</strong>
[lt] Changing log level: 1 -&gt; 3
simics&gt; <strong>bp.log.break object = lt</strong>
simics&gt; <strong>c</strong>
[lt info] 0 s - traffic_generator_thread
      Initiator: 101 Starting Traffic @ 0 s of traffic_generator.cpp in traffic_generator.cpp:114
[lt info] 0 s - traffic_generator_thread
      Initiator: 102 Starting Traffic @ 0 s of traffic_generator.cpp in traffic_generator.cpp:114
[lt info] 0 s - initiator_thread
      Initiator: 101 b_transport(GP, 0 s) @ 0 s of lt_initiator.cpp in lt_initiator.cpp:124
[lt info] 0 s - print
      ID: 201 COMMAND: WRITE Length: 04
      Addr: 0x0000000000000000 Data: 0x00000000 @ 0 s of memory.cpp in report.cpp:133
[lt info] 0 s - b_transport
      Target: 201 returned delay of 0 s + 20 ns + 60 ns = 80 ns @ 0 s of at_target_1_phase.cpp in at_target_1_phase.cpp:111
[lt info] 0 s - initiator_thread
      Initiator: 101 b_transport returned delay = 80 ns @ 0 s of lt_initiator.cpp in lt_initiator.cpp:145
[lt info] 0 s - initiator_thread
      Initiator: 102 b_transport(GP, 0 s) @ 0 s of lt_initiator.cpp in lt_initiator.cpp:124
[lt info] 0 s - print
      ID: 201 COMMAND: WRITE Length: 04
      Addr: 0x0000000000000000 Data: 0x00000000 @ 0 s of memory.cpp in report.cpp:133
[lt info] 0 s - b_transport
      Target: 201 returned delay of 0 s + 20 ns + 60 ns = 80 ns @ 0 s of at_target_1_phase.cpp in at_target_1_phase.cpp:111
[lt info] 0 s - initiator_thread
      Initiator: 102 b_transport returned delay = 80 ns @ 0 s of lt_initiator.cpp in lt_initiator.cpp:145
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
simics&gt; <strong></strong>
</code></pre>
<p>SystemC Library allows breaking simulation on SystemC log messages, which is enabled by <code>bp.log.break</code> command. It should be noted that Simics does not break immediately on the first log message, but rather after several log messages have been printed. This is because a "break" in Simics corresponds to stopping virtual time. All the log messages above were printed at the same virtual time, and thus there is no way to stop until all messages have been printed and virtual time is ready to move on. To understand what is going on between the various log messages, source level debugging is required.</p>
<h3 id="redirecting-custom-api-logs">5.1.1 <a href="#redirecting-custom-api-logs">Redirecting Custom API Logs</a></h3>
<p>Logs using <code>sc_report</code> are automatically integrated with the Simics logging system. However, since <code>sc_report</code> has some issues of its own it is common that SystemC developers have their own logging API or resort to using plain <code>std::cout</code>. While the use of standard streams for logging is highly discouraged this sections explains how to redirect these logs to Simics.</p>
<p>If a custom log API is being used, it is often possible to enable it to support multiple front ends. One simple approach is to specialize it to work in Simics using the standard set of <code>SIM_log*</code> functions, as described in the <em>API Reference Manual</em>. If the log API works with streams Simics provides a convenience class called <code>LogStream</code> that can be used. The convenience class has the following signature: </p>
<pre><code> template&lt;log_type_t Type = Sim_Log_Info,
         unsigned Level = 1,
         int Groups = 0&gt;
class LogStream : public std::ostream {
  public:
    explicit LogStream(ConfObjectRef log_obj)

 ... 
</code></pre>
<p>It is possible to use multiple <code>LogStream</code> objects to map different types of output to different Simics log-types, log-levels, and log-groups. The streams can be used wherever the logging API outputs to a <code>std::ostream</code> object and the log will automatically be turned into a Simics log message with the appropriate type, level, and group.</p>
<p>The <code>LogStream</code> can also be used to redirect standard streams, for example <code>std::cout</code>. This is done by replacing the stream's <code>streambuf</code> with the <code>streambuf</code> of the Simics <code>LogStream</code> as is shown in the example below. </p>
<pre><code>#include &lt;simics/systemc/awareness/log.h&gt;

class CoutRedirect : public simics::ConfObject {
  public:
    explicit CoutRedirect(simics::ConfObjectRef o)
        : simics::ConfObject(o),
          simLog_(o) {
        std::cout.rdbuf(simLog_.rdbuf());
    }

    static void init_class(simics::ConfClass *cls);

  private:
    void print_a_log() const {
        std::cout &lt;&lt; "Print a simple message to std::cout" &lt;&lt; std::flush;
    }

    simics::LogStream&lt;Sim_Log_Info, 2&gt; simLog_;

};
</code></pre>
<h2 id="systemc-signal-read-and-write">5.2 <a href="#systemc-signal-read-and-write">SystemC Signal Read and Write</a></h2>
<p>SystemC Library has support for read and write of SystemC signals <code>sc_signal</code>, <code>sc_in</code>, <code>sc_out</code>, and <code>sc_inout</code>. A signal's value can be read by invoking the Simics interface <code>sc_signal_read</code> on the signal object.</p>
<p>There is a second Simics interface, <code>sc_signal_write</code>, which is used to write a value to the signal object. Based on the type of signal, either the <code>sc_signal_read</code>, <code>sc_signal_write</code>, or both interfaces are implemented by the object.</p>
<div class="note">
<p>When writing a value to the signal object, the value will be updated during the next SystemC cycle. From the command line, simply invoke <code>c 1</code> will update the signal object's value.</p>
</div>
<p>SystemC signals use a template parameter that specifies the underlying value-type of the signal. This allows to use arbitrary classes as value-types. The current implementation directly supports the following value-types:</p>
<ul>
<li>bool </li>
<li>int8_t </li>
<li>int16_t </li>
<li>int32_t </li>
<li>int64_t </li>
<li>uint8_t </li>
<li>uint16_t </li>
<li>uint32_t </li>
<li>uint64_t </li>
<li>sc_time </li>
</ul>
<p>To support SystemC signals with a value-type not listed above, <code>simics::systemc::ScSignalAccessTemplate</code> needs to be implemented.</p>
<p>To activate support for the additional type, the template class needs to be instantiated. This is required to register the support for the new value-type in the infrastructure. One possibility is to declare it as a member variable of the Adapter.</p>
<p>Below is an example that shows the required steps to support signals with a value-type of <code>sc_dt::sc_bigint&lt;1024&gt;</code>. </p>
<pre><code> class BigInt1024Access
    : public simics::systemc::ScSignalAccessTemplate&lt;sc_dt::sc_bigint&lt;1024&gt; &gt; {
  public:
    bool attrToValueT(const attr_value_t *attr,
                      sc_dt::sc_bigint&lt;1024&gt; *value) const {
        const char *str = NULL;
        if (!attrToValue(attr, &amp;str))
            return false;

        *value = str;
        return true;
    }

    attr_value_t valueToAttrT(const sc_dt::sc_bigint&lt;1024&gt; &amp;value) const {
        std::string str = value.to_string();
        return valueToAttr(str.c_str());
    }
};


class Adapter : public scl::Adapter
[...]
    BigInt1024Access big_int_1024_access_;
[...]
</code></pre>
<p>The function <code>attrToValueT</code> implements the transformation from a Simics <code>attr_value_t</code> to the signal's value-type. If the transformation can not be performed, <code>false</code> must be returned, otherwise <code>true</code>.</p>
<p>The template class provides <code>attrToValue</code> functions to transform from <code>attr_value_t</code> to:</p>
<ul>
<li>bool </li>
<li>int64_t </li>
<li>int32_t </li>
<li>int16_t </li>
<li>int8_t </li>
<li>long long unsigned int </li>
<li>uint64_t </li>
<li>uint32_t </li>
<li>uint16_t </li>
<li>uint8_t </li>
<li>double </li>
<li>const char * </li>
</ul>
<p>The function <code>valueToAttrT</code> is used to transform from the SystemC signal value-type to a <code>attr_value_t</code>. The template class provides transformation for the the same types as listed above.</p>
<h2 id="systemc-library-tools">5.3 <a href="#systemc-library-tools">SystemC Library Tools</a></h2>
<p>SystemC Library comes with a variety of tools that use the Simics instrumentation framework and interact with the SystemC objects. For generic information on how Simics instrumentation framework works please refer to the chapter in 
<a href="../analyzer-user-guide/index.html">Analyzer User's Guide</a></p>
<h3 id="supported-systemc-objects">5.3.1 <a href="#supported-systemc-objects">Supported SystemC Objects</a></h3>
<p>The following table shows the different kinds of SystemC objects and when they interact with the SystemC Library tools:</p>
<table><thead><tr><th><strong>SystemC object</strong></th><th><strong>Event</strong></th></tr></thead><tbody>
<tr><td><code>sc_event</code></td><td>an event is notified</td></tr>
<tr><td><code>SC_METHOD</code></td><td>a method process is triggered</td></tr>
<tr><td><code>SC_THREAD</code></td><td>a thread process is triggered or resumed</td></tr>
<tr><td><code>tlm_initiator_socket</code></td><td>a TLM initiator socket method is called</td></tr>
<tr><td><code>tlm_target_socket</code></td><td>a TLM target socket method is called</td></tr>
<tr><td><code>sc_signal</code></td><td>a signal's value is changed</td></tr>
<tr><td><code>sc_in/sc_out/sc_inout</code></td><td>a port's value is changed</td></tr>
</tbody></table>
<h3 id="using-the-tools">5.3.2 <a href="#using-the-tools">Using the Tools</a></h3>
<p>There are two different ways to use the tools and their provided functionality. The user could use the Simics commands registered on the SystemC objects. These commands are tool-specific both in terms of functionality and usage. They automatically create an instrumentation tool for internal use by the commands. The user should avoid using this tool directly.</p>
<p>When using trace and break tools, existing DMI tables are automatically invalidated and the DMI hint is suppressed. When all tools have been removed, DMI hint is no longer suppressed - allowing the initiator to build up a new DMI table if supported.</p>
<p>In the following example, by invoking the command <code>trace-sc</code> on the SystemC target socket, an internal instrumentation tool is created and connected to the target socket. It traces the invocation of any socket method.</p>
<pre><code class="language-simics">simics&gt; <strong>simple.simple_device.target_socket.trace-sc</strong>
Created simple.internal.sc_trace_tool (connected to 1 provider)
</code></pre>
<p>For advanced instrumentation tasks, the user should use the Simics instrumentation framework directly. This makes it possible to use more tool features. It is, for example, possible to create a tool that only traces a certain event or method invocation. Other tools with different filtering options can of course be instantiated and operated in parallel.</p>
<p>The commands bound to the SystemC objects are covered in the tool specific sections below. The remainder of this section shows how the tools provided with SystemC Library can be used.</p>
<p>In the following example, a new trace tool is created that traces all supported SystemC objects. To avoid mixing different C++ ABIs, the standard SystemC tools are built together with the adapter as part of building the corresponding Simics module. The default name of the tool if not provided is prefixed with the module's name. For readability it is recommended to create the tool as a sub-object of the adapter instead, as shown by the example below, whenever that makes sense.</p>
<p>When using trace and break tools, existing DMI tables are automatically invalidated and the DMI hint is suppressed. When all tools have been removed, DMI hint is no longer suppressed - allowing the initiator to build up a new DMI table if supported.</p>
<pre><code class="language-simics">simics&gt; <strong>simple.new-sc-trace-tool -connect-all name=simple.trace_tool</strong>
[simple.gasket_simple_device_target_socket.initiator_socket trace-invalidate-dmi-in] start_addr:0x0 end_addr:0xffffffffffffffff
Created simple.trace_tool (connected to 7 providers)
</code></pre>
<p>The newly created tool can now be disabled, enabled and, if it is of no use anymore, removed. Additional SystemC objects can also be connected and disconnected. All this information is available by invoking the command <code>help</code> on the tool.</p>
<pre><code class="language-simics">simics&gt; <strong>help simple.trace_tool</strong>
</code></pre>
<p>To trace TLM sockets only, the user can instantiate a filter that only matches sockets and add it to the tool. The filter can be removed later to trace all supported objects again. There are four kinds of filters: signal, event, process and socket. All this information is available by invoking <code>help</code> on the <code>new-systemc-filter</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>new-systemc-filter socket</strong>
Created SystemC filter sc_filter0
simics&gt; <strong>simple.trace_tool.add-filter sc_filter0</strong>
simics&gt; <strong>simple.trace_tool.remove-filter sc_filter0</strong>
</code></pre>
<p>When connecting the tool to objects of socket kind the functions argument can be used to select which TLM2 functions to act on. The functions argument correspond to the methods in the <code>tlm_bw_transport_if</code> and <code>tlm_fw_transport_if</code> interfaces. For each interface method there exists a pair of pre and post functions. The pre function is used to instrument the transaction before it is sent through the socket. The post function is used to instrument the transaction after the invocation of the interface method has been performed.</p>
<p>The functions argument is optional. If omitted, all interface methods are handled by the tool. The argument is ignored and has no effect for connections to other kind of objects.</p>
<p>A summary of all tools and their supported functions can be shown by running: </p>
<pre><code class="language-simics">simics&gt; <strong>help topic = Instrumentation</strong>
</code></pre>
<h4 id="dynamic-systemc-objects">5.3.2.1 <a href="#dynamic-systemc-objects">Dynamic SystemC Objects</a></h4>
<p>SystemC allows to create and delete processes and events dynamically during simulation. Due to their dynamic nature, these objects do not have dedicated Simics configuration objects. Instead, they are grouped together and have one shared object for each type that can be used by the tools.</p>
<p><code>&lt;adapter&gt;.sc_event_all_dynamic</code> can be used to connect tools to all dynamic <code>sc_event</code> objects.</p>
<p><code>&lt;adapter&gt;.sc_process_all_dynamic</code> can be used to connect tools to all dynamic <code>SC_METHOD</code> or <code>SC_THREAD</code> objects.</p>
<p>The commands <code>trace-sc</code>, <code>untrace-sc</code>, <code>break-sc</code>, and <code>unbreak-sc</code> can be used on these two Simics configuration objects.</p>
<h3 id="sc_trace_tool">5.3.3 <a href="#sc_trace_tool">sc_trace_tool</a></h3>
<p>The <code>sc_trace_tool</code> can be used for tracing any event listed in section <a class="reference" href="#supported-systemc-objects">5.3.1</a>.</p>
<p>To enable or disable tracing of these events, <code>trace-sc</code> or <code>untrace-sc</code> needs to be invoked on the corresponding SystemC object. See <code>help &lt;sc_provider_controller&gt;.trace-sc</code> and <code>help &lt;sc_provider_controller&gt;.untrace-sc</code> for more information about the commands. Section <a class="reference" href="overview_of_systemc_features.html">5</a> contains an example of how to enable tracing on a TLM2 socket.</p>
<p>There is also a set of commands that makes it possible to trace and untrace on all objects of a certain kind. These commands are located in the corresponding adapter. The following commands <code>trace-sc-event-all</code>, <code>trace-sc-signal-all</code>, <code>trace-sc-process-all</code>, and <code>trace-sc-socket-all</code> are available for enabling instrumentation and the following commands <code>untrace-sc-event-all</code>, <code>untrace-sc-signal-all</code>, <code>untrace-sc-process-all</code>, and <code>untrace-sc-socket-all</code> are available for disabling instrumentation.</p>
<h3 id="sc_break_tool">5.3.4 <a href="#sc_break_tool">sc_break_tool</a></h3>
<p>The <code>sc_break_tool</code> is a tool that can be used to stop the simulation on any event listed in section <a class="reference" href="#supported-systemc-objects">5.3.1</a>.</p>
<p>To enable or disable break on these events, <code>break-sc</code> or <code>unbreak-sc</code> has to be invoked on the corresponding SystemC object. See <code>help &lt;sc_provider_controller&gt;.break-sc</code> and <code>help &lt;sc_provider_controller&gt;.unbreak-sc</code> for more information about the commands. Section <a class="reference" href="overview_of_systemc_features.html">5</a> contains an example of how to enable tracing on a TLM2 socket; the break tools works just like trace.</p>
<p>There is also a set of commands that makes it possible to break and unbreak on all objects of a certain kind. These commands are located in the corresponding adapter. The following commands <code>break-sc-event-all</code>, <code>break-sc-signal-all</code>, <code>break-sc-process-all</code>, and <code>break-sc-socket-all</code> are available for enabling instrumentation and the following commands <code>unbreak-sc-event-all</code>, <code>unbreak-sc-signal-all</code>, <code>unbreak-sc-process-all</code>, and <code>unbreak-sc-socket-all</code> are available for disabling instrumentation.</p>
<h3 id="sc_transaction_tracker_tool">5.3.5 <a href="#sc_transaction_tracker_tool">sc_transaction_tracker_tool</a></h3>
<p>To simplify debugging of complex SystemC models where multiple TLM transactions are sent between multiple sockets, Simics has a capability to track the path a transaction went through as well as to save the history of the transaction changes which happened when the transaction travelled along the path. This capability is provided by the <em>transaction tracker tool</em> which is based on Simics instrumentation framework.</p>
<p>To track a transaction the tool connects to TLM sockets of the SystemC model and observes all the transactions which are sent between the sockets. The tool adds special TLM extension to each transaction passed through a socket, if the transaction does not have the extension added earlier, and uses the extension to save the transaction history. A new entry, consisting of current transaction attributes and hierarchical name of the socket, is appended to the history when the transaction is passed through the socket. Currently, the only transaction attribute which is saved in the entry is transaction address.</p>
<p>To create and connect the tool to all sockets of the SystemC model one should use adapter's <code>track-transactions-all</code> command. Corresponding <code>untrack-transactions-all</code> command disconnects the tool from all the sockets. One may use <code>track-transactions</code> command of a selected socket to connect the socket to the tool, and <code>untrack-transactions</code> command to disconnect it. Also it is possible to use instrumentation tool commands, such as <code>add-instrumentation</code> or <code>remove-instrumentation</code>, to control connection of the tool to all or selected sockets. Please refer to corresponding <code>help</code> commands or the
<a href="../model-builder-user-guide/instrumentation.html#instrumentation">Instrumentation chapter</a> in the Model Builder User's Guide.</p>
<p>To view the transaction history user should enable GDB pretty printing for TLM transactions. The pretty printer output can be seen in GDB console.</p>
<h3 id="sc_protocol_checker_tool">5.3.6 <a href="#sc_protocol_checker_tool">sc_protocol_checker_tool</a></h3>
<p>The <code>sc_protocol_checker_tool</code> is a tool for validation of TLM2 transactions. It checks the transactions sent through sockets and detect those which are not in compliance with the "OSCI TLM-2.0 USER MANUAL".</p>
<div class="note">
<p>The checker is using the Doulos TLM-2.0 Base Protocol Checker of an older version. The checker will be upgraded to a more recent version checking against the IEEE Std 1666-2011 specification.</p>
</div>
<p>The <code>sc_protocol_checker_tool</code> supports <code>tlm_initiator_socket</code> and <code>tlm_target_socket</code> as stated in section <a class="reference" href="#supported-systemc-objects">5.3.1</a>. This tool does not have commands registered on the SystemC objects.</p>
<p>The protocol checker keeps track of the transaction state before the transaction is sent through a socket and after it returns. It checks all TLM socket methods for possible TLM2 transaction specification violations.</p>
<p>As an example, <code>&lt;adapter&gt;.new-sc-protocol-checker-tool -connect-all</code> can be used to check all sockets in a simulation.</p>
<h3 id="sc_vcd_trace_tool">5.3.7 <a href="#sc_vcd_trace_tool">sc_vcd_trace_tool</a></h3>
<p>The <code>sc_vcd_trace_tool</code> generates files based on the VCD format.</p>
<p>As an example, the command <code>&lt;adapter&gt;.new-sc-vcd-trace-tool file = myfile.vcd -connect-all</code> would generate a file in VCD format containing changes for any SystemC object listed in section <a class="reference" href="#supported-systemc-objects">5.3.1</a> with the exception of type <code>SC_THREAD</code> and <code>SC_METHOD</code>.</p>
<p>During generation, two files are created. One contains the header section with variable definitions and the second file contains the value change section. When Simics ends or the tool is deleted, these two files are merged together into a single file. If this merge can not be performed automatically, it should be sufficient to append the file with the value change section on to the header file. For instance: <code>cat myfile.vcd.tail &gt;&gt; myfile.vcd</code></p>
<h2 id="systemc-profiling">5.4 <a href="#systemc-profiling">SystemC Profiling</a></h2>
<p>To aid users in developing well-performing models, Simics offers two ways of profiling SystemC processes. These features encompass a process profiler, that helps users identify performance-heavy processes, and memory profiling, that compiles memory statistics of memory-intensive processes. Details on how to enable and use these features are presented below.</p>
<h3 id="process-profiler">5.4.1 <a href="#process-profiler">Process Profiler</a></h3>
<p>The process profiler feature measures wall clock time execution of method- and thread-processes. The feature is disabled by default, but can be enabled on adapters by using the <code>enable-process-profiler</code> command. The feature can be disabled again by using the command <code>disable-process-profiler</code>.</p>
<p>The profiling results can be obtained by using the adapter command <code>process-profiler-results</code>. This command will show the number of processes of each type and the number of calls and total time spent executing them.</p>
<p>If using the <code>status</code> command on a process, more detailed information will be shown. This information will consist of minimum time, maximum time, total time executing and number of calls to the process. For thread processes the number of calls will represent the number of times we yielded to that process.</p>
<p>The <code>clear-process-profiler-results</code> command clears accumulated profiling results. All process profiler data including the aggregated execution time is cleared.</p>
<h3 id="memory-profiling">5.4.2 <a href="#memory-profiling">Memory Profiling</a></h3>
<p>Memory profiling is enabled and disabled for each adapter by using the <code>enable-memory-profiler</code> and <code>disable-memory-profiler</code> commands. Memory profiling is disabled by default.</p>
<p>When memory profiling is enabled, Simics will record allocations and deallocations made in underlying processes. Please note that memory profiling has to be enabled for each adapter you wish to profile.</p>
<p>Users may inspect the current memory usage of a process by using the <code>status</code> command on the corresponding object in the awareness object hierarchy. Additionally, the collective memory usage of processes in a module may be inspected by using the <code>status</code> command on that module.</p>
<div class="note">
<p>Memory profiling has certain limitations listed in chapter <a class="reference" href="limitations.html">7</a>.</p>
</div>
<h2 id="trigger-systemc-processes">5.5 <a href="#trigger-systemc-processes">Trigger SystemC Processes</a></h2>
<p>SystemC Library supports unscheduled running of SystemC thread and SystemC method process objects. Two different options are available to run the processes. The first way is to locate the event object that the processes are sensitive to and invoke <code>notify</code> on the event object. This will cause all processes that are sensitive to the event object to be run during the next SystemC cycle. The second option is to locate the SystemC thread or process and invoke <code>run</code> on the object directly. The process will be run during the next SystemC cycle. This implies that <code>SIM_continue()</code> must be invoked before the process is run. From the command line, this corresponds to invoking <code>c 1</code>.</p>
<h2 id="tlm-injection">5.6 <a href="#tlm-injection">TLM Injection</a></h2>
<p>Sockets, registered with the awareness framework, provide the Simics <code>sc_tlm_fw_transport</code> and <code>sc_tlm_bw_transport</code> interfaces. The interfaces correspond to the SystemC TLM2 transport interfaces and support injection. The following rules specify the mapping between the Simics interfaces and the SystemC transport interfaces.</p>
<ul>
<li>The <code>attr_value_t</code> are dictionaries with <code>string</code> as key </li>
<li>The keys are based on namespaces to address the designated target </li>
<li>The namespace used for the transaction is <strong>gp</strong> </li>
<li>The namespace used for the <code>tlm_dmi</code> descriptor is <strong>dmi</strong> </li>
</ul>
<p>For example, injecting a write transaction into a socket could be done as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>dut.top.simple_initiator_socket_0.trace-sc</strong>
Created dut.internal.sc_trace_tool (connected to 1 provider)
simics&gt; <strong>@socket = dut.top.simple_initiator_socket_0.iface.sc_tlm_fw_transport</strong>
simics&gt; <strong>@socket.b_transport({'gp.command' : 1, 'gp.data_ptr' : (0, 1, 2, 3)}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] write sz:4 addr:0x0 data:0x03020100
[dut.top.simple_initiator_socket_0 trace-b-in] write sz:4 addr:0x0 data:0x03020100 status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>The transaction is injected into the socket by invoking <code>b_transport</code> of the <code>sc_tlm_fw_transport</code> interface. To avoid blocking Simics when the interface is called, the transaction is queued up and sent when simulation starts. This is only required for <code>b_transport</code>. All other functions of <code>sc_tlm_fw_transport</code> and <code>sc_tlm_bw_transport</code> execute their side-effects directly. The fields of the <code>tlm_generic_payload</code> are set by building the key prefixed with <strong>gp.</strong>, followed by the name of the setter function. The key <strong>gp.command</strong> addresses the generic payload and invokes <code>set_command</code> on the generic payload. The functions expects a <code>tlm_command</code> enum type when invoked in SystemC. For argument passing, enums are passed as <code>signed integer</code> types. The value 0 reflects a read transaction and 1 corresponds to a write transaction. This is according to the <code>tlm_command</code> enum definition in the SystemC kernel.</p>
<p>To simplify matters, <strong>gp.data_ptr</strong> invokes <code>set_data_ptr</code>, <code>set_data_length</code> and <code>set_streaming_width</code>. The following guidelines should be followed when setting the value of the key-value pair in dictionaries.</p>
<ul>
<li>Pointers to data are set via <code>attr_value_t</code> 'data' </li>
<li>The length of the data is encapsulated by the <code>attr_value_t</code> 'data', and should not be explicitly set </li>
<li>Arrays are set via <code>attr_value_t</code> 'list' </li>
<li>The length of the array is encapsulated by the <code>attr_value_t</code> 'list', and should not be explicitly set </li>
<li>Each extension is set as an attr_value_t 'dict' </li>
<li>For multiple function arguments of different types, use a 'dict' </li>
<li>For multiple function arguments of the same type, use a 'list' </li>
</ul>
<p>Injecting a read transaction into a socket could be done as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>@socket.b_transport({'gp.command' : 0, 'gp.data_ptr' : (0,) * 4}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] read sz:4 addr:0x0 data:0x00000000
[dut.top.simple_initiator_socket_0 trace-b-in] read sz:4 addr:0x0 data:0x03020100 status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>The length of the data to be read is specified by the Python tuple. Because the transaction is sent into the socket at a later point in time, the Simics instrumentation framework is used to display the actual data returned from the <code>b_transport</code> call.</p>
<p>To add an extension to the transaction, additional key-value pairs need to be set in the dictionary associated with the transaction argument. The table below lists the mapping between each namespace and the corresponding SystemC Library extension.</p>
<table><thead><tr><th><strong>Namespace key</strong></th><th><strong>Extension</strong></th></tr></thead><tbody>
<tr><td>ethernet_common</td><td>EthernetCommonExtension</td></tr>
<tr><td>i2c_master_v2</td><td>I2cMasterV2Extension</td></tr>
<tr><td>i2c_slave_v2</td><td>I2cSlaveV2Extension</td></tr>
<tr><td>map_info</td><td>MapInfoExtension</td></tr>
<tr><td>pci_bus</td><td>PciBusExtension</td></tr>
<tr><td>pci_device</td><td>PciDeviceExtension</td></tr>
<tr><td>pci_express</td><td>PciExpressExtension</td></tr>
<tr><td>pci_upstream_operation</td><td>PciUpstreamOperationExtension</td></tr>
<tr><td>serial_device</td><td>SerialDeviceExtension</td></tr>
</tbody></table>
<p>The key-value pairs for the extensions are specific. For details about the valid pairs, please refer to the implementation of the extension injector located in <code>simics/systemc/iface/</code>. One example that demonstrates the inject of a transaction with an <code>EthernetCommonExtension</code> set is shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>@data = tuple(bytearray(b'ABCDEF'))</strong>
simics&gt; <strong>@fraglist = [data[:4], data[4:]]</strong>
simics&gt; <strong>@frame = {'len' : len(data), 'fraglist' : fraglist}</strong>
simics&gt; <strong>@socket.b_transport({'ethernet_common.frame' : {'frame' : frame, 'crc_ok' : 1}}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] ignore sz:0 addr:0x0
[dut.top.simple_initiator_socket_0 trace-b-in] ignore sz:0 addr:0x0 status:TLM_OK_RESPONSE
</code></pre>
<h3 id="writing-an-injector-for-a-custom-extension">5.6.1 <a href="#writing-an-injector-for-a-custom-extension">Writing an Injector for a Custom Extension</a></h3>
<p>To support inject of extensions not provided by SystemC Library, <code>simics::systemc::injection::InjectBase</code> needs to be implemented.</p>
<p>To activate support for the additional injector, the template class needs to be instantiated. This is required to register the support for the new injector in the infrastructure. One possibility is to declare it as a member variable of the Adapter. Below is an example that shows the required steps to support a new extension. </p>
<pre><code> class CustomExtension : public tlm::tlm_extension&lt;CustomExtension&gt; {
  public:
    CustomExtension() : member_a_(0), member_b_(0),
                        member_d_(NULL), member_d_len_(0),
                        member_x_(0), member_y_(0) {}
    virtual tlm::tlm_extension_base *clone() const {
        return new CustomExtension(*static_cast&lt;const CustomExtension *&gt;(this));
    }
    virtual void copy_from(tlm::tlm_extension_base const &amp;extension) {
        *this = static_cast&lt;const CustomExtension &amp;&gt;(extension);
    }
    void set_member_b(uint8_t member) {
        member_b_ = member;
    }
    void set_xy(uint8_t x, int8_t y) {
        member_x_ = x;
        member_y_ = y;
    }
    virtual ~CustomExtension() {}
    uint8_t member_a_;
    uint8_t member_b_;
    std::vector&lt;uint8_t&gt; member_c_;
    const uint8_t *member_d_;
    uint64_t member_d_len_;

  private:
    uint8_t member_x_;
    int8_t member_y_;
};

#include &lt;simics/systemc/injection/inject_base.h&gt;  // NOLINT

template &lt;typename TPAYLOAD&gt;
class InjectCustomExtension
    : public simics::systemc::injection::InjectBase&lt;TPAYLOAD&gt; {
  public:
    ATTR_DICT_PARSER_NAMESPACE("custom.")

    virtual bool setValue(simics::systemc::injection::AttrDictParser *parser,
                          const std::string &amp;key, attr_value_t *attr,
                          TPAYLOAD *gp) {
        if (key == "member_a") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!parser-&gt;value(&amp;extension-&gt;member_a_))
                return false;

            return true;
        }

        INJECT_SET_VALUE(set_member_b, uint8_t, CustomExtension);

        if (key == "set_xy") {
            simics::systemc::injection::AttrDictParser p = parser-&gt;init(attr);
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);
            uint8_t x = 0;
            if (!p.lookUp("x", &amp;x))
                return false;

            int8_t y = 0;
            if (!p.lookUp("y", &amp;y))
                return false;

            extension-&gt;set_xy(x, y);
            return true;
        }

        if (key == "member_c") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!parser-&gt;value(&amp;extension-&gt;member_c_))
                return false;

            return true;
        }

        if (key == "member_d") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!SIM_attr_is_data(*attr)) {
                parser-&gt;reportError("member_d must be data");
                return false;
            }
            extension-&gt;member_d_ = SIM_attr_data(*attr);
            extension-&gt;member_d_len_ = SIM_attr_data_size(*attr);

            return true;
        }

        return false;
    }
};

static InjectCustomExtension&lt;tlm::tlm_generic_payload&gt; injector_;
</code></pre>
<p>The example shows different ways to set the members in the <code>CustomerExtension</code>. If the member in the extension is directly accessible, it could be set as shown for <strong>member_a</strong>. Data access is usually provided by setters and getters, <code>set_member_b</code> can be called by <code>INJECT_SET_VALUE</code>. If multiple arguments are required by the extension method, the arguments should be grouped in another dictionary or list as key <strong>set_xy</strong> shows. The key <strong>member_c</strong> demonstrates how a Python list can be loaded into a <code>vector</code>. Setting a data pointer is shown by key <strong>member_d</strong>. If a member in the extension cannot be properly setup, <code>false</code> must be returned. The failing key will be reported as an error and the inject call will be aborted.</p>
<p>The corresponding calls to setup the extension from Python could be as in the following example.</p>
<pre><code class="language-simics">simics&gt; <strong>@socket.b_transport({'custom.member_a' : 1}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.set_member_b' : 2}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.set_xy' : {'x' : 3, 'y' : 4}}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.member_c' : [5, 6]}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.member_d' : (7, 8, 9)}, 0)</strong>
</code></pre>
<h2 id="unconnected-ports">5.7 <a href="#unconnected-ports">Unconnected Ports</a></h2>
<p>According to SystemC language standard, port instances defined by <code>sc_port</code> class cannot remain unbound at the end of elaboration, unless allowed by port policy. SystemC Library optionally permits using unbound ports. Such ports are then automatically bound to a dynamically allocated object implementing the corresponding interface. Access to an unbound port will log an unimplemented message in Simics, for example:</p>
<pre><code>[device unimpl] Access to unbound port: device.simple_initiator_socket_0 @ 0 s
of intc/unimplemented in unconnected_base.h:28
</code></pre>
<p>The feature is disabled by default and can be enabled using <em>allow_unconnected_ports</em> attribute of the SystemC adapter. The list of supported unbound ports includes specialized <code>sc_in</code>, <code>sc_out</code> and <code>sc_inout</code> ports as well as socket ports which use the standard TLM-2.0 forward and backward transport interfaces.</p>

<div class="chain">
<a href="connecting-systemc-and-simics-models.html">4 Connecting SystemC and Simics Models</a>
<a href="execution-of-systemc-models-in-the-simics-simulator.html">6 Execution of SystemC Models in the Simics Simulator</a>
</div>