<!doctype html>
<head>
<meta charset="utf-8">
<title>8 Simics Model Development Checklist</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="dml-tips-and-tricks.html">7 DML Tips and Tricks</a>
<a href="advanced-programming-with-dml.html">9 Advanced Programming with DML</a>
</div>
<div class="path">
<a href="index.html">Model Builder User's Guide</a>
&nbsp;/&nbsp;
<a href="part-device-modeling.html">II Device Modeling</a>
&nbsp;/&nbsp;</div>
<h1 id="simics-model-development-checklist">8 <a href="#simics-model-development-checklist">Simics Model Development Checklist</a></h1>
<p>This chapter provides a checklist for use when developing models of devices and systems for Simics. The intention is to help developers with creating high quality models that work well in Simics, including future versions, that behave in a way that Simics users expect models to, and that can be used together with other device models easily.</p>
<h2 id="generic-checklist">8.1 <a href="#generic-checklist">Generic Checklist</a></h2>
<p>This section describes important generic items that should be taken into consideration when working with Simics. This applies if one is writing device models, components or general functionality to extend Simics.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:ge-01-checkpointing"><em>GE-01</em> — Checkpointing</span><br>
Device models and other Simics extensions must support checkpointing. All state associated with the modeled machine should be included in the checkpoint. The simulation session is not checkpointed. Simply loading a machine, taking a checkpoint without having advanced the simulation and restarting from that checkpoint should result in the same machine state. The same should be true at anytime during the simulation and care must be taken to checkpoint any transient state in a module, such as pending events.</p>
<p>For more information refer to the sections about events and attributes in
"Programming with DML", the section about general usability in "Building
Well-Behaved Models" and the section about configuration attributes in
"Overview" in the <em>Model Builder User's Guide</em>. Also refer to the section
"Configuration and Checkpointing" in the  <em>Simics User's Guide</em></p>
</li>
<li>
<p><span class="term" id="dt:ge-02-reverse-execution"><em>GE-02</em> — Reverse Execution</span><br>
Models that are deterministic and support checkpointing also work with reverse execution. But the performance of the attribute get/set methods, as well as their memory consumption, are more important. Use <code>image</code> objects for storing data-type attributes, such as internal memories, of more than a few kilo bytes. This can have dramatic effects on performance, especially when reverse execution is enabled. See also <em>GE-13</em>.</p>
<p>For more information refer to the sections about events and attributes in
"Programming with DML", the section about general usability in "Building
Well-Behaved Models" and the section about configuration attributes in
"Overview" in the <em>Model Builder User's Guide</em>. Also refer to the section
"Configuration and Checkpointing" in the <em>Simics User's Guide</em></p>
</li>
<li>
<p><span class="term" id="dt:ge-03-use-the-most-recent-api"><em>GE-03</em> — Use the Most Recent API</span><br>
The most recent version of the Simics API should be used. Functions and interfaces marked as deprecated should be avoided.</p>
<p>The latest API is documented in the <em>Reference Manuals</em> included in each Simics package.</p>
</li>
<li>
<p><span class="term" id="dt:ge-04-use-standard-simics-interfaces"><em>GE-04</em> — Use Standard Simics Interfaces</span><br>
The Simics <em>interface</em> mechanism should be used when communicating between objects. The standard interface types should be used when possible, allowing newly developed objects to connect to existing ones. References between objects should be implemented using attribute, with the type "os" for port interfaces, "o" for interfaces implemented by the object without any port and "n" to allow no connection. It is recommended that all three variants are supported, i.e. "os|o|n".</p>
<p>For more information see the section about Simics interfaces in "Overview"
in the <em>Model Builder User's Guide</em>. The standard interfaces are documented
in the <em>Reference Manuals</em> included in each Simics package.</p>
</li>
<li>
<p><span class="term" id="dt:ge-05-host-independence"><em>GE-05</em> — Host Independence</span><br>
Code should be written to work on both little- and big-endian host systems. Operating system specifics should be avoided if possible, allowing code to run on Windows and Linux. Any access to the host, for example a real network, real display, real USB, etc, should be in a separate "host access" module and not in the device itself </p>
</li>
<li>
<p><span class="term" id="dt:ge-06-use-compiler-to-catch-possible-errors"><em>GE-06</em> — Use Compiler to Catch Possible Errors</span><br>
All code should compile without warnings. It is recommended that the default flags for the compiler in the Simics build environment are used. For GCC, this is something like <code>-O2 -Wall -Werror</code>. </p>
</li>
<li>
<p><span class="term" id="dt:ge-07-implement-info-and-status-commands"><em>GE-07</em> — Implement <code>info</code> and <code>status</code> Commands</span><br>
All Simics classes should have an <code>info</code> and a <code>status</code> command. The <code>info</code> shows static information about an object. Required attributes used for configuration are typically presented here. The <code>status</code> command shows dynamic information about an object. For really detailed information, a class specific command is better suited. Objects that do not have any dynamic information should print this fact in the <code>status</code> command output.</p>
<p>For more information refer to the section about general usability in
"Building Well-Behaved Models" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:ge-08-check-for-memory-leaks"><em>GE-08</em> — Check for Memory Leaks</span><br>
A module should not leak memory while running the simulation, including when taking checkpoints and using reverse execution. The internal Simics command <code>mm-list-*</code> can be used to see where memory has been allocated. To enable the command, set the environment variable <code>SIMICS_MEMORY_TRACKING</code> before starting Simics and enable internal commands, using the <code>enable-unsupported-feature "malloc-debug"</code> command.</p>
<p>For more information see the application note on <em>Debugging User-Developed Simics Modules</em>.</p>
</li>
<li>
<p><span class="term" id="dt:ge-09-no-side-effects-on-attribute-reads"><em>GE-09</em> — No Side Effects on Attribute Reads</span><br>
There should never be any side effects when attributes are read. It should always be possible to read out attribute values without affecting the model.</p>
<p>For more information refer to the sections about attributes in "Programming with DML" and the section about configuration attributes in "Overview" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:ge-10-class-attribute-and-command-documentation"><em>GE-10</em> — Class, Attribute and Command Documentation</span><br>
Classes, non-internal attributes and CLI commands should all be properly documented. For attributes that users may change, all allowed values have to be described.</p>
<p>For more information refer to the sections about structuring DML code in "Building Well-Behaved Models" and "Adding New Commands" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:ge-11-follow-naming-guidelines"><em>GE-11</em> — Follow Naming Guidelines</span><br>
Try to use coherent naming when creating files, classes, components, objects, attributes and commands in Simics. As a general rule, use lower case names. Abbreviations may be written in all capital letters, but avoid mixing upper and lower case letters, e.g., do not use capitalization. Avoid special characters and stick to plain ASCII.</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:directories-c-c-dml-and-simics-files">Directories, C/C++, DML and .simics files</span><br>
Use dash instead of underscore. Do not use spaces. </li>
<li><span class="term" id="dt:python-files">Python files</span><br>
Use underscore instead of dash since the file name is used as a module name in Python.</li>
<li><span class="term" id="dt:component-modules">Component Modules</span><br>
Component modules typically end with the <code>-comp</code> suffix. </li>
<li><span class="term" id="dt:classes-and-components">Classes and components</span><br>
Use dash or underscore for class names in C and DML.<br>
Use underscore for class and component names in Python (mandatory).</li>
<li><span class="term" id="dt:objects-and-attributes">Objects and attributes</span><br>
Use underscore in all names to simplify Python wrapping. Support for using dashes in these names will be removed in the future.</li>
<li><span class="term" id="dt:commands">Commands</span><br>
Use dash to separate words. Commands typically have the form &lt;verb&gt;-&lt;noun&gt;, for example <code>list-objects</code>.</li>
</ul>
</div>
<p>Look at the existing naming for things not covered by the guidelines here.</p>
</li>
<li>
<p><span class="term" id="dt:ge-12-avoid-using-indexed-attributes"><em>GE-12</em> — Avoid Using Indexed Attributes</span><br>
Index support for attributes should only be added if it is really needed for performance reasons. When lists attributes have index support, the index should run from 0 up to <code>size</code> - 1. If this is not the case, a dictionary attribute should be used instead of a list. </p>
</li>
<li>
<p><span class="term" id="dt:ge-13-write-deterministic-models"><em>GE-13</em> — Write Deterministic Models</span><br>
A simulation model should behave <em>exactly</em> the same way when it is run with identical external stimuli (e.g., using a recorder, or only scripted input). Never use host functions that do not behave identically between runs in your model, such as <code>gettimeofday()</code> or <code>rand()</code>.</p>
<p>This is essential for reverse execution to work correctly, and greatly helps in pinpointing bugs, as those are guaranteed to be repeatable in a deterministic simulation.</p>
<p>For more information refer to the section about general usability in "Building Well-Behaved Models" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:ge-14-check-spelling"><em>GE-14</em> — Check Spelling</span><br>
All user visible strings should be checked for correct spelling and grammar. </p>
</li>
<li>
<p><span class="term" id="dt:ge-15-do-not-assert-on-user-errors"><em>GE-15</em>— Do not Assert on User Errors</span><br>
Errors that can be triggered by a user, for example by running target software that does not follow the specification should not cause Simics to assert. For errors signalling use log messages of the "info", "spec-violation" or "error" type depending on severity. Assert should only be used to protect against bugs in the simulator code. </p>
</li>
<li>
<p><span class="term" id="dt:ge-16-do-not-use-deprecated-features"><em>GE-16</em> — Do Not Use Deprecated Features</span><br>
Avoid using features listed as deprecated in the <em>Simics Migration Guide</em>. Check the <code>prefs</code> object for settings (attributes) whose names start with <code>legacy_</code>. Make sure your system works with all such settings turned off. Also run Simics with the <em>-wdeprecated</em> command line argument and make sure that there are no run-time warnings generated during simulation.</p>
</li>
<li>
<p><span class="term" id="dt:ge-17-avoid-saving-attributes-as-binary-data"><em>GE-17</em> — Avoid Saving Attributes as Binary Data</span><br>
Structured attribute data should not be saved in binary form, since it prevents user inspection, for example by the info and status commands, and makes it difficult to keep compatibility with old checkpoints. Binary data should only be used when saving memory images and similar. </p>
</li>
</ul>
</div>
<h2 id="device-checklist">8.2 <a href="#device-checklist">Device Checklist</a></h2>
<p>This section describes important items that, in addition to the generic checklist, should be taken into consideration when writing device models. For more in depth understanding of the importance of these items, please refer to the <em>Model Builder User's Guide</em>.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:de-01-source-code-in-dml"><em>DE-01</em> — Source Code in DML</span><br>
Device models should in general be written in DML. Example of an exception to this rule is code for algorithms already available, or better expressed, in some other language. </p>
</li>
<li>
<p><span class="term" id="dt:de-02-reset-support"><em>DE-02</em> — Reset Support</span><br>
Models of devices with one or more reset inputs should properly implement reset. The Simics <code>signal</code> interface should be used as input with one port interface for each reset input. </p>
</li>
<li>
<p><span class="term" id="dt:de-03-logging"><em>DE-03</em> — Logging</span><br>
The standard Simics log mechanism should be used to trace things happening in the device. It is important that target software access to unimplemented registers and features of the device are properly logged with the correct type.</p>
<p>A message is most of the time a fragment or, more rarely, one or more complete sentences. If it is a fragment, the message shall start with a lowercase letter (with the obvious exception for words and abbreviations that shall start with an uppercase letter) and have no period at the end. Sentences shall start with an uppercase letter and end with a period.</p>
<p>In DML, a typical log statement may read: <code>log info, 2, 0: "increased counter: %d", value;</code>.</p>
<p>Do not use exclamation marks and avoid question marks. Multiple question marks in a row shall never be used.</p>
<p>Do not start an "info" message with the words "error", "unimplemented" or "spec_violation", use the appropriate log-type instead.</p>
<p>Do not start an "error" message with the word "error", it is just a repetition. The word "error" might be appropriate inside the message but should in most circumstances be avoided. Same goes for the "critical", "spec_violation", and "unimplemented" log-types.</p>
<p>Do not use newlines, in particular not at the end of the message. Also do not use multiple log statements to output longer messages, include everything in one statement. It is up to the presentation layer to output a long message in a readable format.</p>
<p>Do not mention the name of the object or class which the message refers to, as it is implicitly given by the log statement and output in the log message prefix.</p>
<p>For abbreviations and other special words, write them as specified in the "Dictionary" chapter of the "Writing Documentation" manual or in the <code>src/docs/common/simics-documentation-word-list</code> or <code>src/docs/internal/documentation-manual/usage.docu</code> files. Here are some examples: IRQ, DMA, CPU, CPUs.</p>
<p>A message followed by a more specific message, such as: <code>"can't open file "abc": no such file or directory"</code> should be (as above) separated by a colon. If even more specific messages follow, these are also appended using a colon as separator.</p>
<p>A message which contains some extra information at the end should be written as: <code>"read from register XYZ (value = 0x5000)"</code></p>
<p>Do not use cryptic abbreviations such as @, addr, idx, reg, len. Instead use: at, address, index, register, length</p>
<p>Do not use variable names (if they aren't complete words) in log messages with log levels 1-3. If values are output, it should be possible to understand what the value represents without reading the source code. I.e. it should be possible to understand the log message without reading the source code.</p>
<p>Do not use assert statements on conditions that can be triggered by users, see <em>GE-15</em>.</p>
<p>Use pre-defined DML templates for different implementations. Log level is automatically handled in some of these templates. For example, <code>reserved</code>, <code>unimplemented</code> and <code>read_only</code>. Full list and descriptions about these templates can be found in the <em>Model Builder DML 1.2</em> reference manual.</p>
<p>Spec-violation and unimplemented messages are typically logged on level 1. Sometimes they are first logged at log level 1 then log level 3 for spam reduction when unimplemented registers or features are always accessed. log level 3 should be avoided for spec-violation.</p>
<p>For more information refer to "Logging" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:de-04-avoid-sim_-functions-when-modeling-behavior"><em>DE-04</em> — Avoid <code>SIM_</code> Functions when Modeling Behavior</span><br>
Code that models the behavior of a device should avoid <code>SIM_</code> and internal <code>VT_</code> functions as far as possible. Such functions are mainly intended for simulator specifics such as configuration and logging, but not to model the actual device. Simics interfaces should be used instead to communicate with other objects that a device is connected to. The most common exceptions are <code>SIM_</code> functions used to access fields in the <code>generic_transaction_t</code>, timing API functions and event API functions for devices not written in DML. </p>
</li>
<li>
<p><span class="term" id="dt:de-05-avoid-attribute-access-when-modeling-behavior"><em>DE-05</em> — Avoid Attribute Access when Modeling Behavior</span><br>
Simics attributes are intended for configuration and diagnostic access to a device. Communication between devices should use Simics interfaces and not rely on reading or writing attributes.</p>
<p>For more information see the section about Simics interfaces in "Overview"
in the <em>Model Builder User's Guide</em>. The standard interfaces are documented
in the <em>Reference Manuals</em> included in each Simics package.</p>
</li>
<li>
<p><span class="term" id="dt:de-06-handle-persistent-storage"><em>DE-06</em> — Handle Persistent Storage</span><br>
Some kinds of storage are persistent and survive power cycling, for example NVRAMs, certain device registers, and disk images. Models of such entities should be handled as persistent in Simics, allowing the <code>save-persistent-state</code> and <code>load-persistent-state</code> commands to work properly for simulating power off followed by power on. To check which images are marked as persistent, use the <code>list-persistent-images</code> command.</p>
<p>The <code>image</code> interface on objects of the Simics <code>image</code> class provides a way to mark an image object as holding persistent data. Custom disk and storage models must call this interface on their associated image objects, if they are persistent.</p>
<p>Device register and device state saved in attributes are marked as persistent by using the <code>Sim_Attr_Persistent</code> flag on the attribute when it is registered with Simics.</p>
<p>For NVRAMs the <code>persistent-ram</code> class can be used.</p>
<p>For more information see the section about saving and restoring persistent
data in "Configuration and Checkpointing" in the <em>Simics User's Guide</em></p>
</li>
<li>
<p><span class="term" id="dt:de-07-use-dml-device-class-library-code"><em>DE-07</em> — Use DML Device Class Library Code</span><br>
Device models should share common code if possible, such as the generic PCI,
I2C or MII device code, see the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:de-08-document-limitations"><em>DE-08</em> — Document Limitations</span><br>
Parts and features of a device that is not modeled should be described in documentation. For devices written in DML, use the <code>limitations</code> parameter. For devices not written in DML add the information to the class documentation. Use free form complete sentences or bullet lists:</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;The X device does not implement Y hashing.&lt;/li&gt;
  &lt;li&gt;The Z feature does not work with the Windows 7 driver.&lt;/li&gt;
  &lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>See the <em>DML 1.4 Reference Manual</em> for more information.</p>
<p>Unimplemented registers, or registers with limited functionality, should use the standard Simics log mechanism with the <code>Sim_Log_Unimplemented</code> type to log any accesses.</p>
</li>
<li>
<p><span class="term" id="dt:de-09-performance"><em>DE-09</em> — Performance</span><br>
Devices should be written with performance in mind. In general this simply
means avoiding expensive operations and using events instead of polling. The
<em>Model Builder User's Guide</em> includes a discussion on performance for device
models.</p>
</li>
<li>
<p><span class="term" id="dt:de-10-internal-device-to-device-register-access"><em>DE-10</em> — Internal Device to Device Register Access</span><br>
Device objects should use the <code>int_register</code> interface if it has to access registers in another object directly. The typical case is for objects that represent tightly coupled devices. In other situations the devices can use the architecturally specified way of communicating, for example by doing memory mapped accesses or sending bus transactions if a bus interface exists.</p>
<p>The <code>int_register</code> interface is documented in the <em>Simics Reference Manual</em> </p>
</li>
<li>
<p><span class="term" id="dt:de-11-handle-inquiry-accesses"><em>DE-11</em> — Handle inquiry accesses</span><br>
Device objects should handle inquiry accesses without performing any side effects beyond changing the state of the register itself. This is done automatically for registers which does not override the <code>read_access</code> and <code>write_access</code> methods, but if you override these methods or implement the access at the bank level you have to implement it yourself.</p>
</li>
<li>
<p><span class="term" id="dt:de-12-reboot-support"><em>DE-12</em> — Reboot Support</span><br>
A machine model should support system reboot. This means software reboot and commands to trigger any reset buttons. Reset signals are typically distributed between simulated devices using the <code>signal</code> interface unless reset is already part of some technology specific interface such as the <code>pci_device</code> interface. </p>
</li>
<li>
<p><span class="term" id="dt:de-13-optional-attributes-should-be-optional"><em>DE-13</em> — Optional attributes should be optional</span><br>
Any optional attribute should be truly optional. It should make sense and be possible to instantiate the object without setting any optional attributes. Accesses to the device should not cause simulation errors if any optional attributes are not set, for example dereferencing a NIL pointer for an optional object attribute. </p>
</li>
<li>
<p><span class="term" id="dt:de-14-support-multiple-instantiation"><em>DE-14</em> — Support Multiple Instantiation</span><br>
It should always be possible to create multiple instances of a device model, for example to have several similar systems networked together. </p>
</li>
<li>
<p><span class="term" id="dt:de-15-use-standard-memory-classes-when-possible"><em>DE-15</em> — Use Standard Memory Classes When Possible</span><br>
When modeling address spaces, reusing the Simics <code>memory-space</code> or <code>port-space</code> classes is almost always possible. Similarly, the <code>ram</code>, <code>rom</code> and <code>persistent-ram</code> classes should be used to model RAM and ROM. This is true also for on-chip memory, unless the memory is very small, perhaps a few kilobytes or less. The storage for larger memory areas should be implemented using the standard <code>image</code> class, that provides delta checkpointing and efficient run-time memory handling.</p>
</li>
<li>
<p><span class="term" id="dt:de-16-only-use-the-device-api"><em>DE-16</em> — Only Use the Device API</span><br>
When writing device models only the Device API should be used. API function, and interfaces, from the Simulator API should not be used. The Device API is documented in the Model Builder User's Guide. See also <em>DE-04</em> about avoiding <code>SIM_</code> functions. </p>
</li>
<li>
<p><span class="term" id="dt:de-17-support-deletion"><em>DE-17</em> — Support Deletion</span><br>
It should be possible to delete object of the device class. All allocated memory should be freed, events should be cancelled, etc.</p>
</li>
</ul>
</div>
<h3 id="ethernet-devices">8.2.1 <a href="#ethernet-devices">Ethernet Devices</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:et-01-separate-transceiver-phy-model"><em>ET-01</em> — Separate Transceiver (PHY) Model</span><br>
Ethernet devices where the transceiver is visible to the software, for example exposed by the <em>MII</em> or similar interface, should have the transceiver modeled as a separate object in Simics. This allows for reuse of transceivers and a number of such models already exist, including a generic MII transceiver.</p>
<p>For more information see the section on Ethernet transceiver in "Modeling Ethernet Devices" in the <em>Model Builder User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:et-02-bandwidth-limitation"><em>ET-02</em> — Bandwidth Limitation</span><br>
Ethernet devices should use the standard bandwidth limitation support provided by the <code>ieee_802_3_phy_v3</code> interface. This interface is used when communicating with PHY devices. </p>
</li>
<li>
<p><span class="term" id="dt:et-03-configurable-mac-address"><em>ET-03</em> — Configurable MAC Address</span><br>
Ethernet devices should provide a way to set the Ethernet MAC address when setting up the system. Typically by providing a <code>mac_address</code> attribute. </p>
</li>
</ul>
</div>
<h3 id="interrupt-devices">8.2.2 <a href="#interrupt-devices">Interrupt Devices</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:in-01-edge-vs-level-triggered-interrupts"><em>IN-01</em> — Edge vs. Level Triggered Interrupts</span><br>
Interrupt inputs are either edge or level triggered. The device should correctly model the kind used for each input. </li>
<li><span class="term" id="dt:in-02-use-signal-interface-ports-for-input"><em>IN-02</em> — Use <code>signal</code> Interface Ports for Input</span><br>
Each interrupt input should be implemented using a port interface of the <code>signal</code> type. </li>
</ul>
</div>
<h3 id="pci-devices">8.2.3 <a href="#pci-devices">PCI Devices</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:pc-01-the-print-pci-config-regs-command"><em>PC-01</em> — The <code>print-pci-config-regs</code> Command</span><br>
The standard <code>&lt;pci-device&gt;.print-pci-config-regs</code> command should be supported by all PCI devices. </li>
<li><span class="term" id="dt:pc-02-expansion-rom"><em>PC-02</em> — Expansion ROM</span><br>
Components for PCI devices that may be configured with an on-board ROM image should have a <code>bios</code> attribute that is the image file for the expansion ROM. </li>
</ul>
</div>
<h3 id="serial-devices">8.2.4 <a href="#serial-devices">Serial Devices</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:se-01-intentionally-left-out"><em>SE-01</em> — <em>Intentionally left out.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:se-02-support-baud-rate-but-allow-override"><em>SE-02</em> — Support Baud Rate but Allow Override</span><br>
Serial devices should obey the baud rate setting since software may not work with an unrealistic timing behavior. Still, for simulator performance reasons, it is often of interest to optionally run faster in virtual time than the actual device would.</p>
</li>
</ul>
</div>
<h2 id="processor-model-checklist">8.3 <a href="#processor-model-checklist">Processor Model Checklist</a></h2>
<p>This section describes important items that, in addition to the generic
checklist, should be taken into consideration when writing processor models. For
more information about processor models, see the <em>Processor Model Integration
Guide</em>.</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:pr-01-trigger-standard-haps"><em>PR-01</em> — Trigger Standard Haps</span><br>
Processor models should trigger standard haps. </li>
<li><span class="term" id="dt:pr-02-support-common-processor-commands"><em>PR-02</em> — Support Common Processor Commands</span><br>
Processor should implemented the same set of commands with the same semantics as pre-existing processor models. </li>
<li><span class="term" id="dt:pr-03-support-standard-interfaces"><em>PR-03</em> — Support Standard Interfaces</span><br>
Interfaces listed in the Processor Model Integration Guide should be supported by a processor model. </li>
<li><span class="term" id="dt:pr-04-simics-style-register-names"><em>PR-04</em> — Simics Style Register Names</span><br>
To support remote GDB and allow portable Simics scripts, register names used in the int register interface must be Simics style names. </li>
</ul>
</div>
<h2 id="component-checklist">8.4 <a href="#component-checklist">Component Checklist</a></h2>
<p>This section describes important items that, in addition to the generic checklist, should be taken into consideration when writing components. For more in depth understanding of the importance of these items, please refer to the <em>Model Builder User's Guide</em>.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:co-01-checkpointing-of-connection-information"><em>CO-01</em> — Checkpointing of Connection Information</span><br>
Information that a component receives from another component in a connect method call may have to be checkpointed in case that information has to be used again. This is sometimes the case with hot-plug connections. </p>
</li>
<li>
<p><span class="term" id="dt:co-02-naming-of-components-and-objects"><em>CO-02</em> — Naming of Components and Objects</span><br>
Until there are proper guidelines for component, connector, and object names, check existing objects in Simics for examples. Some common names are:</p>
<ul>
<li><code>eth_adapter</code> — basename for Ethernet PCI cards. </li>
<li><code>ethernet</code> — ethernet-link connector name for components with a single ethernet-link connector. </li>
</ul>
</li>
<li>
<p><span class="term" id="dt:co-03-use-standard-connector-types-when-possible"><em>CO-03</em> — Use Standard Connector Types When Possible</span><br>
The standard component connector types are listed in the <em>Model Builder User's Guide</em>. By using the standard types, the component can more easily be reused in other systems.</p>
</li>
<li>
<p><span class="term" id="dt:co-04-correct-component-abstraction"><em>CO-04</em> — Correct Component Abstraction</span><br>
Components should represent real separate hardware entities with standard hardware interfaces, such as PCI or Ethernet. It should only be possible to build valid systems using components and their connectors. More low-level kinds of connections should be done between configuration objects within the components.</p>
</li>
<li>
<p><span class="term" id="dt:co-05-implement-standard-attributes-and-names"><em>CO-05</em> — Implement Standard Attributes and Names</span><br>
Components should implement standard attributes, and in some cases have well
defined sub-strings in their names, that are used by the GUI to extract
system information. This applies to top-level components, components with
memory, Ethernet connectors or disks on them. A complete list is included in
the section about component references in "Components" in the <em>Model Builder
User's Guide</em>. Some commonly used component attribute names are:</p>
<ul>
<li><code>cpu_frequency</code> </li>
<li><code>num_cpus</code> </li>
<li><code>num_cores</code> </li>
<li><code>memory_megs</code> — for components with RAM. </li>
<li><code>rtc_time</code> — format: "YYYY-MM-DD HH:MM:SS Z". </li>
<li><code>mac_address</code> — single Ethernet device. </li>
<li><code>mac_address0, mac_address1, ...</code> — multiple Ethernet devices. </li>
<li><code>size</code> — for disk components. </li>
</ul>
</li>
<li>
<p><span class="term" id="dt:co-06-slot-names"><em>CO-06</em> — Slot Names</span><br>
The slot names in the component should be chosen with care since there can
be name conflicts with attributes and commands for the component. The
priority order for conflicting names are defined in the <em>Model Builder
User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:co-07-intentionally-left-out"><em>CO-07</em> — <em>Intentionally left out.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:co-08-component-error-handling"><em>CO-08</em> — Component Error Handling</span><br>
It should always be possible to create a non-instantiated component as long as the provided arguments are valid. If the component requires any external file, for example, then it should check for its existence and possibly signal any error in the <code>pre_instantiate</code> method. The <code>connect_&lt;connection&gt;()</code>, <code>add_objects()</code> and <code>post_instantiate()</code> methods should never trigger any errors.</p>
</li>
<li>
<p><span class="term" id="dt:co-09-optional-attributes"><em>CO-09</em> — Optional Attributes</span><br>
Component attributes should in general be made optional with well chosen default values instead of being required.</p>
</li>
<li>
<p><span class="term" id="dt:co-10-on-board-software"><em>CO-10</em> — On-board Software</span><br>
Boot software such as BIOS, OBP and other firmware that is resident on the hardware should be setup as part of the component. If changing the firmware makes sense, then there should be a configuration attribute to set the image file to use.</p>
</li>
</ul>
</div>
<h2 id="system-checklist">8.5 <a href="#system-checklist">System Checklist</a></h2>
<p>This section describes important items that, in addition to the generic checklist, should be taken into consideration when assembling a larger system. See also the "Target Script Checklist".</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:sy-01-reuse-of-existing-models"><em>SY-01</em> — Reuse of Existing Models</span><br>
Since developing a new device model may involve a lot of work, it is a good idea to make sure that no previous model of the device exists. Also similar device models can be useful if code can be shared between them. </p>
</li>
<li>
<p><span class="term" id="dt:sy-02-build-simicsfs-for-linux-target"><em>SY-02</em> — Build SimicsFS for Linux Target</span><br>
If Linux is supported for the target system, then a SimicsFS kernel module should be built and installed on the Linux image. </p>
</li>
<li>
<p><span class="term" id="dt:sy-03-moved-to-st-01"><em>SY-03</em> — <em>Moved to ST-01.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-04-moved-to-st-02"><em>SY-04</em> — <em>Moved to ST-02.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-05-moved-to-st-06"><em>SY-05</em> — <em>Moved to ST-06.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-06-moved-to-st-08"><em>SY-06</em> — <em>Moved to ST-08.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-07-moved-to-st-17"><em>SY-07</em> — <em>Moved to ST-17.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-08-moved-to-st-18"><em>SY-08</em> — <em>Moved to ST-18.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-09-moved-to-st-20"><em>SY-09</em> — <em>Moved to ST-20.</em></span></p>
</li>
<li>
<p><span class="term" id="dt:sy-10-only-create-device-objects-from-components"><em>SY-10</em> — Only Create Device Objects from Components</span><br>
All objects implementing the functionality of a target system should be created by components. There should not be any model objects created automatically when loading modules. Also target scripts should only create component objects and no other model objects. </p>
</li>
</ul>
</div>
<h2 id="target-script-checklist">8.6 <a href="#target-script-checklist">Target Script Checklist</a></h2>
<p>This section describes important items that, in addition to previous checklists, should be taken into consideration when writing the target scripts for a virtual platforms. </p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:st-01-follow-machine-script-guidelines"><em>ST-01</em> — Follow Machine Script Guidelines</span><br>
The <code>.simics</code> and <code>.include</code> scripts for a machine should follow the
guidelines in the section about ready-to-run configurations in
"Configuration and Checkpointing" in the <em>Simics User's Guide</em>. For example
the setup of the simulated hardware should be separate from the software
configuration. See also "System Configurations" in the <em>Model Builder User's
Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:st-02-possible-to-start-from-all-simics-scripts"><em>ST-02</em> — Possible to Start from All <code>.simics</code> Scripts</span><br>
It should be possible to start any <code>.simics</code> file from scratch. Scripts that require other files to have run first, or require CLI variables to be set, should have the <code>.include</code> suffix. </p>
</li>
<li>
<p><span class="term" id="dt:st-03-location-independence"><em>ST-03</em> — Location Independence</span><br>
It should be possible to launch a target script in Simics no matter what the current directory of Simics is. The <code>%simics%</code> path marker can be used to reference other scripts in a Simics project, the same, or other packages.</p>
</li>
<li>
<p><span class="term" id="dt:st-04-do-not-advance-the-simulation"><em>ST-04</em> — Do not Advance the Simulation</span><br>
A target script should not run the simulation, but start all processors at step and cycle 0. Script branches can be used to automate setup needed while the system is booting although adding support for it in a system component is recommended, to make sure checkpoints can be taken early.</p>
</li>
<li>
<p><span class="term" id="dt:st-05-supply-system-information-for-gui-views"><em>ST-05</em> — Supply System Information for GUI Views</span><br>
The target viewer should report correct information about the system in the built-in Winsome GUI.</p>
</li>
<li>
<p><span class="term" id="dt:st-06-proper-command-error-handling"><em>ST-06</em> — Proper Command Error Handling</span><br>
Errors that are detected in a script should be reported using the <code>interrupt-script</code> command. Using the <code>quit</code> command is not advisable in scripts since it will close the interactive session for a user. It is not needed either since Simics will exit on errors anyway when run in batch mode. </p>
</li>
<li>
<p><span class="term" id="dt:st-07-check-for-external-files"><em>ST-07</em> — Check for External Files</span><br>
If the script uses files which are not included in the same package, it should verify their presence before referencing them and, if needed, interrupt the script. The <code>lookup-file</code> command searches for a file and, if not found, it emits an error message and interrupts the script. Otherwise, use the two commands <code>file-exists</code> and <code>interrupt-script</code>.</p>
</li>
<li>
<p><span class="term" id="dt:st-08-naming-of-the-top-component"><em>ST-08</em> — Naming of the Top Component</span><br>
A machine script (<code>&lt;architecture&gt;-system.include</code>) should create the top level component with the name configured by the <code>$machine_name</code> variable. If this variable is not set, it should default to the system name. The name of the created component should then be saved in <code>$system</code>. It will typically be the same as <code>$machine_name</code> unless there is a name collision. See also "System Configurations" in the <em>Model Builder User's Guide</em>.</p>
<p>For example: </p>
<pre><code>(in decl) param machine_name : string = "board"
$system = (create-chassis-qsp-x86 name = $machine_name)
</code></pre>
<p>As a result, multiple machines can be instantiated in the following way: </p>
<pre><code>$machine_name = machine1
run-command-file "%simics%/targets/qsp-x86/firststeps.simics"
$machine_name = machine2
run-command-file "%simics%/targets/qsp-x86/firststeps.simics"
</code></pre>
<p>The old component prefix support should not be used anymore as it will be removed in the future.</p>
</li>
<li>
<p><span class="term" id="dt:st-09-use-common-script-to-create-ethernet-network"><em>ST-09</em> — Use Common Script to Create Ethernet Network</span><br>
If applicable to the system being modeled, use the <code>targets/common/add-eth-link.include</code> script to create a simulated Ethernet network and to configure the service-node.</p>
</li>
<li>
<p><span class="term" id="dt:st-10-include-an-ethernet-network"><em>ST-10</em> — Include an Ethernet Network</span><br>
Target scripts should create an Ethernet network by default and connect the primary Ethernet adapter of the system to it.</p>
</li>
<li>
<p><span class="term" id="dt:st-11-no-connection-to-the-real-network"><em>ST-11</em> — No Connection to the Real Network</span><br>
Target scripts should not connect the virtual Ethernet network to the real network by default.</p>
</li>
<li>
<p><span class="term" id="dt:st-12-allow-parameterization"><em>ST-12</em> — Allow Parameterization</span><br>
Target scripts should allow users to modify its behavior by setting parameters using CLI variables. All parameters should be optional and have good default values. For boolean variables, TRUE/FALSE should be used. See also <em>ST-13</em>.</p>
</li>
<li>
<p><span class="term" id="dt:st-13-use-standard-parameter-variables"><em>ST-13</em> — Use Standard Parameter Variables</span><br>
The following standard variables should be implemented if applicable for the target system: </p>
<div class="dl">
<ul>
<li><span class="term" id="dt:memory_gigs-or-memory_megs">$memory_gigs or $memory_megs</span><br>
Amount of system memory in GiB or MiB. </li>
<li><span class="term" id="dt:freq_mhz">$freq_mhz</span><br>
Frequency of the main processor cores in MHz. </li>
<li><span class="term" id="dt:num_cpus">$num_cpus</span><br>
The number or processors in the target system; compare with <code>$cpu_cores</code>. </li>
<li><span class="term" id="dt:cpu_cores">$cpu_cores</span><br>
The number of cores on processor components and SoCs with multiple cores. Use this parameter when <code>$num_cpus</code> would be misleading. </li>
<li><span class="term" id="dt:cpu_class">$cpu_class</span><br>
The name of the processor class for systems that support more than one kind of processor. </li>
<li><span class="term" id="dt:host_name">$host_name</span><br>
The name of the target system. Used as name of the top component. (For legacy reasons this variable has a confusing name. It should really be called $target_name.) </li>
<li><span class="term" id="dt:mac_address">$mac_address</span><br>
The MAC (Ethernet) address of the primary network controller. </li>
<li><span class="term" id="dt:disk_image">$disk_image</span><br>
The file name of an image to use for the primary disk. </li>
<li><span class="term" id="dt:disk_size">$disk_size</span><br>
The size of the file in <code>$disk_image</code>, if it cannot be automatically determined from the file. </li>
<li><span class="term" id="dt:rtc_time">$rtc_time</span><br>
The starting time of the RTC (Real Time Clock) in the <code>"YYYY-MM-DD HH:MM:SS UTC"</code> format. </li>
<li><span class="term" id="dt:ip_address">$ip_address</span><br>
The primary IP address of the system. (If it can be set.) </li>
<li><span class="term" id="dt:connect_real_network">$connect_real_network</span><br>
Connect the virtual Ethernet network to the real network using port-forwarding/NAT. </li>
</ul>
</div>
<p>The following variables are automatically supported if the <code>targets/common/add-eth-link.include</code> script is used to create a virtual Ethernet network. Scripts creating their own Ethernet network without using <code>add-eth-link.include</code> should support some subset of these variables. </p>
<div class="dl">
<ul>
<li><span class="term" id="dt:create_network">$create_network</span><br>
Boolean variable specifying if a simulated Ethernet network link should be created together with the system. </li>
<li><span class="term" id="dt:eth_link">$eth_link</span><br>
The name of an existing Ethernet link object. </li>
<li><span class="term" id="dt:service_node">$service_node</span><br>
The name of an existing service node object. </li>
<li><span class="term" id="dt:service_node_ip_address">$service_node_ip_address</span><br>
The IP address of the <code>$service_node</code> object on the <code>$eth_link</code> link. </li>
<li><span class="term" id="dt:dhcp_pool_ip">$dhcp_pool_ip</span><br>
The first address in the pool of IP addresses used for DHCP in the $service_node. </li>
<li><span class="term" id="dt:dhcp_pool_size">$dhcp_pool_size</span><br>
The size of the IP address pool used for DHCP in the <code>$service_node</code>. Set to 0 to disable DHCP. </li>
<li><span class="term" id="dt:network_goal_latency">$network_goal_latency</span><br>
The requested network latency of the <code>$eth_link</code> link. </li>
<li><span class="term" id="dt:eth_link_gid">$eth_link_gid</span><br>
The global identifier for the <code>$eth_link</code> link, used in distributed simulation. </li>
</ul>
</div>
</li>
<li>
<p><span class="term" id="dt:st-14-do-not-leak-cli-variables"><em>ST-14</em> — Do not Leak CLI Variables</span><br>
CLI variables are global by default. Scripts should try to make variables local if possible, or unset them after use, to avoid conflicts with other scripts. See also <em>ST-15</em>.</p>
</li>
<li>
<p><span class="term" id="dt:st-15-support-multi-machine-setup"><em>ST-15</em> — Support Multi-Machine Setup</span><br>
It should be possible to create multiple target machines by setting the <code>$host_name</code> variable and then running the target start script (with the <code>-local</code> flag) without getting any conflicts.</p>
</li>
<li>
<p><span class="term" id="dt:st-16-configure-os-awareness"><em>ST-16</em> — Configure OS Awareness</span><br>
All top-level components should have <code>software</code> slot with an <code>os_awareness</code> component in it. This is typically created in the <code>&lt;architecture&gt;-system.include</code> script: </p>
<pre><code>new-os-awareness $system.software
</code></pre>
<p>If the OS awareness framework in Simics supports the operating system that is configured on the machine, then a parameter file should be created that matches the operating system and that is loaded in the software setup script (i.e. the <code>&lt;architecture&gt;-&lt;software&gt;-setup.include</code> file), typically using: </p>
<pre><code>$system.software.load-parameters &lt;architecture&gt;-&lt;software&gt;.params
</code></pre>
<p>For more details refer to the section "OS Awareness Details" in the <em>Analyzer User's Guide</em>.</p>
</li>
<li>
<p><span class="term" id="dt:st-17-do-not-reference-objects-by-name"><em>ST-17</em> — Do Not Reference Objects by Name</span><br>
Simics scripts should not expect that objects created as part of components will get certain names. When creating a component, the returned component name can be saved in a variable for later use. </p>
<pre><code>$console = (new-text-console-comp)
$console.con-&gt;title = "new title"
</code></pre>
<p>When referencing component and objects created by another machine script, the <code>$system</code> variable (<em>ST-08</em>) will provide a reference to the top-level component created by that script.</p>
</li>
<li>
<p><span class="term" id="dt:st-18-set-up-a-valid-cell-partitioning"><em>ST-18</em> — Set Up a Valid Cell Partitioning</span><br>
Check that the cell partitioning set up by the script is correct by using
<code>check-cell-partitioning</code>, both after the script has run and for checkpoints
taken of the system. For more information see the section on simulation
cells in the "Multithreading" section of the <em>API Reference Manual</em>.</p>
</li>
<li>
<p><span class="term" id="dt:st-19-keep-default-global-simulation-settings"><em>ST-19</em> — Keep default global simulation settings </span><br>
Scripts should not modify default simulation settings. Examples of settings that should not be done in scripts: changing log-level (<code>log-level 2</code>), explicitly enabling reverse execution (<code>enable-reverse-execution</code>).</p>
</li>
<li>
<p><span class="term" id="dt:st-20-keep-target-scripts-simple"><em>ST-20</em> — Keep Target Scripts Simple</span><br>
While following the guidelines in this section, also try to keep the target scripts as simple as possible. Avoid switching between Python and CLI for example. If Python code is needed in a target script, then some component is probably not powerful enough or some new CLI command is needed.</p>
</li>
</ul>
</div>

<div class="chain">
<a href="dml-tips-and-tricks.html">7 DML Tips and Tricks</a>
<a href="advanced-programming-with-dml.html">9 Advanced Programming with DML</a>
</div>