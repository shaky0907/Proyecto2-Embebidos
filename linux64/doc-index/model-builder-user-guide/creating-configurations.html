<!doctype html>
<head>
<meta charset="utf-8">
<title>24 Components</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="memory-space.html">23 Memory Spaces</a>
<a href="adding-flash-to-a-system.html">25 Adding Flash to a System</a>
</div>
<div class="path">
<a href="index.html">Model Builder User's Guide</a>
&nbsp;/&nbsp;
<a href="part-system-modeling.html">IV Creating Virtual Systems</a>
&nbsp;/&nbsp;</div>
<h1 id="components">24 <a href="#components">Components</a></h1>
<p>This chapter describes how to write your own Simics components. It assumes you have already read the section about components in the <em>Simics User's Guide</em>, particularly for the definitions.</p>
<h2 id="introduction">24.1 <a href="#introduction">Introduction</a></h2>
<p>A component represents a piece of hardware which connects to other parts of system through standardized interfaces. The primary purpose of component in Simics is to manage and encapsulate the complexity inherent in composing a system. Frequently, a component represents a piece of hardware which can be removed from the system and put back in without breaking it or the rest of the system. Some manufacturers refer to this sort of hardware as a Field Replaceable Unit or FRU. Whether modeling FRUs or not, the definition of components should closely follow the structure in the real system. Some examples of real hardware that generally modeled using components are motherboards, compact flash cards, disks, SOCs, and PCI cards.</p>
<p>Components are assembled to construct systems through two primary mechanisms: nested namespaces and connectors. A system will usually use both mechanisms. Namespaces are used to encapsulate parts of the system which from the outside can be considered one unit and connectors are used to connect the components to each other similar to how the real hardware is connected, for example memory slots, PCI slots, Ethernet sockets. When there is a tight coupling between a component and a subcomponent, for example between a board and an SOC, the component can set up the subcomponent and the connections between the two components without using connectors.</p>
<p>Consider a system consisting of a compact PCI chassis with a processor board and several I/O boards. The system runs a single operating system image and is considered a single machine; however, each board is clearly a separate entity from the others and from the chassis. Here, you would use simple connections between the components, with one component for each board and one for the chassis.</p>
<p>Now consider the processor board consisting of an integrated processor SOC, several discrete devices, RAM, and flash. Here, the SOC is clearly a reusable system with sufficient complexity that it should be encapsulated in a component, but the board is meaningless without the SOC. Thus a component should be used to represent the SOC, with the board being a component that contains the SOC. Since the board has such a strong dependency on the SOC it does not need to use a connector to connect to it, instead it can create the SOC component itself and set up the connections manually.</p>
<p>Namespaces are described in section <a class="reference" href="#namespace-hierarchies">24.2</a>, while component hierarchies are described in <a class="reference" href="#component-hierarchies">24.3</a>. To summarize, a namespace composition is used to describe components that consists of other components, while connectors are used to connect components to each other.</p>
<h3 id="component-class">24.1.1 <a href="#component-class">Component Class</a></h3>
<p>A <em>component</em> is a generic Simics class, with the special ability to contain class instances. Each instance of a component represents a namespace described in section <a class="reference" href="#namespaces">24.2.1</a>. In this chapter, we will refer to a component instance as a <em>component</em>, and the class instances within the component as <em>objects</em>.</p>
<p>More specifically, a component class is a Simics class written in Python that implements the <code>component</code> interface. Details of writing components are described in section <a class="reference" href="#implementing-components">24.6</a>. The <code>component</code> interface is documented in section <a class="reference" href="#component-interfaces">24.8.1</a>.</p>
<p>A number of ready to use components are provided with Simics. Some of these are standard components that can be used in many kind of systems. Examples of standard components are disks, flashes, text consoles, etc. Other components are specific to a particular system, such as an evaluation board.</p>
<h3 id="component-module">24.1.2 <a href="#component-module">Component Module</a></h3>
<p>A component module is a Simics module containing the implementation of one or more related <em>components</em>. The <code>examples-comp</code> module, for example, contains a set of example components. It will be used as an example in the following sections. It can be found at <code>[simics]/src/components/</code>.</p>
<p>Additional examples of flat components that do not support hierarchical composition can be found in the <code>[simics]/src/extensions</code> directory. These components are still supported, but they will not be discussed in this chapter.</p>
<h3 id="components-in-project">24.1.3 <a href="#components-in-project">Components in Project</a></h3>
<p>When adding a component to a project, the component module source directory is placed in <code>[project]/modules/component_module_name</code>, and contains one <code>component_module_name.py</code> file, one <code>Makefile</code> and optionally one PNG image file for each top-level component.</p>
<p>The <code>Makefile</code> is essentially identical for all component modules; it simply points out the <code>.py</code> file that is part of the module. Section <a class="reference" href="#implementing-components">24.6</a> describes how to create new components.</p>
<h2 id="namespace-hierarchies">24.2 <a href="#namespace-hierarchies">Namespace Hierarchies</a></h2>
<p>All components also define its own namespace for other components and objects. Placing a component in another component's namespace is used to model systems composed of reusable subsystems that do not individually stand alone.</p>
<figure id="conf_component_hierarchy_0">
<p><img alt="" src="conf_component_hierarchy_0.png"></p>
<figcaption>Figure 8. Example of a namespace hierarchy</figcaption>
</figure>
<p>Figure <a class="reference" href="#conf_component_hierarchy_0">8</a> shows an example system with one root component called <code>cmp0</code> with two sub components, <code>cmp1</code> and <code>cmp2</code>. The <code>cmp1</code> component contains the <code>obj</code> object. Each component has a separate namespace. The namespaces form a tree of components. The <code>cmp1</code> component is in the <code>cmp0</code> component's namespace.</p>
<p>All objects have a name. For objects in the global namespace the name is simply a string given at its creation. Objects in other namespaces have names that depend on their location in the hierarchy. These names depend on which slot in the parent the object is placed in.</p>
<p>Slots are something all components have, and which mainly define the names of its children. Each slot has a name and a value. The value is often just an object reference. Other possible values are <code>None</code> or nested lists with objects references and <code>None</code>s as elements. A slot with <code>None</code> value is called an unoccupied slot.</p>
<p>An object in a component has a local name and a full name. The local name is called <em>slot name</em> or simply slot. An object's slot name is the name of the slot it belongs to concatenated with its index in the slot. Assume that a component <em>cmp</em> has the slot <em>sub</em> with an object reference to the object <em>A</em>. The object <em>A</em> has the slot name <em>sub</em> and the full name <em>cmp.sub</em>. Now assume that the component <em>cmp</em> has the slot <em>sub</em> with a list of two object references to object <em>B</em> and object <em>C</em>. The object <em>B</em> has the slot name <em>sub[0]</em> and the full name <em>cmp.sub[0]</em>.</p>
<p>In figure <a class="reference" href="#conf_component_hierarchy_0">8</a> the sub components names are actually the slot names. Both <code>cmp1</code> and <code>cmp2</code> are slots in <code>cmp0</code>. The <code>cmp1</code> component in figure <a class="reference" href="#conf_component_hierarchy_0">8</a> has the full name <code>cmp0.cmp1</code>. All object names in the figures in this chapter are local names.</p>
<p>A component can be connected to components on the same hierarchical level or to a parent or child component; see section <a class="reference" href="#connecting-components">24.4</a>.</p>
<h3 id="namespaces">24.2.1 <a href="#namespaces">Namespaces</a></h3>
<p>Component namespaces provide scoping for names in a manner similar to syntactic blocks in programming languages. As with programming structure, it is easier to understand when a minimal number of names are defined in the global scope or namespace. Another good analogy is a file system directory structure.</p>
<p>A component or object can be added to a component's namespace on definition, or after creation at run-time using the <code>move-object</code> command.</p>
<pre><code class="language-simics">Ex. move component cmp1 to cmp0 as "cmp1":
simics&gt; <strong>move-object src = cmp1 dst = cmp0.cmp1</strong>
</code></pre>
<p>Moving an object to a component puts the object in its namespace. This is done by putting the object in a slot in the component. The object can now be accessed relative to the parent component in CLI, Python, or in the Simics API.</p>
<p>Moving an object to a different hierarchical location changes its full name. The <code>cmp1</code> is now accessed using the hierarchical name <code>cmp0.cmp1</code>, the slot name is <em>cmp1</em>.</p>
<pre><code class="language-simics">Ex. execute info command for cmp1 in CLI:
simics&gt; <strong>cmp0.cmp1.info</strong>
</code></pre>
<pre><code class="language-simics">Ex. access queue attribute for cmp1 in CLI:
simics&gt; <strong>cmp0.cmp1-&gt;queue</strong>
</code></pre>
<pre><code class="language-simics">Ex. access queue attribute for cmp1 in Python:
simics&gt; <strong>@conf.cmp0.cmp1.queue</strong>
</code></pre>
<pre><code class="language-simics">Ex. get cpu object from cmp1 in Python:
simics&gt; <strong>@conf.cmp0.cmp1.cpu</strong>
</code></pre>
<p>A normal object can only exist in one namespace at a time; only connector objects can exist in several namespaces. Connector objects are documented in section <a class="reference" href="#connector-objects">24.4.2</a>. Connector objects can be copied to a new namespace using the <code>copy-connector</code> command.</p>
<pre><code class="language-simics">Ex. copy connector object cmp0.cmp1.port0 to cmp0 as "copy0":
simics&gt; <strong>copy-connector cmp0.cmp1.port0 cmp0.copy0</strong>
</code></pre>
<p>The connector object can now be accessed as <code>cmp0.copy0</code> or <code>cmp0.cmp1.port0</code>, and has two parents. The owner of the connector object is not changed and is still the <code>cmp0.cmp1</code> component.</p>
<p>The <code>component</code> interface has functions to add and remove objects from a components namespace, which is used by the <code>move-object</code> and <code>copy-connector</code> commands.</p>
<p>The <code>alias</code> command can be used to avoid having to write the complete hierarchical name several times for often-used objects:</p>
<pre><code class="language-simics">Ex. alias for cmp1 in CLI:
simics&gt; <strong>alias short cmp0.cmp1.port0</strong>
simics&gt; <strong>short.info</strong>
</code></pre>
<h3 id="precedence">24.2.2 <a href="#precedence">Precedence</a></h3>
<p>Objects, attributes, and commands sometimes share the same namespace name, resulting in conflicts. Consider a root component named <code>cmp0</code> with an object in slot <em>cpu</em> and also has a command called <code>cpu</code> that prints all processors in the components. There will be a conflict when typing <strong>cmp0.cpu</strong> on the command line.</p>
<p>You should try to avoid such name conflicts, and Simics will print a warning message if any are detected. If there are conflicting names, the following precedence describes how the name is interpreted.</p>
<p>The order in decreasing precedence is:</p>
<ol>
<li>slots,</li>
<li>attributes, and</li>
<li>commands.</li>
</ol>
<p>Thus continuing the example above, <code>cmp0.cpu</code> is an object reference, not a command.</p>
<h2 id="component-hierarchies">24.3 <a href="#component-hierarchies">Component Hierarchies</a></h2>
<p>To model how the parts of a system are connected to each other components are connected to each other using connectors. The connectors allow you to build a system that consist of reusable components. The connections form a graph separate from the namespace hierarchy.</p>
<p>Components in the global namespace which represent systems of interest to the user should be top-level components. A top-level component's main responsibility is to provide informational metadata in some standardized attributes which are mainly used by Simics's graphical tools; see the details in <a class="reference" href="#component-attributes">24.8.3</a>. The user can set which components he wants as top-level components when he configures the system. For example, a compact PCI form factor single board computer can either be the top-level component in a standalone system or part of a chassis based system, where the chassis would be the top-level component.</p>
<h2 id="connecting-components">24.4 <a href="#connecting-components">Connecting Components</a></h2>
<p>Components can connect to other components via connector objects (described in more detail in section <a class="reference" href="#connector-objects">24.4.2</a>). The connector objects used for connecting components must implement the <code>connector</code> interface. The <code>connector</code> interface description can be found in section <a class="reference" href="#component-interfaces">24.8.1</a>.</p>
<figure id="conf_component_connector_0">
<p><img alt="" src="conf_component_connector_0.png"> </p><figcaption>Figure 9. Example component connection</figcaption><p></p>
</figure>
<p>In figure <a class="reference" href="#conf_component_connector_0">9</a>, the <code>southbridge</code> component is connected to the <code>usb_device</code> component. The <code>southbridge</code> component contains the <code>usb_host</code> object, and the <code>usb_device</code> component contains the <code>usb_disk</code> object. It is the components that set up the connection through their connectors, but it is the <code>usb_host</code> and <code>usb_disk</code> objects that are connected via interfaces. The <code>usb_host</code> object has a <code>usb_devices</code> attribute that connects to the <code>usb_device</code> interface on all connected usb device objects. The <code>usb_disk</code> object has a <code>usb_host</code> attribute that connects to the <code>usb</code> interface of the host object. Data exchanged during the connection process sets the attributes to appropriate values. A component connection between two components can exchange data to set up multiple attributes for several objects in the components.</p>
<h3 id="connector-properties">24.4.1 <a href="#connector-properties">Connector Properties</a></h3>
<p>A component connector has several properties that define the type of connection. The properties are defined in the <code>connector</code> interface, which is implemented by all component connectors.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:type">type</span><br>
Components have connectors of different types. Two connectors can only be connected if the types are identical. The most common types are standard hardware connectors such as Ethernet and serial.</p>
</li>
<li>
<p><span class="term" id="dt:hotpluggable">hotpluggable</span><br>
A connector is hotpluggable if the connector supports connecting and disconnecting after the component has been instantiated. For example, a USB device connector is often hotpluggable, while a processor connector usually is not.</p>
</li>
<li>
<p><span class="term" id="dt:required">required</span><br>
A connector that is required must be connected when the component is instantiated, otherwise will an error be generated. Processor connectors on board components are often required as the system cannot be setup without processor.</p>
</li>
<li>
<p><span class="term" id="dt:direction">direction</span><br>
The direction is either <em>up</em>, <em>down</em> or <em>any</em>. It is only possible to connect connectors <em><strong>of different directions</strong></em>. The direction of a connection determines if the connection defines the two components as part of the same connected tree or not. <em>Up</em> and <em>down</em> connectors imply that the connector defines a tree relationship, while <em>any</em> connectors do not imply any tree relationship. Additionally, the direction defines the order in which components in a component tree are instantiated. The top-level component is visited first, and then all components that are connected to its down connectors. This process is continued recursively until all components in the tree have been visited.</p>
<p>A top-level component is not allowed to have any <em>up</em> connectors, and its <em>any</em> connectors can only be connected to other <em>up</em> connectors. Top-level components must also be root components of their hierarchies.</p>
</li>
</ul>
</div>
<h3 id="connector-objects">24.4.2 <a href="#connector-objects">Connector Objects</a></h3>
<p>Component connector objects are normal Simics objects that implement the <code>connector</code> interface. Connector objects contain only the functionality needed to set up the connections between objects within the components they connect.</p>
<p>Connector objects are explicitly defined in the component class. The connector objects will be created when an instance of the component class is created. Defining a connector will automatically put the connector object in its component's namespace, i.e., all connectors will exist in a slot in a component.</p>
<p>A component can inherit another component's connectors. This can either be done using the <code>copy-connector</code> command at run-time, as described in section <a class="reference" href="#namespaces">24.2.1</a>, or when defining a component, as described in section <a class="reference" href="#adding-components">24.6.11</a>.</p>
<h3 id="connecting-connectors">24.4.3 <a href="#connecting-connectors">Connecting Connectors</a></h3>
<p>Component connectors are connected using the <code>connect</code> command, which takes the two component connector objects as parameters.</p>
<pre><code class="language-simics">Ex. connecting cmp0 and cmp1 in figure :
simics&gt; <strong>connect cmp0.cnt0 cmp1.cnt0</strong>
</code></pre>
<figure id="conf_connector_level_0">
<p><img alt="" src="conf_connector_level_0.png"> </p><figcaption>Figure 10. Component connection between components on the same level</figcaption><p></p>
</figure>
<figure id="conf_connector_level_1">
<p><img alt="" src="conf_connector_level_1.png"> </p><figcaption>Figure 11. Component connection between component parent and child</figcaption><p></p>
</figure>
<p>Two components can only be connected if they are siblings in the namespace hierarchy or if they are parent and child. The former is illustrated in figure <a class="reference" href="#conf_connector_level_0">10</a>, the latter in figure <a class="reference" href="#conf_connector_level_1">11</a>.</p>
<h3 id="adding-connector-references">24.4.4 <a href="#adding-connector-references">Adding Connector References</a></h3>
<p>When making a component into a sub component of another component, it is often desirable to expose the sub component connectors as connectors of the parent component. This is very simple, as it is possible to add a reference to the sub component's connector to the parent component.</p>
<figure id="conf_connector_reference_0">
<p><img alt="" src="conf_connector_reference_0.png"> </p><figcaption>Figure 12. Connector reference</figcaption><p></p>
</figure>
<p>Assume we have two components, <code>cmp0</code> and <code>cmp1</code>. The <code>cmp1</code> has a connector object named <code>cnt0</code>. First add <code>cmp1</code> to <code>cmp0</code> and then add a reference:</p>
<pre><code class="language-simics">simics&gt; <strong>move-object src = cmp1 dst = cmp0.cmp1</strong>
simics&gt; <strong>copy-connector cmp0.cmp1.cnt0 cmp0.cpy0</strong>
</code></pre>
<h3 id="ethernet-link-connections">24.4.5 <a href="#ethernet-link-connections">Ethernet Link Connections</a></h3>
<p>The legacy Ethernet link component using the <code>std-ethernet-link</code> class is not compatible with the new hierarchical components. The new Ethernet link components <code>ethernet_cable</code>, <code>ethernet_hub</code>, and <code>ethernet_switch</code> should be used with hierarchical components.</p>
<h2 id="life-of-a-component">24.5 <a href="#life-of-a-component">Life of a Component</a></h2>
<p>A component goes through several phases, from creation to fully instantiated component connected to other components with a lot of sub components and objects.</p>
<p>These are the phases:</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:1-creation-phase">1. Creation Phase</span>
The first step to become full-grown component is to be created. A component can either be created as a non-instantiated component or as an instantiated component. A component can only be created and instantiated in one command if it does not contain any required connectors. When setting up a system it is most common to create non-instantiated components, so we will focus on this in this section.</li>
<li><span class="term" id="dt:2-setup-phase">2. Setup Phase</span>
Once the component has been created it is time to initialize it. It is now possible to set the component attributes that were not set when the component was created.</li>
<li><span class="term" id="dt:3-connect-phase">3. Connect Phase</span>
Next step in the life of a component is to look at the surroundings and connect to other components. All required connectors must be connected. It is a good idea to also connect all optional connectors.</li>
<li><span class="term" id="dt:4-instantiate-phase">4. Instantiate Phase</span>
When all connections are setup it is time to become instantiated. In the instantiate phase all objects in the component and all connected components are created. This must be done atomically, as objects might have attributes pointing to objects in other components in the tree.</li>
</ul>
</div>
<h3 id="creation-phase">24.5.1 <a href="#creation-phase">Creation Phase</a></h3>
<p>The components are created using the <code>create-</code><em>name-of-component</em> command, which will create a non-instantiated component.</p>
<p>The first argument to the <code>create-</code> command is the name of the component. The components default name will be used if the name is not provided when creating the component. The default name is defined by the <code>basename</code> class attribute. The <code>basename</code> attribute is set to <em>component</em> for all components that are based on the <code>StandardComponent</code> class, but it can be overridden in the inheriting class.</p>
<p>The remaining arguments to the <code>create-</code> command are the config attributes, see section <a class="reference" href="#adding-config-attributes">24.6.6</a>. The config attributes are either required or optional. All required attributes must be set when the component is created.</p>
<h3 id="setup-phase">24.5.2 <a href="#setup-phase">Setup Phase</a></h3>
<p>All attributes that were not set during the creation phase, but should be set are set in the setup phase. Some attributes might depend on other components or one script creates the component and another script setup the components.</p>
<h3 id="connect-phase">24.5.3 <a href="#connect-phase">Connect Phase</a></h3>
<p>All required connectors must be connected before the component is instantiated. Required connectors might for instance be connectors for connecting a processor to board. The objects on the board component require the processor object in the processor component to function.</p>
<h3 id="instantiate-phase">24.5.4 <a href="#instantiate-phase">Instantiate Phase</a></h3>
<p>The component can be instantiated when all connectors have been connected. The instantiation process will collect all pre objects in the component and create new real objects to replace the pre objects.</p>
<p>The <code>component</code> interface has two functions that will be called in the instantiate process. The <code>pre_instantiate</code> function will be called right before the component is instantiated. The function returns <code>True</code> if the component is allowed to be instantiated. The <code>post_instantiate</code> function will be called right after the component is instantiated. This function is a good place to add code that requires real objects from the component.</p>
<h2 id="implementing-components">24.6 <a href="#implementing-components">Implementing Components</a></h2>
<p>This section describes how to implement components. All examples in this section are fully functional and are included in the <code>examples-comp</code> module. To test the examples, start the vacuum target machine and load the <code>examples-comp</code> module.</p>
<p>The source code for the component examples can be found in <code>[simics]/src/components/examples-comp/examples_comp.py</code>.</p>
<h3 id="creating-a-new-component">24.6.1 <a href="#creating-a-new-component">Creating a New Component</a></h3>
<p>A new component module can be created using the <code>project-setup</code> utility:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows">Windows</span></p>
<pre><code class="language-simics">project&gt; <strong>bin\project-setup.bat --component my-own-component</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux">Linux</span></p>
<pre><code class="language-simics">project$ <strong>./bin/project-setup --component my-own-component</strong>
</code></pre>
</li>
</ul>
</div>
<p>This will create skeleton code for a new component in the <code>[project]/modules/my-own-component/</code> directory, with all files needed to build it as a Simics module.</p>
<h3 id="the-comp-python-module">24.6.2 <a href="#the-comp-python-module">The comp Python Module</a></h3>
<p>Simics includes the <code>comp</code> Python module that greatly simplifies writing components. The module contains all functionality needed for creating a component.</p>
<p>The <code>comp</code> module and its classes and methods are documented in section <a class="reference" href="#the-comp-component">24.11</a>. This help for writing components is only available in Python, as Python is the only language supported for writing components.</p>
<p>To use the <code>comp</code> module, make sure your Python file contains:</p>
<pre><code>from comp import *
</code></pre>
<p>The <code>comp</code> module contains the <code>StandardComponent</code> class that should be used as base class when creating new components. The class contains a lot of useful methods and parameters to define a new component. The <code>comp</code> module also contains other classes that are based on the <code>StandardComponent</code> class. These classes will be described later.</p>
<p>Here is an example how to create a simple component:</p>
<p>
</p><pre><code>import simics
from comp import *

class emmett(StandardComponent):
    """The long description for the Emmett component."""
    _class_desc = 'short Emmett description'
</code></pre>
<p></p>
<p>In the example we create the component class <em>emmett</em>. The first string in the class is a long description of the component that can be several sentences. The <em>_class_desc</em> is a short class description beginning with lower case, without trailing dot, and at most 50 characters long. The longer description is used in the help commands and reference manuals, while the shorter description is used for example in the GUI to describe the component.</p>
<p>Upon registration, the newly defined component registers itself as a common Simics class which allows instances of it to be created like for any other Simics object. By inheriting the <code>StandardComponent</code>, the component will also get a set of predefined attributes that all components should have; see section <a class="reference" href="#component-attributes">24.8.3</a>. The default value and functionality for the attributes can be overridden if needed; see section <a class="reference" href="#overriding-attributes">24.6.7</a>.</p>
<p>All components will also automatically define a few default commands. <code>new-</code><em>name-of-component</em> will create an instantiated component of the type <em>name_of_component</em>. <code>create-</code><em>name-of-component</em> will create a non-instantiated component. Note that underscores are converted to dashes for class name for the <code>new-</code> and <code>create-</code> commands. The component will also automatically get <code>info</code> and <code>status</code> commands.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module examples-comp</strong>
simics&gt; <strong>new-emmett name = my_emmett</strong>
Created instantiated 'emmett' component 'my_emmett'
</code></pre>
<p>To define a top-level component, override the top_level class definition in the <code>StandardComponent</code> class like this:</p>
<p>
</p><pre><code>class mcfly(StandardComponent):
    """The McFly component."""
    _class_desc = 'a McFly component'

    class top_level(StandardComponent.top_level):
        def _initialize(self):
            self.val = True
</code></pre>
<p></p>
<p>In this example, we override the default value for <em>top_level</em>. The <code>top_level</code> attribute is by default set to <code>False</code>. Section <a class="reference" href="#overriding-attributes">24.6.7</a> says more about how to override the default attribute functionality. It is possible to change a non top-level component into a top-level component by setting the attribute when creating it or at run time.</p>
<h3 id="standardcomponent-class-basic-methods">24.6.3 <a href="#standardcomponent-class-basic-methods">StandardComponent Class Basic Methods</a></h3>
<p>The <code>StandardComponent</code> class is defined in the <code>comp</code> Python module. The class is based on <code>pyobj.ConfObject</code>, from which it inherits some rarely used methods (see section <a class="reference" href="writing-module-with-pyobj.html#confobject-class-basic-methods">15.3</a>).</p>
<p>The <code>StandardComponent</code> class adds a method <code>setup</code>, which is called after all attributes of a component object's have been set. This method is often used for adding new objects to the component. Objects should only be added if the component has not been yet instantiated. This makes the <code>setup</code> methods very similar in all components. The <code>instantiated</code> attribute is checked to determine if we should add new objects or not. More information about attributes can be found in section <a class="reference" href="#adding-attributes">24.6.5</a>.</p>
<p>
</p><pre><code>class tyrell(StandardComponent):
    """The Tyrell component."""
    _class_desc = 'a Tyrell component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.olws = 1
            self.add_tyrell_objects()

    def add_tyrell_objects(self):
        self.add_pre_obj('mem', 'memory-space')

class sebastian(tyrell):
    """The Sebastian component."""
    _class_desc = 'a Sebastian component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_sebastian_objects()

    def add_sebastian_objects(self):
        self.add_pre_obj('mem', 'memory-space')
</code></pre>
<p></p>
<p>The <code>setup</code> method corresponds to the <code>finalize</code> field in the <code>class_info_t</code> struct that is passed to the <code>SIM_create_class</code> function, see the <em>Simics Reference Manual</em>.</p>
<div class="note">
 To prevent name conflicts when using class inheritance, use unique names for the methods that add objects. For example, tint the method name with the name of its class, such as `add_banana_objects()` in class "banana". A component that inherits another component class and calls its `setup` method with *self* can cause problems when the method that adds objects has the same name in both classes.
</div>
<p>The <code>StandardComponent</code> class defines the <code>_finalize</code> method which also the <code>pyobj.ConfObject</code> class defines. Old components often implement this method. It is not recommended to implement the <code>_finalize</code> method, the <code>setup</code> method should instead be implemented to get better component error messages on component exceptions.</p>
<p>
</p><pre><code>class roy_batty(StandardComponent):
    """The Roy Batty component."""
    _class_desc = 'a Roy Batty component'

    def _initialize(self):
        super()._initialize()
        self.replicants = 4

    def _finalize(self):
        super()._finalize()
        if not self.instantiated.val:
            self.add_roy_batty_objects()

    def add_roy_batty_objects(self):
        self.add_pre_obj('mem', 'memory-space')
</code></pre>
<p></p>
<h3 id="standardcomponent-class-parameters">24.6.4 <a href="#standardcomponent-class-parameters">StandardComponent Class Parameters</a></h3>
<p>The <code>StandardComponent</code> class in the <code>comp</code> module includes parameters that can be set to control the component behavior. Since the <code>StandardComponent</code> class is based on <code>pyobj.ConfObject</code>, also see the parameters defined in <a class="reference" href="writing-module-with-pyobj.html#confobject-class-parameters">15.4</a>.</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:_help_categories">_help_categories</span>
Set this to a tuple of help category names; the component commands will appear under these categories in the <code>help</code> command. For example, if you are modeling a PCI Ethernet card, you might want to set it to <code>('Ethernet', 'PCI')</code>.</li>
<li><span class="term" id="dt:_no_new_command">_no_new_command</span>
Set it to <code>object()</code> to make sure that the component class does not automatically get a <code>new-</code> command registered. This is useful for components that require a connection before they can be instantiated.</li>
<li><span class="term" id="dt:_no_create_command">_no_create_command</span>
Set it to <code>object()</code> to make sure that the component class does not automatically get a <code>create-</code> command registered.</li>
</ul>
</div>
<p>
</p><pre><code>class henry_hill(StandardComponent):
    """The wiseguy, Henry Hill component."""
    _class_desc = 'a Henry Hill component'
    _do_not_init = object()

class frankie_carbone(henry_hill):
    """The wiseguy, Frankie Carbone component."""
    _class_desc = 'a Frankie Carbone component'
    _help_categories = ('Goodfellas',)
    def _initialize(self):
        super()._initialize()
</code></pre>
<p></p>
<h3 id="adding-attributes">24.6.5 <a href="#adding-attributes">Adding Attributes</a></h3>
<p>A component that inherits the <code>StandardComponent</code> class creates a new attribute by defining a new class in the component class that inherits the <code>Attribute</code> class, which is defined in the <code>pyobj</code> module. See the section <a class="reference" href="writing-module-with-pyobj.html#attributes">15.5</a>.</p>
<h3 id="adding-config-attributes">24.6.6 <a href="#adding-config-attributes">Adding Config Attributes</a></h3>
<p>The <code>comp</code> Python module provides the <code>ConfigAttribute</code> class and the <code>SimpleConfigAttribute</code> function for creating parameterized config attributes. Attributes that are used to parameterize the component will automatically become arguments to the <code>new-</code> and <code>create-</code> commands. This allows for an easy way to create a component with the desired parameters.</p>
<p>Because config attributes are used as arguments to <code>new-</code> and <code>create-</code> commands, they must be documented. Hence the default value of the <code>attrattr</code> class member is <code>Sim_Attr_Optional</code>.</p>
<p>Config attributes are created like this:</p>
<p>
</p><pre><code>class ripley(StandardComponent):
    """The Ripley component."""
    _class_desc = 'a Ripley component'

    def setup(self):
        super().setup()
        print("sequels is", self.sequels.val)
        print("eggs is", self.eggs.val)
        print("marine is", self.marine.val)

    class sequels(SimpleConfigAttribute(
            None, 'i', simics.Sim_Attr_Required, [4])):
        """Number of sequels."""

    class eggs(ConfigAttribute):
        """The number of hatched eggs."""
        attrtype = "i"
        valid = [821, 1023]
        def _initialize(self):
            self.val = 50
        def getter(self):
            return self.val
        def setter(self, val):
            if val == 0:
                return simics.Sim_Set_Illegal_Value
            self.val = val

    class marine(SimpleConfigAttribute(
            'hudson', 's', val = ['hudson', 'gorman', 'vasquez'])):
        """The name of the marine."""
</code></pre>
<p></p>
<p>An optional <em>config</em> attribute such as <code>eggs</code> becomes an optional argument to the <code>new-</code> and <code>create-</code> commands for the component. A required attribute such as the <code>sequels</code> attribute becomes a required argument when creating the component.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module examples-comp</strong>
simics&gt; <strong>new-ripley name = my_ripley sequels = 3</strong>
sequels is 3
eggs is 50
marine is hudson
Created instantiated 'ripley' component 'my_ripley'
</code></pre>
<p>Use the <code>SimpleConfigAttribute</code> function when a simple attribute without any special functionality is required, just like the <code>SimpleAttribute</code> function is used.</p>
<p>The <code>ConfigAttribute</code> class contains a <em>valid</em> attribute which is a list of valid values. The list gives the user a hint about valid values when creating a component. There is no check that the value written to the attribute is a value in the list of valid values. The list of valid value(s) does not need to contain the default initial value for the config attribute, but it usually does. The valid list should at least contain one valid value even if several values are valid.</p>
<h3 id="overriding-attributes">24.6.7 <a href="#overriding-attributes">Overriding Attributes</a></h3>
<p>The <code>StandardComponent</code> class defines a set of attributes that all components should implement. The attributes are described in detail in the section <a class="reference" href="#component-attributes">24.8.3</a>. All of the attributes can be overridden if needed.</p>
<p>Here is an example how to override the <code>component_icon</code> attribute:</p>
<p>
</p><pre><code>class nemo(StandardComponent):
    """The Nemo component."""
    _class_desc = 'a Nemo component'

    class component_icon(StandardComponent.component_icon):
        def _initialize(self):
            self.val = "stanton.png"
</code></pre>
<p></p>
<p>The new component icon attribute example code only overrides the initial value, but it is also possible to override anything in the class definition, such as the <code>getter</code> or <code>setter</code> methods, if required.</p>
<h3 id="the-_up-member">24.6.8 <a href="#the-_up-member">The _up Member</a></h3>
<p>To access a class's containing class the <em>_up</em> member is used. See the section <a class="reference" href="writing-module-with-pyobj.html#the-_up-member">15.7</a>.</p>
<h3 id="adding-objects-to-slots">24.6.9 <a href="#adding-objects-to-slots">Adding Objects to Slots</a></h3>
<p>A component can define <em>slots</em>. A slot has a name and a value, often a single object. Slots can be defined in the component; however, new slots can also be added after a component has been created, but that will not be discussed in this section. Slots defined in the component are called static slots. Static slots cannot be removed after the component has been created. The value in the slot can be changed at any time. The name of the slot is used to access an object in the slot.</p>
<h4 id="adding-single-object">24.6.9.1 <a href="#adding-single-object">Adding Single Object</a></h4>
<p>Common Simics objects are added to a component using the <code>add_pre_obj</code> method. The method will create pre objects that will be converted to real objects when the component is instantiated.</p>
<p>
</p><pre><code>class wall_e(StandardComponent):
    """The WALL-E component."""
    _class_desc = 'a WALL-E component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_wall_e_objects()

    def add_wall_e_objects(self):
        p = self.add_pre_obj('p_mem', 'memory-space')
        v = self.add_pre_obj('v_mem', 'memory-space')
        self.add_pre_obj('clock', 'clock', freq_mhz = 10)
        p.map = [[0x100, v, 0, 0, 0x10]]

    class cpu_list(StandardComponent.cpu_list):
        def getter(self):
            return [self._up.get_slot('clock')]
</code></pre>
<p></p>
<p>The component in the example defines three objects and three slots to hold references to them. The <code>add_pre_obj</code> function has two required and two optional arguments. The two required arguments are the slot name and the class name. The third argument is optional and specifies the name of the object. The name defaults to an empty string and will be the object's hierarchical name, it is not shown in the example and it should only be used in special cases and then it is given as <code>name = "pineapple"</code>. The fourth argument is also optional and is attribute values for the object. The <code>add_pre_obj</code> function returns a <code>pre_conf_object</code> or an array of <code>pre_conf_objects</code>.</p>
<p>The <em>p_mem</em> and <em>v_mem</em> slots contain <code>memory-space</code> objects and the <em>clock</em> slot contains a <code>clock</code> object. In this example, we save references to the added objects in <code>p</code> and <code>v</code> to make it easier when setting attributes for the objects.</p>
<p>A slot value can be extracted with the <code>get_slot</code> method in the <code>StandardComponent</code> class. The method takes the slot name as argument. Note that to access the component class from the <code>cpu_list</code> attribute class the <em>_up</em> member is required.</p>
<h4 id="adding-array-of-objects">24.6.9.2 <a href="#adding-array-of-objects">Adding Array of Objects</a></h4>
<p>The <code>add_pre_obj</code> function can create nested arrays of identical objects. This is done by adding an index suffix to the slot name. All created objects are returned as nested array corresponding to the suffix. Here is an example that better explains how it works:</p>
<p>
</p><pre><code>class hal(StandardComponent):
    """The HAL component."""
    _class_desc = 'a HAL component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_hal_objects()
            self.do_hal_stuff()

    def add_hal_objects(self):
        self.add_pre_obj('clock', 'clock', freq_mhz = 2001)

        self.add_pre_obj('p_mem[4]', 'memory-space')
        self.add_pre_obj('v_mem[6][10]', 'memory-space')

    def do_hal_stuff(self):
        c = self.get_slot('clock')

        self.get_slot('p_mem[1]').queue = c
        self.get_slot('p_mem')[1].queue = c

        self.get_slot('v_mem[2][3]').queue = c
        self.get_slot('v_mem[2]')[3].queue = c
        self.get_slot('v_mem')[2][3].queue = c
</code></pre>
<p></p>
<p>The <em>p_mem</em> and <em>v_mem</em> slots both contain arrays of objects. The <em>p_mem</em> slot contains an array of 4 elements where each element is a <code>memory-space</code> object. The <em>v_mem</em> slot contains an array of 6 elements where each element is an array of 10 <code>memory-space</code> objects, i.e. totally 60 objects.</p>
<p>The <code>do_hal_stuff</code> method fetches the slots using the <code>get_slot</code> method. The <em>slot</em> argument can either be indexed or the indexing can be done after getting the slot. The two lines that work on the <em>p_mem</em> slot do the same and the three lines that work on the <em>v_mem</em> slot do the same thing.</p>
<p>Slot arrays are supported and can sometimes help when having many objects. Here is the output from using the arrays in the <code>hal</code> component class.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module examples-comp</strong>
simics&gt; <strong>new-hal name = my_hal</strong>
Created instantiated 'hal' component 'my_hal'
simics&gt; <strong>my_hal.p_mem</strong>
["my_hal.p_mem[0]", "my_hal.p_mem[1]", "my_hal.p_mem[2]", "my_hal.p_mem[3]"]
simics&gt; <strong>my_hal.p_mem[0]</strong>
"my_hal.p_mem[0]"
simics&gt; <strong>my_hal.v_mem[0]</strong>
[my_hal.v_mem[0][0], my_hal.v_mem[0][1], my_hal.v_mem[0][2], ↩
my_hal.v_mem[0][3], my_hal.v_mem[0][4], my_hal.v_mem[0][5], ↩
my_hal.v_mem[0][6], my_hal.v_mem[0][7], my_hal.v_mem[0][8], my_hal.v_mem[0][9]]
simics&gt; <strong>my_hal.v_mem[0][0]</strong>
my_hal.v_mem[0][0]
</code></pre>
<h4 id="lazy-slot-object-assignment">24.6.9.3 <a href="#lazy-slot-object-assignment">Lazy Slot Object Assignment</a></h4>
<p>The <code>add_pre_obj</code> method supports <code>None</code> as <em>slot</em> argument. This means that the pre objects will be created and returned by the method, but they will not be added to any slot. The pre objects can later be added to a slot using the <code>add_slot</code> method.</p>
<p>
</p><pre><code>class marvin(StandardComponent):
    """The Marvin component."""
    _class_desc = 'a Marvin component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_marvin_objects()

    def add_marvin_objects(self):
        self.add_pre_obj('clock', 'clock', freq_mhz = 2001)
        p_mem = [None,
                 self.add_pre_obj(None, 'memory-space'),
                 self.add_pre_obj(None, 'memory-space'),
                 None]
        self.add_slot('p_mem', p_mem)
</code></pre>
<p></p>
<p>This example shows how to create a slot with an mixed array of <code>None</code> and pre objects. The first and the last elements in the slot are unoccupied. The two middle elements contain pre objects. Here is the output when getting the slot value:</p>
<pre><code class="language-simics">simics&gt; <strong>new-marvin name = my_marvin</strong>
Created instantiated 'marvin' component 'my_marvin'
simics&gt; <strong>my_marvin.p_mem</strong>
[NIL, "my_marvin.p_mem[1]", "my_marvin.p_mem[2]"]
</code></pre>
<h3 id="adding-connectors">24.6.10 <a href="#adding-connectors">Adding Connectors</a></h3>
<p>Connectors are added to components similarly to how objects are added to slots, see <a class="reference" href="#adding-objects-to-slots">24.6.9</a>. A component that has connectors must implement the <code>component_connector</code> interface. Below we describe how to add connectors either by explicitly implementing the <code>component_connector</code> interface in section <a class="reference" href="#defining-connector-explicitly">24.6.10.1</a>, or using connector classes in section <a class="reference" href="#connector-classes">24.6.10.2</a>.</p>
<h4 id="defining-connector-explicitly">24.6.10.1 <a href="#defining-connector-explicitly">Defining Connector Explicitly</a></h4>
<p>One way of implementing connectors is to define the <code>component_connector</code> interface and implement all the functions that are needed for the connectors.</p>
<p>
</p><pre><code>class elliot(StandardComponent):
    """The Elliot component."""
    _class_desc = 'an Elliot component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_elliot_objects()

    def add_elliot_objects(self):
        self.add_connector(
             'eth0', 'ethernet-link', True, False, False,
             simics.Sim_Connector_Direction_Down)
        self.add_connector(
             'uart[2]', 'serial', True, False, False,
             simics.Sim_Connector_Direction_Down)
        dbg = self.add_connector(
             None, 'serial', True, False, False,
             simics.Sim_Connector_Direction_Down)
        self.add_slot('debug', dbg)

    class component_connector(Interface):
        def get_check_data(self, cnt):
            # same as connect_data
            return self._up.get_connect_data(cnt)
        def get_connect_data(self, cnt):
            return self._up.get_connect_data(cnt)
        def check(self, cnt, attr):
            return True
        def connect(self, cnt, attr):
            self._up.connect(cnt, attr)
        def disconnect(self, cnt):
            self._up.disconnect(cnt)

    def get_connect_data(self, cnt):
        if cnt in self.get_slot('uart'):
            num = self.get_slot('uart').index(cnt)
            return [None, self.get_slot('uart_dev%d' % num), 'uart%d' % num]
        elif cnt == self.get_slot('debug'):
            return [None, self.get_slot('dbg_dev'), 'debug']
        elif cnt.type == 'ethernet-link':
            return []

    def connect(self, cnt, attr):
        if cnt in self.get_slot('uart'):
            (link, console) = attr
            num = self.get_slot('uart').index(cnt)
            self.get_slot('uart_dev%d' % num).console = console
        elif cnt == self.get_slot('debug'):
            (link, console) = attr
            self.get_slot('dbg_dev').console = console
        elif cnt == self.get_slot('eth0'):
            self.get_slot('emac0').link = attr[0]

    def disconnect(self, cnt):
        if cnt in self.get_slot('uart'):
            num = self.get_slot('uart').index(cnt)
            self.get_slot('uart_dev%d' % num).console = None
        elif cnt == self.get_slot('debug'):
            self.get_slot('dbg_dev').console = None
        elif cnt == self.get_slot('eth0'):
            self.get_slot('emac0').link = None
</code></pre>
<p></p>
<p>The example component creates one connector in the slot <em>eth0</em>, one array of two connectors in the slot <em>uart</em>, and one connector in the slot <em>debug</em>.</p>
<p>The connector objects are created at once when adding a connector slot with the <code>add_connector</code> method. The function returns the objects or nested arrays of objects if the slot was specified, otherwise the function returns pre objects or nested arrays of pre objects, like the <em>dbg</em> connector in the example. In the latter case the objects are created when they are assigned to a slot using the <code>add_slot</code> function. This is to avoid creating connectors that are never assigned to any slot and therefore are useless.</p>
<p>The component implements the <code>component_connector</code> interface to handle the connector functionality. The interface is documented in the <em>API Reference Manual</em>. The different connector types are documented in section <a class="reference" href="#standard-connector-types">24.10</a>.</p>
<h4 id="connector-classes">24.6.10.2 <a href="#connector-classes">Connector Classes</a></h4>
<p>Most connectors are simple connectors with standard behavior. This makes it possible to use the same code for several components. The <code>StandardConnectorComponent</code> class in the <code>comp</code> Python module helps with this. The <code>StandardConnectorComponent</code> class inherits the <code>StandardComponent</code> class and supports the same features as that class. In addition the <code>StandardConnectorComponent</code> class implements the <code>component_connector</code> interface and a new definition of the <code>add_connector</code> method. The function takes a <em>connector class</em> as argument. The <em>connector class</em> provides all functionality for handling the connection.</p>
<p>The most common standard type of connectors has predefined connector classes. They are included in the <code>connector</code> Python module. This module is imported by the <code>comp</code> module, so there is no need to import it explicitly. The source code for these classes can be found in <code>[simics]/src/core/common/connectors.py</code>.</p>
<p>
</p><pre><code>class gertie(StandardConnectorComponent):
    """The Gertie PCI component."""
    _class_desc = "a Gertie PCI component"
    _help_categories = ('PCI',)

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_gertie_objects()
        self.add_gertie_connectors()

    def add_gertie_connectors(self):
        self.add_connector('pci', PciBusUpConnector(0, 'sample_dev'))

    def add_gertie_objects(self):
        self.add_pre_obj('sample_dev', 'sample_pci_device',
                         int_attr = 10)
</code></pre>
<p></p>
<p>Note that connectors instantiating a helper connector class that handles the connection must instantiate the connector class even if the component has been instantiated. The call to <em>add_gertie_connectors</em> in the example is independent of the <code>instantiated</code> attribute. This would otherwise result in an error when loading a checkpoint as the checkpoint will not contain the information about the helper class.</p>
<p>This is important to understand when using dynamic connectors (i.e. connectors created on demand); the component must be able to recreate the helper connector classes when a checkpoint is loaded. If the component did not do this, the checkpoint would load (and the system would run), but you would not be able to connect or disconnect any connectors. One way to determine which helper connectors to recreate is to look at attributes (or attributes of objects in the component).</p>
<p>One standard connector class is the <code>PciBusUpConnector</code>. The class takes <em>fun_num</em> and <em>device</em> as arguments. The <em>fun_num</em> is the function number and the <em>device</em> is the slot name of the PCI device that should be added to the PCI bus. The slot name must be given as a string.</p>
<p>It is possible to create own connector classes by inheriting from the <code>StandardConnector</code> class.</p>
<p>
</p><pre><code>class HarpoonUpConnector(StandardConnector):
    def __init__(self, device, required = False):
        if not isinstance(device, str):
            raise CompException('device must be a string')
        self.device = device
        self.type = 'harpoon-bus'
        self.hotpluggable = False
        self.required = required
        self.multi = False
        self.direction = simics.Sim_Connector_Direction_Up

    def get_check_data(self, cmp, cnt):
        return []
    def get_connect_data(self, cmp, cnt):
        return [cmp.get_slot(self.device)]
    def check(self, cmp, cnt, attr):
        return True
    def connect(self, cmp, cnt, attr):
        (num,) = attr
        cmp.get_slot(self.device).int_attr = num
    def disconnect(self, cmp, cnt):
        cmp.get_slot(self.device).int_attr = 0

class brody(StandardConnectorComponent):
    """The Brody component."""
    _class_desc = 'a Brody component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_brody_objects()
        self.add_brody_connectors()

    def add_brody_connectors(self):
        self.add_connector('jaws', HarpoonUpConnector('sample'))

    def add_brody_objects(self):
        self.add_pre_obj('sample', 'sample_device_dml')
</code></pre>
<p></p>
<h3 id="adding-components">24.6.11 <a href="#adding-components">Adding Components</a></h3>
<p>A component can contain sub components. The sub components are added when defining a component. A sub component will be assigned to a slot.</p>
<h4 id="adding-sub-component">24.6.11.1 <a href="#adding-sub-component">Adding Sub Component</a></h4>
<p>The first example just shows how to add a sub component.</p>
<p>
</p><pre><code>class hunt(StandardConnectorComponent):
    """The Hunt component."""
    _class_desc = 'a Hunt component'

    class impossible(SimpleAttribute(False, 'b')):
        """True if impossible, default is False."""

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_hunt_objects()
        self.add_hunt_connectors()

    def add_hunt_connectors(self):
        self.add_connector('mission1', HarpoonUpConnector('sample'))
        self.add_connector('mission2', HarpoonUpConnector('sample'))

    def add_hunt_objects(self):
        self.add_pre_obj('sample', 'sample_device_dml')
        self.add_pre_obj('clock', 'clock', freq_mhz = 4711)

class ethan(StandardConnectorComponent):
    """The Ethan component."""
    _class_desc = 'an Ethan component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_ethan_objects()

    def add_ethan_objects(self):
        self.add_component('last', 'hunt', [['impossible', True]])
        self.copy_connector('copy', 'last.mission1')
        mem = self.add_pre_obj('mem', 'memory-space')
        mem.queue = self.get_slot('last.clock')
</code></pre>
<p></p>
<p>The <code>ethan</code> component in the example creates a sub component with the slot name <em>last</em> of the <code>hunt</code> class type.</p>
<p>The <code>ethan</code> component also copies the <em>mission</em> connector from the <em>last</em> component and puts it in the slot <em>copy</em>. This kind of copy can only be done for connector objects. Note that this is a superior solution to the runtime command <code>copy-connector</code>, which has the same effect at run time but does not update the documentation and requires care when checkpointing.</p>
<p>Note that the <code>get_slot</code> and <code>copy_connector</code> methods can get slots not only in the components own namespace but in the sub components namespace. In the example this is done by the <em>self.get_slot('last.clock')</em> call. It is also possible to access slots in a sub component to the sub component. There is no limit to the look-up depth.</p>
<h4 id="adding-and-connecting-sub-components">24.6.11.2 <a href="#adding-and-connecting-sub-components">Adding and Connecting Sub Components</a></h4>
<p>Two sub components can be both instantiated and connected when defined.</p>
<p>
</p><pre><code>class BessonUpConnector(StandardConnector):
    def __init__(self):
        self.type = 'besson'
        self.hotpluggable = False
        self.required = False
        self.multi = False
        self.direction = simics.Sim_Connector_Direction_Up
    def get_check_data(self, cmp, cnt):
        return []
    def get_connect_data(self, cmp, cnt):
        return []
    def check(self, cmp, cnt, attr):
        return True
    def connect(self, cmp, cnt, attr):
        pass
    def disconnect(self, cmp, cnt):
        pass

class BessonDownConnector(StandardConnector):
    def __init__(self):
        self.type = 'besson'
        self.hotpluggable = False
        self.required = False
        self.multi = False
        self.direction = simics.Sim_Connector_Direction_Down
    def get_check_data(self, cmp, cnt):
        return []
    def get_connect_data(self, cmp, cnt):
        return []
    def check(self, cmp, cnt, attr):
        return True
    def connect(self, cmp, cnt, attr):
        pass
    def disconnect(self, cmp, cnt):
        pass

class korben(StandardConnectorComponent):
    """The Korben component."""
    _class_desc = 'a Korben component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_korben_objects()
        self.add_korben_connectors()

    def add_korben_connectors(self):
        self.add_connector('earth', BessonUpConnector())

    def add_korben_objects(self):
        pass

class zorg(StandardConnectorComponent):
    """The Zorg component."""
    _class_desc = 'a Zorg component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_zorg_objects()
        self.add_zorg_connectors()

    def add_zorg_connectors(self):
        self.add_connector('water', BessonDownConnector())

    def add_zorg_objects(self):
        pass

class leeloo(StandardConnectorComponent):
    """The Leeloo component."""
    _class_desc = 'a Leeloo component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_leeloo_objects()

    def add_leeloo_objects(self):
        self.add_pre_obj('clock', 'clock', freq_mhz = 10)
        self.add_component('korb_slot', 'korben', [])
        self.add_component('zorg_slot', 'zorg', [])
        self.connect(self.get_slot('korb_slot.earth'),
                     self.get_slot('zorg_slot.water'))
</code></pre>
<p></p>
<p>The <code>leeloo</code> component creates a <code>korben</code> sub component and <code>zorg</code> sub component. The two sub components are connected using the <code>connect</code> method. Arguments to the method are the connectors in the sub components.</p>
<h3 id="overriding-interfaces">24.6.12 <a href="#overriding-interfaces">Overriding Interfaces</a></h3>
<p>The <code>StandardComponent</code> class implements the <code>component</code> interface. The interface implementation can be overridden if needed.</p>
<p>
</p><pre><code>class godzilla(StandardComponent):
    """The Godzilla component."""
    _class_desc = 'a Godzilla component'

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_godzilla_objects()

    def add_godzilla_objects(self):
        self.add_pre_obj('mem', 'memory-space')
        self.add_pre_obj('p_mem', 'memory-space')

    class component(StandardComponent.component):
        def post_instantiate(self):
            self._up.get_slot('mem').default_target = [
                self._up.get_slot('p_mem'), 0, 0, None]
</code></pre>
<p></p>
<p>In the example we override the <code>post_instantiate</code> method. A component usually does not have to override the <code>component</code> interface.</p>
<h3 id="adding-dynamic-connectors">24.6.13 <a href="#adding-dynamic-connectors">Adding Dynamic Connectors</a></h3>
<p>A connector can support connecting to multiple connectors or just one other connector. This is defined by the <em>multi</em> attribute for the connector. Connectors that connect to multiple connectors are not recommended, it is often better to support dynamic connectors, i.e. new connectors that are created when required.</p>
<p>Here is an example how to create connectors when needed, the example can be found in <code>[simics]/src/components/sample-dynamic-connectors</code>:</p>
<p>
</p><pre><code>import simics
from comp import *

class sample_dynamic_connectors(StandardComponent):
    """A sample component dynamically creating connectors."""
    _class_desc = "sample comp with dynamic connectors"

    def setup(self):
        super().setup()
        if not self.instantiated.val:
            self.add_objects()

    class top_level(StandardComponent.top_level):
        def _initialize(self):
            self.val = True

    class num_serials(SimpleAttribute(0, 'i')):
        """Number of serial connectors"""

    def create_uart_and_connector(self):
        num = self.num_serials.val
        self.add_connector(
            'uart%d' % num, 'serial', True, False, False,
            simics.Sim_Connector_Direction_Down)
        if self.instantiated.val:
            o = simics.SIM_create_object('NS16550', '')
        else:
            o = pre_obj('', 'NS16550')
        self.add_slot('uart_dev%d' % num, o)
        self.num_serials.val += 1

    def add_objects(self):
        self.add_pre_obj('clock', 'clock', freq_mhz = 10)
        self.create_uart_and_connector()

    class component_connector(Interface):
        def get_check_data(self, cnt):
            return []
        def get_connect_data(self, cnt):
            self._up.create_uart_and_connector()
            num = int(cnt.name.split('uart')[1])
            return [None, self._up.get_slot('uart_dev%d' % num), cnt.name]
        def check(self, cnt, attr):
            return True
        def connect(self, cnt, attr):
            num = int(cnt.name.split('uart')[1])
            udev = self._up.get_slot('uart_dev%d' % num)
            (link, console) = attr
            if link:
                udev.link = link
            else:
                udev.console = console
        def disconnect(self, cnt):
            num = int(cnt.name.split('uart')[1])
            udev = self._up.get_slot('uart_dev%d' % num)
            udev.link = None
            udev.console = None
</code></pre>
<p></p>
<p>The <code>create_uart_and_connector</code> method in the <em>sample_dynamic_connectors</em> component creates a new uart connector object and a uart device. The function is called each time someone connects to one of the component's connectors and when the component is created. This means that the component will have one empty connector when the component is created and there will always exist at least one empty connector in the component.</p>
<p>The example code does not handle disconnecting and removal of unused connectors. This means that there might exist more than one empty connector. But it is just an example that can be used as reference.</p>
<h2 id="example-component">24.7 <a href="#example-component">Example Component</a></h2>
<h3 id="sample-component">24.7.1 <a href="#sample-component">Sample Component</a></h3>
<p>The sample component is a very simple component that can be used as reference when writing a component. The source code can be found in the <code>src/components/sample-components</code> directory. The <code>sample-pci-card</code> can for instance be added to the <code>Firststeps</code> machine. This <code>Firststeps</code> machine is in <em>QSP-x86 Package</em>.</p>
<p>Here is an example how to add a new PCI card from the command line:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module sample-components</strong>
simics&gt; <strong>new-sample-pci-card foo integer_attribute = 99</strong>
Created instantiated 'sample_pci_card' component 'foo'
simics&gt; <strong>connect foo.pci_bus "board.mb.nb.pci_slot[0]"</strong>
</code></pre>
<h3 id="hierarchical-component-example">24.7.2 <a href="#hierarchical-component-example">Hierarchical Component Example</a></h3>
<p>This section describes a hierarchical system with components. We use the simple PC system in figure <a class="reference" href="#conf_component_new_example_0">13</a> as an example.</p>
<figure id="conf_component_new_example_0">
<p><img alt="" src="conf_component_new_example_0.png"> </p><figcaption>Figure 13. Example hierarchical system</figcaption><p></p>
</figure>
<p>The system in figure <a class="reference" href="#conf_component_new_example_0">13</a> consists of the <code>pc_system</code>, <code>motherboard</code>, <code>northbridge</code>, <code>southbridge</code>, <code>pci_eth</code>, <code>usb_device</code>, and two <code>ddr_memory</code> components.</p>
<p>The components contains both regular objects (drawn as ellipses in the figure), and sub components (drawn as rectangles with drop shadows). An object can be a processor, device, or an extension. Remember that an extension is something that add simulation functionality, such as a trace object.</p>
<p>The blue and cyan circular objects on the edge of the components are connectors. A blue connector is a connector that is owned by the component it is in. A cyan connector is an inherited connector from another component. An inherited connector can also be seen as a reference connector. The dashed line shows how the connector has been inherited. The connector called <em>eth</em> in <code>northbridge</code> has been inherited to <code>motherboard</code> as <em>geth</em>, and <em>geth</em> has been inherited by <code>pc_system</code> as <em>eth0</em>. The <code>pc_system</code> component could inherit <em>eth</em> directly from <code>northbridge</code>, but that is not the case in this example. We will not distinguish reference connectors from real connectors in this section, as they look identical to an outside observer. Only the component designer who sets up the system needs to be aware of the distinction.</p>
<p>Connectors can be connected to other connectors, forming connections. The solid blue lines in the figure are connections. Two connectors can only be connected if they belong to components that are on the same hierarchical level, or if one of the components is a sub component of the other. The <code>northbridge</code> and <code>southbridge</code> components are on the same level, and they can connect to each other through their connectors. The <code>ddr_memory</code> and <code>motherboard</code> components can be connected because the <code>ddr_memory</code> components are sub components of <code>motherboard</code>.</p>
<p>The <code>pc_system</code> component contains all components in its component tree except <code>usb_device</code>. Both <code>pc_system</code> and <code>usb_device</code> are on the same level—in this case, the so-called root level.</p>
<p>The <code>pci_eth</code> and <code>ddr_memory0_1</code> components have a different color to indicate that they were not defined in the <code>pc_system</code> component, but added at runtime. The <code>pc_system.ddr2_3</code> connectors have not been connected to any component.</p>
<figure id="conf_object_connections_0">
<p><img alt="" src="conf_object_connections_0.png"> </p><figcaption>Figure 14. Object connections in a hierarchical system</figcaption><p></p>
</figure>
<p>It is actually objects that must be connected (see section <a class="reference" href="#hierarchical-component-example">24.7.2</a>); the component connectors merely provide a way of sending the data between components needed for setting up the object attributes. Figure <a class="reference" href="#conf_object_connections_0">14</a> shows the components and the objects from figure <a class="reference" href="#conf_component_new_example_0">13</a>, but now the actual connections between the objects are in focus. The dashed lines between the objects show how the objects are connected. A lot of the objects are connected to the <code>pci_bus</code> object. This is very common on a generic PC system. Even objects that are not in the same component tree are connected, e.g., the <code>usb</code> object and the <code>usb_disk</code> object.</p>
<h3 id="flat-component-example">24.7.3 <a href="#flat-component-example">Flat Component Example</a></h3>
<p>This section describes how to create a system consisting of only root components in component hierarchies. Although it is better to create hierarchical system models as shown in the example in section <a class="reference" href="#hierarchical-component-example">24.7.2</a>, the creation of flat systems is supported. The flat system modeling concept is primarily useful when modeling a system that is best described as a "collection of peers", such as a rack of computers. Additionally, several standard system models provided with Simics are implemented as flat systems, since hierarchical components were not supported when these systems were built. It is expected that all such systems will be upgraded to hierarchical models over time.</p>
<figure id="conf_component_old_example_0">
<p><img alt="" src="conf_component_old_example_0.png"> </p><figcaption>Figure 15. Example of a flat system</figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#conf_component_old_example_0">15</a> shows a flat system representation of the system shown in figure <a class="reference" href="#conf_component_new_example_0">13</a>. The difference is that there are no hierarchical components in figure <a class="reference" href="#conf_component_old_example_0">15</a>.</p>
<p>The biggest advantage of hierarchical systems over flat systems is clarity. In a hierarchical configuration, objects, commands, and attributes are only accessible via their hierarchical name in the hierarchy, and do not clutter the top-level namespace. This is particularly important for large systems with many objects. Consider a big rack with several boards, each with several devices and processors. Simics requires that all objects at the same level of the namespace have unique names. Thus, objects of the same type in different parts of the system either need long, essentially hierarchical, names; or else the user must remember which randomly named objects make up which part of the system. Using hierarchy reduces complexity by providing a system for naming.</p>
<h2 id="component-reference">24.8 <a href="#component-reference">Component Reference</a></h2>
<p>This section describes the interfaces, commands, attributes, and classes that are provided by Simics to help implement components.</p>
<h3 id="component-interfaces">24.8.1 <a href="#component-interfaces">Component Interfaces</a></h3>
<p>This section documents the set of interfaces that every component is required to implement. These interfaces ensure that the component works with Simics commands and the API that operates on components. See <a class="reference" href="#the-comp-component">24.11</a> for the default implementations provided by the <code>comp</code> Python module.</p>
<h4 id="component_interface_t">24.8.1.1 <a href="#component_interface_t">component_interface_t</a></h4>
<p>
</p><p>All component classes must implement the <code>component</code>
interface. All functions in the interface must be implemented.</p>
<p>The <code>pre_instantiate</code> function is called before the
component is instantiated. The function returns <code>true</code> if the
component can be instantiated, or <code>false</code> if not.</p>
<p>The component might need to do some extra work after the component
has been instantiated. This should be done when called via the
<code>post_instantiate</code> function.</p>
<p>The <code>create_cell</code> function returns <code>true</code> if the
configuration system can create a default cell object for the
component, or <code>false</code> if not. Both
<code>pre_instantiate</code> and <code>create_cell</code> typically
return <code>true</code>.</p>
<p>Component has slots. A slot has key and value. The key is the slot
name as a string. The value is a conf object, a pre conf object, or
None, or nested lists of such types.</p>
<p>Slots are either defined in the component or added after the
component has been created. Slots defined in the component are
static slots which can not be deleted, but the slot value can be
changed. Slots added to the component after creation are
dynamic slots and they can be removed when wanted.</p>
<p>The <code>get_slots</code> function returns a dictionary with slot
names as dictionary keys and slot values as dictionary values.</p>
<p>The <code>get_slot_objects</code> function returns a list of all conf
objects and pre conf objects extracted from all slot values.</p>
<p>The <code>get_slot_value</code> returns the slot value. The slot name
is passed as <em>slot</em> argument. A slot value is set using
the <code>set_slot_value</code> function. The <em>value</em>
argument should be a conf object, pre conf object, or None, or
nested lists of such types. The get function returns NULL on failure.
The set function does not return anything to indicate failure.</p>
<p>The <code>has_slot</code> function returns <code>true</code> if the
<em>slot</em> exists, otherwise <code>false</code>. The slot can
either be a static slot or a dynamic slot. The <code>add_slot</code>
function adds the slot named <em>slot</em>. Adding a slot can
fail if the slot already exist. The added slot will be a dynamic
slot. A dynamic slot can be deleted. The <code>del_slot</code>
function deletes a dynamic slot. Deleting a slot will fail if the
slot does not exist or if the slot is static. Both
<code>add_slot</code> and <code>del_slot</code> returns <code>true</code>
on success or <code>false</code> on failure.</p>

<pre><code>SIM_INTERFACE(component) {
        bool (*pre_instantiate)(conf_object_t *obj);
        void (*post_instantiate)(conf_object_t *obj);
        bool (*create_cell)(conf_object_t *obj);

        attr_value_t (*get_slots)(conf_object_t *obj);
        attr_value_t (*get_slot_objects)(conf_object_t *obj);

        attr_value_t (*get_slot_value)(conf_object_t *obj,
                                 const char *NOTNULL slot);
        void (*set_slot_value)(conf_object_t *obj,
                         const char *NOTNULL slot,
                         attr_value_t value);

        bool (*has_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
        bool (*add_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
        bool (*del_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
};
#define COMPONENT_INTERFACE "component"
</code></pre>
<p></p>
<h4 id="component_connector__interface_t">24.8.1.2 <a href="#component_connector__interface_t">component_connector__interface_t</a></h4>
<p>
</p><p>The <code>component_connector</code> is implemented by components
that use connector objects for handling connections between components.</p>
<p>The connection setup is made in two stages, the check stage and the
connect stage. The check stage is often not needed, but it can be
used to make sure that the later connect step will not fail. Each
connection is handled by a connector object. The connector object
will both handle the connection in both direction, i.e. sending
connect information and receiving connector information. Two
components that should be connected must implement one connector
object each.</p>
<p>The <code>get_check_data</code> and <code>get_connect_data</code> will
be called from the connector object to get connection data to send
to the other part of the connection, i.e. to the destination. The
data sent must be an <code>attr_value_t</code> type.</p>
<p>The <code>check</code>, <code>connect</code>, and <code>disconnect</code>
functions are called from the connector object when another
connector wants to connect to this connection. The connection data
is passed as the <em>attr</em> argument.</p>

<pre><code>SIM_INTERFACE(component_connector) {
        attr_value_t (*get_check_data)(conf_object_t *obj,
                                       conf_object_t *NOTNULL connector);
        attr_value_t (*get_connect_data)(conf_object_t *obj,
                                         conf_object_t *NOTNULL connector);
        bool (*check)(conf_object_t *obj, conf_object_t *NOTNULL connector,
                      attr_value_t attr);
        void (*connect)(conf_object_t *obj, conf_object_t *NOTNULL connector,
                        attr_value_t attr);
        void (*disconnect)(conf_object_t *obj,
                           conf_object_t *NOTNULL connector);
};

#define COMPONENT_CONNECTOR_INTERFACE "component_connector"
</code></pre>
<p></p>
<h3 id="component-commands">24.8.2 <a href="#component-commands">Component Commands</a></h3>
<p>All required component commands are either provided by the <code>comp</code> Python module or generated by project-setup as described in <a class="reference" href="#creating-a-new-component">24.6.1</a>. The standard <code>info</code> and <code>status</code> commands will need to be extended to be relevant to the actual component.</p>
<h3 id="component-attributes">24.8.3 <a href="#component-attributes">Component Attributes</a></h3>
<p>This section documents the set of attributes that every component is required to implement. These attributes ensure that the component works with Simics commands and the API that operates on components.</p>
<p>Note that some attributes are marked as <em>optional</em>. This means that the value of the attribute does not need to be specified, not that the attribute does not need to be implemented.</p>
<p>We draw a distinction between attributes that define the state of a given instance of a component, and class attributes that are the same for all instances of a given component class.</p>
<h4 id="attributes">24.8.3.1 <a href="#attributes">Attributes</a></h4>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:instantiated">instantiated</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>boolean</strong>.</p>
<p>Set to TRUE if the component has been instantiated.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:object_list">object_list</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>dictionary</strong> or <strong>nil</strong>.</p>
<p>Dictionary with objects that the component consists of. The dictionary key is the name of the slot including array index as a string and the value is a single object or <code>None</code>.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:object_prefix">object_prefix</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>string</strong> or <strong>nil</strong>.</p>
<p>Object prefix string used by the component.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:top_level">top_level</span></p>
<p><strong>Optional</strong> attribute; <strong>read-write</strong> access; type: <strong>boolean</strong> or <strong>nil</strong>.</p>
<p>Set to TRUE for top-level components, i.e. the root of a hierarchy.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:top_component">top_component</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>object</strong> or <strong>nil</strong>.</p>
<p>The top level component. Attribute is not valid until the component has been instantiated.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:components">components</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>[o*]</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. List of components below the top-level component. This attribute is not valid until the object has been instantiated.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:cpu_list">cpu_list</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>[o*]</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. List of all processors below the top-level component. This attribute is not valid until the object has been instantiated.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:machine_icon">machine_icon</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>string</strong> or <strong>nil</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. An instance of a top-level component may override the default <code>system_icon</code> with its own icon. This attribute is the name of an 80x80 pixel large icon in PNG format that should reside in the [host]/lib/images directory of the Simics installation or the project.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:system_info">system_info</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>string</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. A short single-line description of the current configuration of the system that the component is a top-level component of. The line may include the Linux name of the simulated machine, the installed operating system, or similar information. For example "Tango - Fedora Core 5 Linux".</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:domain">domain</span></p>
<p><strong>Optional</strong> attribute; <strong>read/write</strong> access; type: <strong>object</strong> or <strong>nil</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. Domain to put the component in.</p>
</li>
</ul>
</div>
<h4 id="class-attributes">24.8.3.2 <a href="#class-attributes">Class Attributes</a></h4>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:basename">basename</span></p>
<p><strong>Pseudo</strong> <strong>class</strong> attribute; <strong>read-only</strong> access; type: <strong>string</strong>.</p>
<p>The basename of the component.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:component_icon">component_icon</span></p>
<p><strong>Pseudo</strong> <strong>class</strong> attribute; <strong>read-only</strong> access; type: <strong>string</strong> or <strong>nil</strong>.</p>
<p>Name of a 24 by 24 pixel icon in PNG format used to graphically represent the component in a configuration viewer.</p>
</li>
</ul>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:system_icon">system_icon</span></p>
<p><strong>Pseudo</strong> <strong>class</strong> attribute; <strong>read-only</strong> access; type: <strong>string</strong> or <strong>nil</strong>.</p>
<p>This attribute is only valid if the <code>top_level</code> attribute is TRUE. Name of an 80 by 80 pixel icon in PNG format used to graphically represent the system that the component is a top-level of.</p>
</li>
</ul>
</div>
<h3 id="standard-attributes">24.8.4 <a href="#standard-attributes">Standard Attributes</a></h3>
<p>It is recommended that some standard attribute names are used for common component characteristics. Such attributes are used by the Simics Control window in the GUI for example to collect information. The attributes only need to be readable.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:memory_megs">memory_megs</span></p>
<p>type: <strong>integer</strong>. Components with memory that should be included in the count of total system memory should have this attribute representing the amount of memory in MiB. This is not needed if the component is connected to memory DIMM components.</p>
</li>
<li>
<p><span class="term" id="dt:memory_bytes">memory_bytes</span></p>
<p>type: <strong>integer</strong>. Similar to <code>memory_megs</code> but used for systems with small memory sizes.</p>
</li>
</ul>
</div>
<h3 id="standard-interfaces">24.8.5 <a href="#standard-interfaces">Standard Interfaces</a></h3>
<p>Storage devices should implement the <code>disk_component</code> interface that is used by the GUI to present information about the total amount of attached disk storage in a system.</p>
<h2 id="various-component-features">24.9 <a href="#various-component-features">Various Component Features</a></h2>
<p>The following information is not meant to provide coding guidelines but to help the programmer gain a better understanding of components.</p>
<h3 id="checkpointing">24.9.1 <a href="#checkpointing">Checkpointing</a></h3>
<p>The majority of a component's state is checkpointed via the attributes that are used to configure it. There are also separate attributes that are only used for checkpointing, discussed in sections <a class="reference" href="#adding-attributes">24.6.5</a> and <a class="reference" href="#component-attributes">24.8.3</a>.</p>
<p>Other data that should be checkpointed includes state calculated or received during the connection phase, since it may be needed to support later reconfiguration for hotplugging components.</p>
<p>All information about connectors and connections is checkpointed automatically by the connector objects in the components.</p>
<h3 id="automatic-queue-assignment">24.9.2 <a href="#automatic-queue-assignment">Automatic Queue Assignment</a></h3>
<p>All Simics configuration objects that handle time in any way must have their <em>queue</em> attribute set. A queue makes time advance, and makes it possible to post events. Any object that implements the <code>cycle</code> interface can be used as a queue; the only objects that currently do this are processors and objects of the class <code>clock</code>. All objects that have the same queue are said to be part of the same <em>time domain</em>.</p>
<p>The component system automatically sets the queue attribute for all objects at instantiation time, based on the component hierarchy. To override the automatic queue assignment, for example on multiprocessor boards where each processor should be its own queue, simply assign the queue attribute when adding the pre-configuration objects.</p>
<div class="note">
When building a model of an asymmetric multiprocessor board which logically consists of multiple systems, create multiple sub components rather than spending time manually setting queue attributes.
</div>
<h3 id="automatic-recorder-assignment">24.9.3 <a href="#automatic-recorder-assignment">Automatic Recorder Assignment</a></h3>
<p>Devices that handle input, such as serial and network devices, keyboards, and mice, usually implement a connection to a <code>recorder</code> object. All their input passes through the recorder so that it may record the input to the file and later replay the same input from the file.</p>
<p>The component system automatically creates a recorder and connects it to all input devices that have a <code>recorder</code> attribute. A component can override this automatic assignment by setting the <code>recorder</code> attribute itself for its objects.</p>
<h3 id="inheritance">24.9.4 <a href="#inheritance">Inheritance</a></h3>
<p>Since components are implemented as Python classes, it is easy to create new components that are similar to existing ones by using inheritance. Instead of basing the component on the <code>StandardComponent</code> base class, another component class can be used. The new component class can, for example, remove unnecessary connectors, add new connectors, add new objects, and override methods.</p>
<h3 id="hotplugging">24.9.5 <a href="#hotplugging">Hotplugging</a></h3>
<p>Components may be added and removed from the configuration during simulation. This can be used to simulate the effects of changes in the simulated hardware, e.g., plugging in a new board into a rack or unplugging a network cable.</p>
<p>The connectors to the component must be set to support hotplugging to allow connection or disconnection during simulation. You can even instantiate an extension to an existing configuration using hotplugging.</p>
<p>When a connector representing a link is disconnected, all in-flight messages on the link are discarded.</p>
<p>If a component is disconnected, i.e., all of its connectors are disconnected, communication to and from the component is stopped. Both the objects within component and the rest of the configuration continues to be simulated. Additionally, any communication within the component continues. To stop the simulation in the component while continuing simulation in the rest of the configuration (e.g., simulating power-off of a component), you have to explicitly add this functionality to the models. The models should remove the events that they have posted on any event queues. The <code>queue</code> attributes will be set to Nil by Simics after the disconnection.</p>
<p>If a component is connected again to some other part of the configuration, the <code>queue</code> attributes of the object making up the component are automatically set to a queue inside the new top-level component. If a specific queue is needed, it should be passed along in the connect data and be assigned in the connect method. Simics will not touch queue attributes that are set by the connect method. The component should notify its models about being hotplugged, so that they can repost their events on the new queue.</p>
<h2 id="standard-connector-types">24.10 <a href="#standard-connector-types">Standard Connector Types</a></h2>
<p>The following is a list of common connector types found in many of the architecture models implemented by Simics. Machine-specific connector types are not described in this section. The tables list all connector directions and the data that should be passed for connectors of each direction, including check data if it is different from the connect data.</p>
<p>The data listed for each connector type should be returned by the <code>get_connect_data</code> function in the <code>component_connector</code> interface, which is implemented by all components. The check data should be returned by the <code>get_check_data</code> function in the <code>component</code> interface. See the section <a class="reference" href="#adding-connectors">24.6.10</a> for more information how to implement connectors.</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>one direction</td><td>[&lt;first argument&gt;, &lt;second argument&gt;, <em>…</em>]</td></tr>
<tr><td>other direction(s)</td><td>[&lt;first argument&gt;, <em>…</em>]</td></tr>
</tbody></table>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:agp-bus"><code>agp-bus</code></span></p>
<p>Used to connect AGP based graphics devices.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;AGP slot&gt;, &lt;<code>agp-bus</code> object&gt;]</td></tr>
<tr><td>up</td><td>[[[&lt;AGP function&gt;, &lt;<code>agp-device</code> object&gt;]*]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:compact-pci-bus"><code>compact-pci-bus</code></span></p>
<p>Used to connect cPCI cards to a backplane component wrapping the standard PCI bus. The backplane component, defining the <code>down</code> connector, must make sure that the pci-bus pre-configuration object has the <code>pci_devices</code> and <code>bridge</code> attributes initialized.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;PCI device number&gt;, &lt;PCI bus object&gt;]</td></tr>
<tr><td>up</td><td>[[[&lt;PCI function number&gt;, &lt;PCI device object&gt;, &lt;is_bridge&gt;]*]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:datagram-link"><code>datagram-link</code></span></p>
<p>Used to connect datagram_link devices and datagram links. <em>Up and down <code>datagram-link</code> connectors cannot be connected. They have to be connected to an <code>any</code> connector</em>.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>any</td><td>[&lt;datagram link object&gt;]</td></tr>
<tr><td>down</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
<tr><td>up</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:ethernet-link"><code>ethernet-link</code></span></p>
<p>Used to connect Ethernet devices and Ethernet links. <em>Up and down <code>ethernet-link</code> connectors cannot be connected. They have to be connected to an <code>any</code> connector</em>.</p>
<p>Note also that when using old-style Ethernet links (of class <code>ethernet-link</code>) only, the arguments provided by the up and down connectors will be ignored and can be skipped.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>any</td><td>[&lt;ethernet link object&gt;]</td></tr>
<tr><td>down</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
<tr><td>up</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:fc-loop"><code>fc-loop</code></span></p>
<p>Simplified Fibre-Channel connection. The controller should have a connect function that makes sure that disk IDs on the loop are unique.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;fc-controller object&gt;]</td></tr>
<tr><td>up</td><td>[&lt;fc-device object&gt;, &lt;loop ID&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:graphics-console"><code>graphics-console</code></span></p>
<p>Used to connect a graphical console to a graphics device.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;graphics-device object&gt;]</td></tr>
<tr><td>up</td><td>[&lt;graphics-console object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:keyboard"><code>keyboard</code></span></p>
<p>Used to connect a keyboard device to a console for receiving real keyboard input.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;keyboard object&gt;]</td></tr>
<tr><td>up</td><td>[&lt;console object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:i2c-link"><code>i2c-link</code></span></p>
<p>Used to connect a i2c-link-v2 device to i2c link. The device is expected to have i2c_link_v2 attribute.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;i2c-link-v2 device object&gt;, &lt;port&gt;]</td></tr>
<tr><td>up</td><td>[&lt;i2c-link-v2 link object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:ide-slot"><code>ide-slot</code></span></p>
<p>Provides connection between an IDE controller and IDE disks and CD-ROMs.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>-</td></tr>
<tr><td>up</td><td>[&lt;IDE device object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:isa-bus"><code>isa-bus</code></span></p>
<p>Used to connect legacy ISA devices to an ISA bus. The connect function in the component with the <code>down</code> connector should detect port number collisions.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;port-space object&gt;, &lt;memory-space object&gt;, &lt;interrupt object&gt;, &lt;dma object&gt;]</td></tr>
<tr><td>up</td><td>-</td></tr>
<tr><td>up check</td><td>[[&lt;port-number&gt;*]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:mem-bus"><code>mem-bus</code></span></p>
<p>Connection for SDRAM components providing SPD information. The connect function should make sure that only SDRAM of the correct type and width is inserted in a memory slot.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;i2c-bus object&gt;, &lt;i2c-bus address&gt;]</td></tr>
<tr><td>up</td><td>[&lt;memory-megs&gt;, &lt;memory-ranks&gt;]</td></tr>
<tr><td>up check</td><td>[&lt;type&gt;, &lt;memory_megs&gt;, &lt;memory-ranks&gt;, &lt;bit width&gt;, &lt;ECC width&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:mouse"><code>mouse</code></span></p>
<p>Used to connect a mouse device to a console for receiving real mouse input.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;mouse object&gt;]</td></tr>
<tr><td>up</td><td>[&lt;console object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:panel-input-bool-panel-input-number-panel-output-bool-panel-output-number"><code>panel-input-bool</code>, <code>panel-input-number</code>, <code>panel-output-bool</code>, <code>panel-output-number</code></span></p>
<p>Used to connect a system panel to a target component.</p>
<p>The <code>input</code> types are used when the component receives input from a widget in the panel.</p>
<p>The <code>output</code> types are used when the component exposes its state to the panel.</p>
<p>The <code>bool</code> types transfer boolean state via the <code>signal</code> interface. The <code>number</code> types transfer numeric state via the <code>uint64_state</code> interface.</p>
<p>The direction of the connector is always <code>up</code> in the panel and <code>down</code> in the target component.</p>
<p>The connector data is identical for the <code>bool</code> and <code>number</code> types, but differs depending on the combination of <code>up</code>/<code>down</code> and <code>input</code>/<code>output</code>:</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down/input or up/output</td><td>[&lt;target object&gt;, &lt;port&gt;]</td></tr>
<tr><td>down/output or up/input</td><td>-</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:pci-bus"><code>pci-bus</code></span></p>
<p>Used to connect PCI devices to a standard PCI bus. A component defining the <code>down</code> connector must make sure that the pci-bus pre-configuration object has the <code>pci_devices</code> attribute set.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;PCI device number&gt;, &lt;PCI bus object&gt;]</td></tr>
<tr><td>up</td><td>[[[&lt;PCI function number&gt;, &lt;PCI device object&gt;]*]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:pcmcia-slot"><code>pcmcia-slot</code></span></p>
<p>Used to connect PCMCIA (PC-CARD) devices into a PCMCIA controller. <em>The arguments exported by the up connector is expected to change in a future Simics version</em>.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;PCMCIA device object&gt;, &lt;slot ID&gt;]</td></tr>
<tr><td>up</td><td>[&lt;<code>attr-space</code> object&gt;, &lt;<code>common-space</code> object&gt;, &lt;<code>io-space</code> object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:rapidio"><code>rapidio</code></span></p>
<p>Used to connect two RapidIO ports together.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
<tr><td>up</td><td>[&lt;device object&gt;] or [[&lt;device object&gt;, &lt;port&gt;]]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:sb-interrupt"><code>sb-interrupt</code></span></p>
<p>South Bridge interrupt routing connection.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;interrupt object&gt;, &lt;<code>io-apic</code> object&gt;]</td></tr>
<tr><td>up</td><td>[&lt;interrupt object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:serial"><code>serial</code></span></p>
<p>Used to connect serial devices together, and to different kinds of serial consoles. When implementing a down connector make sure to use the name of the serial device object in the console title. This makes it easier to identify the console in a system with several consoles. <em>Either the link argument or the console/device must be supported, but not both</em>.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>[&lt;link&gt;, &lt;serial-device object&gt;, &lt;console title&gt;]</td></tr>
<tr><td>up</td><td>[&lt;serial-link&gt;, &lt;text-console object&gt;]</td></tr>
</tbody></table>
</div>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:mmc"><code>mmc</code></span></p>
<p>Used to connect MMC/SD cards to controllers. The card is required to implement the <code>mmc</code> interface.</p>
</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>down</td><td>-</td></tr>
<tr><td>up</td><td>[&lt;MMC/SD card object&gt;]</td></tr>
</tbody></table>
</div>
<h2 id="the-comp-component">24.11 <a href="#the-comp-component">The comp Component</a></h2>
<p>The <em>API Reference Manual</em> documents the classes and methods implemented in the <code>comp</code> Python module. This section documents the default implementation of the methods in the <code>component</code> interface in the <code>StandardComponent</code> class. This section does not duplicate the documentation of <code>StandardComponent</code> methods not part of the <code>component</code> interface, for example <code>get_slot</code>, which are documented in the reference manual in the Python-specific API section of the API chapter.</p>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-add_slot"><a href="#comp-standardcomponent-component-add_slot">comp.StandardComponent.component.add_slot()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name"><a href="#name">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>add_slot</strong> — add slot</li>
</ul>
</div>
<h4 id="synopsis"><a href="#synopsis">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>add_slot(self, slot)
</code></pre>
</li>
</ul>
</div>
<h4 id="description"><a href="#description">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function adds a dynamic slot named <em>slot</em> if it does not already exist. It returns <code>True</code> if it could add the slot.</li>
</ul>
</div>
<h4 id="return-value"><a href="#return-value">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li><code>True</code> or <code>False</code></li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-create_cell"><a href="#comp-standardcomponent-component-create_cell">comp.StandardComponent.component.create_cell()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-2"><a href="#name-2">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>create_cell</strong> — create cell for component</li>
</ul>
</div>
<h4 id="synopsis-2"><a href="#synopsis-2">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>create_cell(self)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-2"><a href="#description-2">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Returns cell creation status for component. The default behavior depends on the <code>automatic_cell_partition</code> attribute in the <code>sim</code> object and if the component is a top-level component.</li>
</ul>
</div>
<h4 id="return-value-2"><a href="#return-value-2">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li>Returns <code>True</code> if automatic cell partitioning is enabled and the component is a top-level component, otherwise it returns <code>False</code>.</li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-del_slot"><a href="#comp-standardcomponent-component-del_slot">comp.StandardComponent.component.del_slot()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-3"><a href="#name-3">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>del_slot</strong> — delete slot</li>
</ul>
</div>
<h4 id="synopsis-3"><a href="#synopsis-3">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>del_slot(self, slot)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-3"><a href="#description-3">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function deletes the dynamic slot named <em>slot</em>. The function returns <code>True</code> if it could remove the slot, otherwise it returns <code>False</code>.</li>
</ul>
</div>
<h4 id="return-value-3"><a href="#return-value-3">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li><code>True</code> or <code>False</code></li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-get_slot_objects"><a href="#comp-standardcomponent-component-get_slot_objects">comp.StandardComponent.component.get_slot_objects()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-4"><a href="#name-4">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>get_slot_objects</strong> — get slot objects</li>
</ul>
</div>
<h4 id="synopsis-4"><a href="#synopsis-4">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>get_slot_objects(self)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-4"><a href="#description-4">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function will return all objects in the static and dynamic slots.</li>
</ul>
</div>
<h4 id="return-value-4"><a href="#return-value-4">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li>list of objects</li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-get_slot_value"><a href="#comp-standardcomponent-component-get_slot_value">comp.StandardComponent.component.get_slot_value()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-5"><a href="#name-5">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>get_slot_value</strong> — get slot</li>
</ul>
</div>
<h4 id="synopsis-5"><a href="#synopsis-5">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>get_slot_value(self, slot)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-5"><a href="#description-5">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function will return the slot value for the slot named <em>slot</em>.</li>
</ul>
</div>
<h4 id="return-value-5"><a href="#return-value-5">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li>value in slot</li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-get_slots"><a href="#comp-standardcomponent-component-get_slots">comp.StandardComponent.component.get_slots()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-6"><a href="#name-6">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>get_slots</strong> — get slot dictionary</li>
</ul>
</div>
<h4 id="synopsis-6"><a href="#synopsis-6">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>get_slots(self)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-6"><a href="#description-6">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function will return all static and dynamic slots as a dictionary.</li>
</ul>
</div>
<h4 id="return-value-6"><a href="#return-value-6">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li>dictionary with all slots</li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-has_slot"><a href="#comp-standardcomponent-component-has_slot">comp.StandardComponent.component.has_slot()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-7"><a href="#name-7">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>has_slot</strong> — check if valid slot</li>
</ul>
</div>
<h4 id="synopsis-7"><a href="#synopsis-7">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>has_slot(self, slot)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-7"><a href="#description-7">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function returns <code>True</code> if there exists a static or dynamic slot named <em>slot</em> in the component, otherwise it returns <code>False</code>.</li>
</ul>
</div>
<h4 id="return-value-7"><a href="#return-value-7">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li><code>True</code> or <code>False</code></li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-post_instantiate"><a href="#comp-standardcomponent-component-post_instantiate">comp.StandardComponent.component.post_instantiate()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-8"><a href="#name-8">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>post_instantiate</strong> — post instantiation functionality</li>
</ul>
</div>
<h4 id="synopsis-8"><a href="#synopsis-8">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>post_instantiate(self)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-8"><a href="#description-8">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>
<p>The function will be called when the component has been instantiated.</p>
<p>The default behavior is to do nothing.</p>
</li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-pre_instantiate"><a href="#comp-standardcomponent-component-pre_instantiate">comp.StandardComponent.component.pre_instantiate()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-9"><a href="#name-9">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>pre_instantiate</strong> — instantiate component status</li>
</ul>
</div>
<h4 id="synopsis-9"><a href="#synopsis-9">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>pre_instantiate(self)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-9"><a href="#description-9">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Should return <code>True</code> if component is allowed to be instantiated, <code>False</code> otherwise. The default behavior is to return <code>TRUE</code>.</li>
</ul>
</div>
<h4 id="return-value-8"><a href="#return-value-8">RETURN VALUE</a></h4>
<div class="dl">
<ul>
<li><code>True</code></li>
</ul>
</div>
</article>
</section>
<section class="not-numbered">
<h3 id="comp-standardcomponent-component-set_slot_value"><a href="#comp-standardcomponent-component-set_slot_value">comp.StandardComponent.component.set_slot_value()</a></h3>
<article class="not-numbered not-in-toc">
<h4 id="name-10"><a href="#name-10">NAME</a></h4>
<div class="dl">
<ul>
<li><strong>set_slot_value</strong> — set slot</li>
</ul>
</div>
<h4 id="synopsis-10"><a href="#synopsis-10">SYNOPSIS</a></h4>
<div class="dl">
<ul>
<li>
<pre><code>set_slot_value(self, slot, val)
</code></pre>
</li>
</ul>
</div>
<h4 id="description-10"><a href="#description-10">DESCRIPTION</a></h4>
<div class="dl">
<ul>
<li>Standard implementation, see the <code>component</code> interface. The function sets the slot named <em>slot</em> to <em>val</em>.</li>
</ul>
</div>
</article>
</section>

<div class="chain">
<a href="memory-space.html">23 Memory Spaces</a>
<a href="adding-flash-to-a-system.html">25 Adding Flash to a System</a>
</div>