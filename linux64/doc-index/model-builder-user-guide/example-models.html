<!doctype html>
<head>
<meta charset="utf-8">
<title>10 Example Models</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="advanced-programming-with-dml.html">9 Advanced Programming with DML</a>
<a href="define-new-interface-type.html">11 Defining New Interface Types</a>
</div>
<div class="path">
<a href="index.html">Model Builder User's Guide</a>
&nbsp;/&nbsp;
<a href="part-device-modeling.html">II Device Modeling</a>
&nbsp;/&nbsp;</div>
<h1 id="example-models">10 <a href="#example-models">Example Models</a></h1>
<p>Three real device models are included in the Simics Base package; an AM79C960 (ISA) Ethernet controller, a DS12887 real-time clock and a DEC21140A (PCI) Ethernet controller. They contain full source code and some tests. You can use these models and tests as examples when developing your own device models. This chapter serves as an orientation about how those devices are modeled and shows how you can test them if you have access to the <code>Enterprise</code> machine or <code>Firststeps</code> for the DEC21140A.</p>
<p>Source packages also contain devices which can be used as examples. If you develop a different kind of model than the ones in Model Builder, you may find a device in one of the source packages a better example.</p>
<h2 id="am79c960">10.1 <a href="#am79c960">AM79C960</a></h2>
<p>AM79C960 was a rather common ISA Ethernet card, used mostly in PCs. It is a little dated now, but still serves as a good example of how to implement Ethernet.</p>
<p>The workable source code for the sample device can also be found in the directory <code>[simics]/src/devices/AM79C960</code>. If you want to try modifying the <code>AM79C960</code> module yourself, we recommend that you set up a user project and copy the source code there, as described in section <a class="reference" href="build-environment.html#adding-modules-to-a-project">3.4</a>.</p>
<p>Please do read previous sections in part <a class="reference" href="part-device-modeling.html">II</a> to know how to compose and build an empty device, and we will ignore those general parts in this section and highlight the methodologies for how to efficiently model a specific device.</p>
<p>Typical work flow for Simics modeling includes below four stages:</p>
<ul>
<li>Modeling materials preparation </li>
<li>Architecture design </li>
<li>Detailed design </li>
<li>Test and continuous integration </li>
</ul>
<p>As the first stage, modeling materials preparation should be done before the modeling of the device, the necessary materials include hardware spec, target OS driver, and test applications, and optional software manuals. Hardware spec is the most important document, it also serves as the root spec of the model and the bridge between modeling team and the software team. Do make sure you get the right version of them.</p>
<p>We will elaborate the other three stages by tearing down the modeling methdology of an AM79C960 device.</p>
<h3 id="architecture-design">10.1.1 <a href="#architecture-design">Architecture Design</a></h3>
<p>There is always a system block diagram in the hardware spec, which perfectly shows the system level functional blocks, AM79C960 does as well, it has even two: one is bus master mode and the other is shared memory mode, there are some difference on ISA bus interface unit, since Simics will not simulate the details of a bus arbitration, we could regard them as one in the modeling.</p>
<p>From the diagram we know that AM79C960 has the major functional blocks like ISA/EISA bus, IEEE 802.3 Ethernet port, transmit and receive FIFOs, etc. It receives frames from ISA bus and sends them to Ethernet port, and vice versa. Our model should focus on those data handling, implement the actions the software calls for the device.</p>
<p>As Simics is a functional simulator, we need not model details how the device works internally, for example, the Ethernet PHY block actually has line encoder/decoder (MENDEC), frame preamble detector, etc. sub functional modules, yet they are not visible to the software, so we will hide those details and handle the data octets directly.</p>
<p>Simics itself is built up by several fundentmental modules, we also suggest the user to divide the complex device module into several sub modules and develop them separately. In each simple module, user always can utilize provided well-defined Simics libraries and templates to facilitate the design, and through interfaces, each module can be connected with each other efficiently.</p>
<p>It's a good practice to try to reuse existing modules and build modular system. The <code>AM79C960</code> module simplified the design and implemented all functionalities in one module for it's simple enough, while if you're modeling a more complex Ethernet controller, it's better at least divide it into PHY and MAC modules, then you could reuse <code>generic_eth_phy</code> module and get some helpful references from the implementation of <code>ich10_lan_v2</code> module, avoid duplicating the common PHY and MAC functionalities, and could be able to improve them separately and facilitate their debugging.</p>
<p>Once the sub modules are defined, we should then begin the interfaces design. In Simics, interface is the primary way to transfer data between modules, see section <a class="reference" href="programming-with-dml.html#interfaces">5.5</a> for more details.</p>
<h3 id="interfaces-design">10.1.2 <a href="#interfaces-design">Interfaces Design</a></h3>
<p>According to the device block diagram, there are several interfaces, means connections to outside of the module, should be includes in this model:</p>
<ul>
<li>Outging ethernet link </li>
<li>Incoming ethernet link </li>
<li>Interrupt to CPU </li>
<li>ISA bus memory space </li>
<li>LED output, resets input, etc. misc ports </li>
</ul>
<p>The outgoing Ethernet link could be implemented as:</p>
<p>
</p><pre><code>connect link {
    param documentation = "The ethernet-link the device is connected to.";
    interface ethernet_common;
}
</code></pre>
<p></p>
<p>The incoming Ethernet link could be implemented as:</p>
<p>
</p><pre><code>implement ethernet_common {
    method frame(const frags_t *frame, eth_frame_crc_status_t crc_status) {
        receive_packet(frame);
    }
}
</code></pre>
<p></p>
<p>When another device is trying to send data to this device, the interface method <code>frame</code> is called, the user is expected to handle the incoming data within the method.</p>
<p>Interrupt is a very common interface for the device to inform some internal events, ex. one frame is received or transmitted, error condition is detected, etc., we can use <code>simple_interrupt</code> interface to do that: </p>
<p>
</p><pre><code>connect irq_dev {
    param documentation = "The device that interrupts are sent to.";
    param configuration = "required";

    interface simple_interrupt;
}
</code></pre>
<p></p>
<div class="note">
<p>The <code>simple_interrupt</code> interface is deprecated, user should use <code>signal</code> interface in the new design.</p>
</div>
<p>To record current level of interrupt line and avoid to raise or lower the interrupt line twice, we need an attribute somewhat like <code>irq_raised</code>. This is also one suggested design practice in Simics to support checkpointing, when Simics restores the running from a checkpoint, the current runtime interrupt status should be correctly restored as well, this is supported by utilizing an attribute, whose value will be automatically saved and restored when the checkpoint is written and read.</p>
<p>To support DMA and share memory with the target CPU, we use <code>memory_space</code> interface to simulate the bus master function. Through this interface, the device is able to access the initialization data and Ethernet descriptor rings which are mapped on the system bus: </p>
<pre><code>connect memory {
    param documentation = "The memory space the device uses to access the "
        + "initialization data and descriptor rings";
    param configuration = required;
    interface memory_space;
}
</code></pre>
<p>AM79C960 supports both shared memory operations mode and bus master mode. In the first mode, AM79C960 is visible as one shared memory space to the master CPU, all registers are mapped on the memory space. In the second mode, AM79C960 has the ability to perform DMA operation, access data from system bus directly. In Simics, there needs no special design for DMA controller, the device can use interface call to access the memory space at any time.</p>
<p>ISA bus logically is seen as an range of linear address memory space from the viewpoint of software, but there is no need to implement bus details, for example, bus arbitration, IOR/IOW signals, etc., instead, we implement this bus functionality as a register bank. DML <code>bank</code> implicitly implements the <code>io_memory</code> interface to make it accessible from the CPU, so the user needs only declare the registers offset, name, size etc. parameters, and focus on its registers logic design, which in many cases is the most important and time-consuming part in a device modeling.</p>
<p>Don't forget to check the interfaces configuration, some of them are optional and may be left unconnected during initialization or even all the runtime. So, in case the interface is optional, user needs to check the connection before calling its methods, just like what <code>AM79C960</code> module does in <code>send_packet()</code> method: </p>
<pre><code>method send_packet() {
    local physical_address_t txd_addr;
    // ... other preparation statements
    if (link.obj != NULL) {
        // ... prepare frame buffer
        link.ethernet_common.frame(&amp;frame, Eth_CRC_Match);
    } else {
        log info, 2: "not connected, not packet sent";
    }
    // ... post handling of sending
}
</code></pre>
<h3 id="registers-design">10.1.3 <a href="#registers-design">Registers Design</a></h3>
<p>Most of the device logics are triggered by register accessing, we could design those logics into the registers' side effect or some global functions. It's a good style to design (declare) the registers bank in one place and implement them at another place, it makes the implementation clear.</p>
<p>Let's take mac_address as an example, it's a primary attribute for an Ethernet controller. The mac_address locates at I/O registers address 0 ~ 5, which are set by the CPU. By utilizing <code>attr_accessor</code> template, any writing to register aprom_0 ~ aprom_5 is also updating the mac_address attribute, which is then be used to check destination address when a frame is received.</p>
<p>Another example is the package transmitting, which is triggered by CSR0 writing. This occurs when the driver prepared the data to be transmitted, configured the descriptor ring accordingly, and then writes the CSR0 to start transmitting. To implement this behavior, we add side effect to the CSR0 writing: </p>
<p>
</p><pre><code>    register csr0 {
        // will csr0.init() after csr0 written?
        session uint1 do_init;
        // will csr0.start() after csr0 written?
        session uint1 do_start;
        // will csr0.transmit_demand() after csr0 written?
        session uint1 do_transmit_demand;

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            if (do_init == 1) {
                do_init = 0;
                initialize();
            }
            if (do_start == 1) {
                do_start = 0;
                start();
            }
            if (do_transmit_demand == 1) {
                do_transmit_demand = 0;
                transmit_demand();
            }
        }
</code></pre>

<pre><code>        field TDMD  @ [3] "Transmit Demand" {
            is write;
            method write(uint64 value) {
                if (value == 1) {
                    this.val = 1;
                    do_transmit_demand = 1;
                }
                // ignore write 0; cleared by send_packet()
            }
        }
</code></pre>
<p></p>
<p>We update the demand bit when writing, as well as other bits in case more than one bits are written, then check the demand bit after writing. It's better to implement the packet sending outside of the register definition, for it could be quite complex.</p>
<p>From related register bits definition and explanation of descriptor ring buffer management, we can conclude below procedure when transmitting one packet frame (Refer to <code>send_packet()</code> method for the implementation):</p>
<ol>
<li>Check if the previous transmitting is finished, quit immediately if it was not, the new transmitting will be scheduled by the event queue. </li>
<li>Clear the TDMD flag, to let other blocks and software know the status. </li>
<li>Read the transmit descriptor, which should have been prepared by the driver. </li>
<li>Check if it is connected to a link, it may be left unconnected. </li>
<li>If it's connected, read the actual frame data and send them by calling the interface method. </li>
<li>Update the registers and write back the transmit descriptor. </li>
<li>Check if the event queue has pending packets to be sent. </li>
</ol>
<p>Let's also take a look at receiving a packet, this occurs when external device call the <code>ethernet_common</code> interface method (Refer to <code>receive_packet()</code> method for the implementation):</p>
<ol>
<li>Buffer the incoming frame. </li>
<li>Check RXON to see if the device is ready to receive. </li>
<li>Read the receive descriptor and check related length. </li>
<li>Check the MAC address to determine whether the device should handle this packet. </li>
<li>If yes, write the frame data to the receive buffer. </li>
<li>Update related flags and raise interrupt to inform the driver to read. </li>
</ol>
<p>The descriptor ring used by transmitting and receiving block is a very common data structure for the Ethernet controller, let's take a look at the transmit descriptor ring implementation in this device as an example. </p>
<p>
</p><pre><code>typedef struct {
    physical_address_t addr;
    uint1 OWN;
    uint1 STP;
    uint1 ENP;
    uint16 size;
} txd_t;

method txd_from_buf(uint8* buf) -&gt; (txd_t) {
    local txd_t txd;
    txd.addr = buf[0] | buf[1] &lt;&lt; 8 | buf[2] &lt;&lt; 16;
    txd.OWN = buf[3][7];
    txd.STP = buf[3][1];
    txd.ENP = buf[3][0];
    txd.size = - (buf[4] | buf[5] &lt;&lt; 8);
    return txd;
}

method txd_to_buf(txd_t txd, uint8* buf) {
    local int neg_size = - txd.size;
    buf[0] = txd.addr[7:0];
    buf[1] = txd.addr[15:8];
    buf[2] = txd.addr[23:16];
    buf[3] = (txd.OWN &lt;&lt; 7) | (txd.STP &lt;&lt; 1) | (txd.ENP &lt;&lt; 0);
    buf[4] = neg_size[7:0];
    buf[5] = neg_size[15:8];
    buf[6] = 0;
    buf[7] = 0;
}
</code></pre>
<p></p>
<p>The descriptor ring buffer is built up by numbers of descriptors, each descriptor entry has the same 8 bytes structure, when reading out one transmit descriptor, <code>AM79C960</code> module extracts its inner data and assigns them to a <code>txd_t</code> type value, for later on convenient access. At writing back, the value is mapped back to the buffer data structure accordingly.</p>
<p>Indexing of the descriptor ring buffer is somewhat tricky,
it originally locates at the transmit ring counter register at CSR74, yet this
device uses an attribute <code>curr_txd</code> to simulate its behavior,
it works well from the software point of view and is quite simple to be
implemented:</p>
<p>
</p><pre><code>attribute curr_txd is uint64_attr {
    param documentation = "Index of the current transmit descriptor";
    param configuration = "optional";
    method addr() -&gt; (physical_address_t) {
        return xmt_descr_tbl_addr.val + (this.val * TXD_SIZE);
    }
    method next() {
        this.val = (this.val + 1) % xmt_descr_tbl_length.val;
    }
}
</code></pre>
<p></p>
<p>The <code>AM79C960</code> model is far from complete, it implements just enough functionalities that the device can be used with Linux 2.4. There always are too many registers to be implemented, in practice, we only implement the smallest set of registers required for the software to work
correctly, and leave those not necessary as unimplemented
(could use <code>unimpl</code> type logging to record).
This completeness could be verified by target software, so when
the software is upgraded, the model probably will have to be updated as well.</p>
<h3 id="other-elements-design">10.1.4 <a href="#other-elements-design">Other Elements Design</a></h3>
<p>Attributes are also widely used in Simics to record internal state or be exposed to user for configuration and debugging, for example, the 64-bit <code>Logical Address Filter</code> that resides in CSR8 - CSR11 is stored in the <code>logical_address_filter</code> attribute. Some of the registers, for example, CSR24 and CSR25 that contain <code>Base Address of Receive Ring</code>, are not even implemented and the values are only stored in separate attributes.</p>
<p>Another example is <code>poll_interval</code>, it originally locates in CSR47, but we could use an attribute to simply the implementation, while keep the ability to configure that at runtime.</p>
<p>In case the device needs some asynchronous handling, such as deferred transmitting process, Simics provides <code>event</code> to support this behavior: </p>
<pre><code>event poll_txd is simple_time_event {
    method event() {
        send_packet();
        poll_txd.post(poll_interval.val);
    }
}
</code></pre>
<p>This event periodically polls the transmit descriptor ring buffer, if there are any descriptors previously pending to be transmitted, they'll be checked again by the event handler. The polling is then rescheduled for the next round.</p>
<p>There is no need to design the event in receiving block, every time the packet is received, it can be handled immediately.</p>
<p>Simics provides <code>template</code> to avoid duplicating the same codes, one good example for this common practice is <code>data_accessor</code>: </p>
<p>
</p><pre><code>template attr_accessor {
    param attr;
    param attr_msb;
    param attr_lsb;
    param ignore_write default false;
    param mac_register default false;

    method get() -&gt; (uint64) {
        return read();
    }
    method set(uint64 value) {
        write(value);
    }
    is read;
    method read() -&gt; (uint64) {
        return attr.val[attr_msb:attr_lsb];
    }
    is write;
    method write(uint64 value) {
        if (!ignore_write) {
            attr.val[attr_msb:attr_lsb] = value;
        }
    }
}
</code></pre>
<p></p>
<p>This template implements register default get/set and read/write behaviors, and the user could customize this kind of register by setting parameters accordingly. Remember that, the user can always find good templates from the <code>utility.dml</code> library and define their own templates as they like.</p>
<p>Any device needs some methods to be reset to known states. By instantiating
the <code>sreset</code> utility template, our Simics device will be provided with
soft_reset semantics, this reset will reset all banks and registers
recursively by default, unless those explicitly ignored:</p>
<p>
</p><pre><code>    // should be read/write accessible only when STOP is set
    register csr1 is sticky;

    // should be read/write accessible only when STOP is set
    register csr2 is sticky;
</code></pre>
<p></p>
<p>These use the utility template <tt>sticky</tt> which
overrides the default soft_reset behavior, and prevents them to be reset to the default value during soft reset.</p>
<p>In case there are some other elements are to be initialized, such as attributes, user can place them in <code>init()</code> or <code>post_init()</code> methods, see section <a class="reference" href="device-modeling-overview.html#attribute-initialization">4.2.7.3</a> for more details.</p>
<h3 id="run-the-am79c960-model-tests">10.1.5 <a href="#run-the-am79c960-model-tests">Run the AM79C960 model tests</a></h3>
<p>Functional tests and integration tests are both heavily used in Simics device modeling, normally functional tests locates at the <code>test</code> subdirectory in the device module, user could execute <code>make test</code> to perform them at any time. Integration tests are much more complex, user needs to connect devices and components in the Simics configuration and run the target OS, generally use target application to test the device models.</p>
<p><code>AM79C960</code> does not provide functional tests, so we will not explain that here. Yet if your distribution contains the simulated machine <em>enterprise</em>, you can find the Simics script <code>enterprise-common.simics</code> in the directory <code>[simics]/targets/440bx</code>. Let's see how to utilize this script to verify the functionalities of this model. This file creates an enterprise machine using the <code>AM79C960</code> module. The AM79C960 object is called <code>enterprise.motherboard.lance.lance</code>.</p>
<p>To do something interesting with the AM79C960 model it needs to be connected to something that it can talk to. The default setup for the enterprise system has the AM79C960 controller connected to a <code>service-node</code> via an Ethernet switch.</p>
<p>Start the simulation and let the machine boot and login as the user <code>root</code>. No password is required. Stop the simulation and set the log level of the <code>lance</code> object to 2:</p>
<pre><code>simics&gt; enterprise.motherboard.lance.lance.log-level 2
[enterprise.motherboard.lance.lance] Changing log level: 1 -&gt; 2
</code></pre>
<p>You can now start the simulation again and send a ping packet to the <code>service-node</code> by entering <code>ping -c 1 10.10.0.1</code> in the console on the simulated machine. The <code>lance</code> object will log what happens:</p>
<pre><code>[enterprise.motherboard.lance.lance info] Packet sent, dst 20:20:20:20:20:00, src 10:10:10:10:10:30, length 102 bytes
[enterprise.motherboard.lance.lance info] packet received, dst 10:10:10:10:10:30, src 20:20:20:20:20:00, length 102 bytes
[enterprise.motherboard.lance.lance info] MAC address matches, packet accepted
</code></pre>
<p>The enterprise machines sends a 102-byte packet to the <code>service-node</code> and receives a 102-byte reply. These are the actual ping request and ping reply.</p>
<p>If you want more detailed logs you can change the log level to 3 or 4. At log level 3 a lot more information about what is going on in the device will be logged. The device polls for packets to transmit regularly, so this will cause a lot of output. At log level 4 all accesses that the processor does to the device will also be logged.</p>
<p>By the test applications we make sure the basic transmitting and receiving work well and the driver can access the device as expected. As a good practice, we should document those key unimplemented features as limitations at the top of the model, just like <code>AM79C960</code> module does: </p>
<pre><code>param limitations = ("&lt;ul&gt;"
    + "..."
    + "&lt;li&gt;The ISA bus configuration registers are not implemented&lt;/li&gt;"
    + "..."
    + "&lt;/ul&gt;");
</code></pre>
<p>In case new features are required, we could define the new test scenarios and develop that add-on features based on this ready model, continuously improve the model's completeness.</p>
<h2 id="ds12887">10.2 <a href="#ds12887">DS12887</a></h2>
<p>DS12887 is a very common real-time clock device. It is used, among other places, in common PCs. There are also many other devices that are extensions of the DS12887, for example, DS17485 and M5823.</p>
<p>It may be good to have the documentation for the DS12887 chip when looking at the sample code, so that you can compare the code to the specification. The documentation can be found on the Internet, search for <code>ds12887.pdf</code> on <code>www.google.com</code> and you will find several links to it.</p>
<p>The source code for the sample device can be found in the directory <code>[simics]/src/devices/DS12887</code>. If you want to try modifying the DS12887 yourself, we recommend that you set up a user project and copy the source code there, as described in section <a class="reference" href="build-environment.html#adding-modules-to-a-project">3.4</a>.</p>
<p>The source code of the DS12887 module is quite richly commented, so if you have the documentation for the DS12887 chip you should hopefully be able to understand most of the code without too much problem.</p>
<h3 id="architecture-design-2">10.2.1 <a href="#architecture-design-2">Architecture Design</a></h3>
<p>Refer to the address map of DS12887 from the spec, the major function blocks of the DS12887 block diagram is clearly the calendar and alarm ram (block "CLOCK, CALENDAR, AND ALARM RAM") and the control registers (block "REGISTERS A,B,C,D"). The output signals of this model are also simple, the main output signal is the interrupt (signal "IRQ"). We can abstract DS12887 with a real time clock device, it increases its internal time counter per second. The date and time are stored in registers. Alarm interrupts can be controlled by registers if clock match the values in alarm registers. As Simics is a functional simulator, we do not need to exactly model such details. Instead we design an attribute <code>base_rtc_time</code> to store absolute time, so that we only update RTC time when time registers are really accessed. Also when registers are accessed we compute and schedule the alarm interrupt rather than compare and decide if the alarm interrupt needs to be triggered. This is also known as common practice to improve the simulation performance.</p>
<h3 id="registers-design-2">10.2.2 <a href="#registers-design-2">Registers Design</a></h3>
<p>As registers are the main function blocks of DS12887. Firstly we write the layout of the register banks. The address and size of registers can be found in the documentation.</p>
<pre><code>bank registers is function_mapped_bank {
    param register_size = 1;
    param function = 1;

    register seconds            @ 0;
    ...
    register nvram[i &lt; 114]  @ 14 + i;
}
</code></pre>
<p>As we introduced previously, we implement the model to update the time registers "lazily". The handling logic looks more complicated than absolutely necessary, but does help simulation performance. A simple implementation could post an event that raises the <code>UIP</code> flag and then an event that lowers the <code>UIP</code> flag, updates the time registers and compares them with the alarm registers each simulated second. Such simple implementation actually would lead to many regular Simics events just for idle loop, in case if the time registers and alarm registers are not really accessed. To avoid having to frequently post these events, the model instead saves the simulated time that the real-time clock time was last set, and the time it was set to. From this information the current real-time clock time can be calculated at any time, and the time registers are only updated when they are read. We actually develop template <code>time_register</code> to include such time updating methods as <code>update_time_registers_conditional()</code> and <code>writeback_time_registers()</code> so time registers can adopt such functionalities. There is a comment above the <code>base_time</code> attribute in the source code that describes more detailedly about the time representation.</p>
<p>Similarly, events for the alarm interrupt, periodic interrupt and update-ended interrupt are only posted if the corresponding interrupt flag is not already raised. We also develop template <code>interrupt_event</code> to implement such interrupt scheduling functionalities, mostly by the <code>update_time()</code> method in it. The interrupt related registers or register fields, for example, the alarm registers, can adopt the template. This implementation means that, if Linux does not use the device after the boot, as we generally observed in our simulated scenarios, the model will have good simulation performance since it does not need to post any more events once Linux has booted.</p>
<p>DS12887 spec well describes the control registers. The 3 DV bits in register <code>a</code> enable the oscillator and interrupt posting. The 4 rate-selection bits decide how to generates the periodic interrupt. Register <code>b</code> include the interrupt enable bits, and the interrupt flag bits are in register <code>c</code>. To better maintain such interrupt functionalities we implement common method update_IRQF() to check, update those fields, and raise or lower the interrupt. This is also a common practice eventually seen in interrupt processing of every DML devices. Interrupt related events and register fields can do individual update, then call the common method to sync the interrupt state, without spreading similar or even inconsistent code in different DML code pieces.</p>
<p>A difference between the documentation of the DS12887 and the model is that the model has three register banks, while the documentation only describes one. This is because of the way the device is used in PCs. The registers described in the documentation correspond to the <code>registers</code> bank. When the device is used in a PC a small translation device with two registers that forwards accesses to the registers of the DS12887 is mapped in the port space. This translation device corresponds to the <code>port_registers</code> bank. In addition we define a bank
<code>partially_persistent_registers</code> which serves as persistent backing
storage for registers where not all fields are persistent. See the section 7.2
of the second chapter of the <em>Simics User's Guide</em> and the
<em>DML 1.4 Reference Manual</em> for details. If you want to use the model as a
pure DS12887, just ignore the <code>port_registers</code> bank.</p>
<h3 id="interfaces-design-2">10.2.3 <a href="#interfaces-design-2">Interfaces Design</a></h3>
<p>According to the functions described in the spec, there are several interfaces should be included in this model:</p>
<ul>
<li>Interrupt output </li>
<li>Reset signal </li>
<li>Clock </li>
</ul>
<p>We can use the interrupt interface <code>simple_interrupt</code> to really trigger the interrupt from DS12887 internal events:</p>
<p>
</p><pre><code>connect irq_dev {
    param documentation = "The device that interrupts are sent to,"
        + " or Nil if the interrupt line is not connected to anything.";
    param configuration = "optional";

    interface simple_interrupt;
}
</code></pre>
<p></p>
<div class="note">
<p>The <code>simple_interrupt</code> is obsoleted by the <code>signal</code> interface.</p>
</div>
<p>We connect to an outside timer to get the current virtual time. We need it to calculate the real time.</p>
<p>
</p><pre><code>    local conf_object_t *clock = SIM_object_clock(dev.obj);
    if (clock == NULL) {
        log error: "device does not have a time queue/clock";
    } else {
        SIM_require_object(clock);
    }
</code></pre>
<p></p>
<p>One amazing capacity of Simics environment is checkpointing and reverse execution. So Simics environment might automatically store or restore DS12887 states to or from a Simics checkpoint. This actually leads to an extra step in Simics modeling to see if the model is checkpointing safe. For a Simics timer model as DS12887, reschedule its time events or time interrupts after restore is generally needed. Aware of that, we also implement the <code>temporal_state</code> interface of such computing and rescheduling.</p>
<h3 id="other-elements-design-2">10.2.4 <a href="#other-elements-design-2">Other Elements Design</a></h3>
<p>We mainly picked alarm interrupts as interrupt example in previous sections. Actually DS12887 also support periodic interrupts and update-ended interrupts. The implementing experience of alarm interrupts can be easily used in other interrupts according to the details described in the spec.</p>
<p>Templates facilitate Simics model code consistency, debugging and device hierarchy. For example, we also implement template <code>rtc_register</code> to be used by all time and alarm registers, which contains methods for register value range checking and converting between BCD format and binary format. DML enables template parameters so that the template method just implement the value boundary checking logic and leave the boundary value setting to each individual registers. We also implement other templates as <code>hour_rtc_register</code>, <code>time_alarm_register</code>, <code>irq_flag</code>, <code>irq_enable_flag</code> accordingly.</p>
<p>There are some DS12887 hardware functionalities are not needed in Simics functional modeling. For example, we do not need the details of oscillator but just need to monitor if it is enabled or not, to trigger the interrupts, from the DV bits of register <code>a</code>. We do not implement the power switch because this is generally not needed in a functional simulation. We also do not implement the daylight saving time and square wave output functionalities since we do not observe software requiring it. We record such non-implemented functionalities with <code>limitations</code> parameter for future enhancement.</p>
<h3 id="running-the-ds12887-model">10.2.5 <a href="#running-the-ds12887-model">Running the DS12887 model</a></h3>
<p>If your distribution contains the simulated machine <em>enterprise</em>, you can find the Simics script <code>enterprise-common.simics</code> in the directory <code>[simics]/targets/440bx</code>. This file creates an enterprise machine using the <code>DS12887</code> module. The DS12887 object is called <code>rtc0</code>.</p>
<p>You can, for example, log what is happening to the device during the boot by setting the log level of the <code>rtc0</code> object to 3:</p>
<pre><code class="language-simics">simics&gt; <strong>rtc0.log-level 3</strong>
[rtc0] Changing log level: 1 -&gt; 3
simics&gt; <strong>c</strong>
[rtc0 info] Update-ended interrupt triggered, raising UF.
Pressing return
[rtc0 info] Periodic interrupt frequency set to 1024.000000 Hz.
[rtc0 info] Periodic interrupt triggered, raising PF.
[rtc0 info] UF lowered.
[rtc0 info] PF lowered.
[rtc0 info] UIE set.
[rtc0 info] Periodic interrupt triggered, raising PF.
[rtc0 info] Update-ended interrupt triggered, raising UF.
[rtc0 info] Raising interrupt.
[rtc0 info] UF lowered.
[rtc0 info] PF lowered.
[rtc0 info] Lowering interrupt.
[rtc0 info] UIE cleared.
[rtc0 info] Periodic interrupt triggered, raising PF.
[rtc0 info] Update-ended interrupt triggered, raising UF.
</code></pre>
<p>If you raise the log level to 4 all access the processor does to the device will be logged. The <code>rtc0</code> object is accessed a lot during the boot, so you probably do not want to run the entire boot with log level 4.</p>
<p>Note that Linux only uses the real-time clock while booting and shutting down. Once it has booted it uses other timers to keep the time, so to get Linux to access the D12887 again once it has booted, you have to reboot the system.</p>
<h2 id="dec21140a">10.3 <a href="#dec21140a">DEC21140A</a></h2>
<p>The DEC21140A is a PCI Ethernet card. As the AM79C960, it is obsolete today but it provides a good example of a PCI device written in DML. Its specification can be found on the Internet, for example by looking for <code>ec-qn7nc-te.ps.gz</code> with Google.</p>
<p>The source code for the sample device can be found in the directory <code>[simics]/src/devices/DEC21140A-dml</code>. If you want to modify the <code>DEC21140A-dml</code> module yourself, we recommend that you set up a user project and copy the source code there, as described in section <a class="reference" href="build-environment.html#adding-modules-to-a-project">3.4</a>.</p>
<h3 id="architecture-design-3">10.3.1 <a href="#architecture-design-3">Architecture Design</a></h3>
<p>Module <code>DEC21140A-dml</code> is a DML-implemented DEC21140A device, the <code>-dml</code> suffix is to differentiate with the old C-implemented one. The <code>DEC21140A-dml</code> implementation is more readable and modern by utilizing DML powerful modeling features, for example, by importing Simics PCI library, the PCI bus implementation is pretty simple and the latest PCI bus features are well supported.</p>
<p>Both AM79C960 and DEC21140 are Ethernet controllers, they have many common parts in Ethernet functionalities, for example, descriptors list (or ring), frame transmit and receive handling, etc., the biggest difference is that, AM79C960 uses ISA bus, yet DEC21140A uses PCI bus to connect to the host.</p>
<p>Another point that should be highlighted here is that, module <code>DEC21140A-dml</code> does not implement the PHY layer functionalities itself, instead, it reuses <code>generic_eth_phy</code> when building the Simics component, this kinds of design practics is highly recommended in Simics modeling.</p>
<p>With the help of PCI standard library and reusing existing PHY module, there are only few necessary device specific implementations to be done, including device status transaction, MAC layer packets handling, interrupt reporting, etc..</p>
<p>For better readability, the source code has been divided into two files: </p>
<div class="dl">
<ul>
<li><span class="term" id="dt:dec21140a-dml"><code>DEC21140A.dml</code></span><br>
This file contains the register bank definitions for the PCI configuration, device interfaces and the CSR registers. </li>
<li><span class="term" id="dt:dec21140a-eth-dml"><code>DEC21140A-eth.dml</code></span><br>
This file contains code to handle the network and Ethernet frames, mainly concerning the <code>transmit()</code> and <code>receive()</code> methods.</li>
</ul>
</div>
<p>The two files also indicate the two key parts for this device in modeling, the host connections which includes PCI bus and CSR registers, and the Ethernet connection.</p>
<p>Similar with other Simics modules, the <code>DEC21140A-dml</code> module is far from complete, it implements just enough functionalities that the device model can be used with Linux.</p>
<h3 id="interfaces-design-3">10.3.2 <a href="#interfaces-design-3">Interfaces Design</a></h3>
<p>As described in the specification, the DEC21140A and the host driver communicate through two data structures: control and status registers (CSRs), descriptor lists and data buffers.</p>
<p>CSR registers are implemented in a Simics bank, its base address will be assigned by BIOS through PCI configuration space BAR register when booting the system. The descriptors lists locate in the host memory and are composed by pointers to the host memory, the <code>DEC21140A-dml</code> module reads and writes those descriptors and the real data through DMA function of the PCI bus.</p>
<p>With the help of Simics PCI library (by importing the file <code>pci/common.dml</code>), module <code>DEC21140A-dml</code> only needs to fill the necessary fields in the PCI configuration space to implement the PCI bus, such as vendor_id, device_id, BARs, etc..</p>
<p>For more info about how to model a PCI device in general, please refer to the Technology Guide "PCIe Modeling Library"</p>
<p>Ethernet connection is implemented by below interfaces:</p>
<ul>
<li><code>ieee_802_3_phy_v2</code>, connect to the outside PHY module, for example, a <code>generic_eth_phy</code> module. </li>
<li>Implementation of <code>ieee_802_3_mac</code> and <code>ieee_802_3_mac_v3</code>, to be connected as a MAC module. </li>
<li><code>mii_management</code> to allow software to communicate with the PHY. </li>
</ul>
<p>Interface <code>microwire</code> is to connect to a serial EEPROM, where some customizable data, ex. MAC address, are stored in.</p>
<h3 id="registers-design-3">10.3.3 <a href="#registers-design-3">Registers Design</a></h3>
<p>As a good practice, the CSR bank declares those registers and only implements small logic size registers in original place, all others logics, ex. interrupting and Ethernet frame transferring, are put to another place.</p>
<div class="note">
<p>The CSR registers should be designed in the bank which <code>function</code> number is equal to the <code>map_func</code> assigned in PCI config bank <code>pci_config</code> BARs, so the CSR bank can be accessed by the software through PCI bus.</p>
</div>
<p>Register CSR0 contains the bus mode configuration, but at normal condition, we need not implement them, so leave most of them as dummy bits, for example the software reset, it's just logged without any real actions, this is good enough for the device module to work in the target linux version.</p>
<p>To avoid duplicating the same kind of register behavior, ex. checking device status before any writes to the register, three templates are designed, named as <code>rw_tx_stopped</code>, <code>rw_rx_stopped</code> and <code>rw_rx_tx_stopped</code>, this kind of design pattern is suggested in Simics modeling. For example: </p>
<pre><code>template rw_tx_stopped {
    is write;
    method write(uint64 value) {
        if (csr.csr5.ts.val != TX_STOPPED &amp;&amp; value != this.val)
            log spec_viol, 3:
                "writing 0x%x to the %s.%s.%s field with running Tx process",
                value, bank.name, reg.name, this.name;
        this.val = value;
    }
}
</code></pre>
<p>There are two registers that are implemented as unmapped registers, <code>current_rx_address</code> and <code>current_tx_address</code>, they are updated every time the CSR3 and CSR4 registers are written separately, and updated accordingly when the descriptors are processed. By doing like this, those two registers are kept as internal variables and not able to be accessed from the software directly, yet they are still automatically checkpointed by Simics and can be accessed by fields, like an ordinary register does.</p>
<h3 id="other-elements-design-3">10.3.4 <a href="#other-elements-design-3">Other Elements Design</a></h3>
<p>Interrupt reporting usually needs some pre-checking for the current level, mask bits setting, enablement, etc. conditions, so in most cases we implement the interrupt raise and lower operation in a dedicated method, just like what <code>DEC21140A-dml</code> does to raise an interrupt bit: </p>
<pre><code>method raise_interrupt(int bit) {
    if (csr.csr5.itr.val[bit] == 0)
        log info, 4: "raise interrupt %d", bit;
    csr.csr5.itr.val[bit] = 1;
    update_interrupts();
}
method update_interrupts() {
    if ((csr.csr5.itr.val &amp; INT_ABNORMAL_MASK &amp; csr.csr7.itr_mask.val) != 0)
        csr.csr5.ais.val = 1 &amp; csr.csr7.ais_mask.val;
    else
        csr.csr5.ais.val = 0;
    if ((csr.csr5.itr.val &amp; INT_NORMAL_MASK &amp; csr.csr7.itr_mask.val) != 0)
        csr.csr5.nis.val = 1 &amp; csr.csr7.nis_mask.val;
    else
        csr.csr5.nis.val = 0;

    if ((csr.csr5.nis.val | csr.csr5.ais.val) != 0)
        pci_config.pci_raise_interrupt();
    else
        pci_config.pci_lower_interrupt();
}
</code></pre>
<h3 id="run-the-dec21140a-dml-module">10.3.5 <a href="#run-the-dec21140a-dml-module">Run the DEC21140A-dml Module</a></h3>
<p>In the QSP-x86 package you can find the script <code>qsp-linux-dec21140.simics</code> in the directory <code>[simics]/targets/qsp-x86</code>. This file creates a QSP-x86 based machine and attaches the DEC21140A-dml device to its PCI bus and the Ethernet link. It also detaches the internal network device of the QSP-x86 from the Ethernet link, so the DEC21140A is the only network device connected to the link.</p>
<p>Start the simulation and let the machine boot. Now you can see the network device and use it to ping the service node which is connected to the Ethernet link:</p>
<pre><code class="language-simics"># <strong>ifconfig eth0</strong>
eth0      Link encap:Ethernet  HWaddr 10:10:10:10:26
          inet addr:10.10.0.100  Bcast:10.10.0.255  Mask:255.255.255.0
          ...
# <strong>ping 10.10.0.1</strong>
PING 10.10.0.1 (10.10.0.1): 56(84) bytes of data.
64 bytes from 10.10.0.1: icmp_seq=1 ttl=31 time=0.063 ms
64 bytes from 10.10.0.1: icmp_seq=2 ttl=31 time=0.062 ms
64 bytes from 10.10.0.1: icmp_seq=3 ttl=31 time=0.063 ms
</code></pre>
<h2 id="ethernet-phy-chip">10.4 <a href="#ethernet-phy-chip">Ethernet PHY chip</a></h2>
<p>The previous section described how to use a DEC21140 device to communicate with an Ethernet network from <code>Firststeps</code> machine. In the setup, all Ethernet communication goes via a PHY chip, represented by the <code>generic_eth_phy</code> device. A PHY chip takes care of the physical layer of the Ethernet protocol; its primary task is to redirect traffic between a media access controller (MAC) device and an Ethernet network. The DEC21140A is one example of a MAC device; the Ethernet network is represented by an Ethernet link in Simics. Below interfaces are used to support those behaviors:</p>
<ul>
<li><code>ethernet_common</code>, connecting to the outside Ethernet PHY device, this interface can be left unconnected, but the outside Ethernet PHY device to be connected must implement the <code>ethernet_common</code> interface. </li>
<li>Optional <code>ethernet_cable</code>, to handle the link status of the peer. </li>
<li><code>ieee_802_3_mac</code> or <code>ieee_802_3_mac_v3</code>, connecting to the Ethernet MAC device, at least one of the two interfaces should be connected, if both are connected, only use the <code>ieee_802_3_mac_v3</code> interface. </li>
<li>Implementation of <code>ieee_802_3_phy</code>, <code>ieee_802_3_phy_v2</code> and <code>ieee_802_3_phy_v3</code>, to handle access from the Ethernet MAC device. All of the three interfaces have to be implemented simultaneously to support any of the possible interfaces call, yet internally they share the same implementation. </li>
</ul>
<p>The <code>generic_eth_phy</code> device can be configured by target software via the Media Independent Interface (MII), which in Simics is represented by the <code>mii_management</code> interface.</p>
<p>The source code of the <code>generic_eth_phy</code> module is sparsely commented but rather simple. Most of the relevant documentation can be found in the IEEE 802.3 standardâ€”in particular chapter 22, where the MII registers are specified.</p>
<p>The <code>generic_eth_phy</code> model is complete enough to be detected and configured correctly by most operating systems. Much of the configuration of a PHY controls which speed to use. The model ignores these settings; instead, the attribute <code>tx_bandwidth</code> can be used to manually configure the maximum transmission speed.</p>
<p>The PHY functionality has been divided between two files:</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:ieee_phy-dml"><code>ieee_phy.dml</code></span><br>
This file contains code to handle the network and redirect Ethernet frames. </li>
<li><span class="term" id="dt:ieee_mii_regs-dml"><code>ieee_mii_regs.dml</code></span><br>
This file handles run-time configuration, and contains the MII registers. </li>
</ul>
</div>
<p>These files cannot be used by themselves; they need to be imported by a DML file that defines the device. The files have some additional requirements, which are documented in comments. The file <code>generic_eth_phy.dml</code> combines the two DML files into the <code>generic_eth_phy</code> device.</p>
<p>This model provides some functional tests in <code>test</code> sub-directory, which are helpful to verify the functionalities implementation, each test, as we suggest, only tests one functionality and is named on its testing purpose. For more details about how to write tests, please refer to chapter <a class="reference" href="writing-model-tests.html">16</a>.</p>

<div class="chain">
<a href="advanced-programming-with-dml.html">9 Advanced Programming with DML</a>
<a href="define-new-interface-type.html">11 Defining New Interface Types</a>
</div>