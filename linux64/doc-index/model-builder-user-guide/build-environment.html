<!doctype html>
<head>
<meta charset="utf-8">
<title>3 Build Environment</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="modeling-techniques.html">2 Modeling Techniques</a>
<a href="part-device-modeling.html">II Device Modeling</a>
</div>
<div class="path">
<a href="index.html">Model Builder User's Guide</a>
&nbsp;/&nbsp;
<a href="introduction-and-preparation.html">I Introduction and Preparation</a>
&nbsp;/&nbsp;</div>
<h1 id="build-environment">3 <a href="#build-environment">Build Environment</a></h1>
<p>The functionality of Simics can be extended by user-written modules. Modules can, among other things, contain new device models, new commands, new components, and new extension to Simics. All of need to be compiled or built to be used in simulation and the environment in which that is done is referred to as the build environment.</p>
<p>This chapter will describe how to configure, maintain and use that environment to build new modules for use with Simics. A project is used to contain and build user-written modules, this permits many users to share a system-wide (read-only) Simics installation. The <em>Model Builder</em> product contains the necessary files and tools to develop your own modules.</p>
<h2 id="notes-for-windows-users">3.1 <a href="#notes-for-windows-users">Notes for Windows Users</a></h2>
<p>To develop new modules for Simics on the Windows platform, you need the MinGW compiler suite and make tools installed. See the <em>Simics Installation Guide</em> for more information.</p>
<p>If you do not wish to use the GCC compiler, you can use the Microsoft Visual C++ compiler to compile C++ modules (n.b., the Visual C++ compiler is not supported for C modules). See section <a class="reference" href="#platform-specific-notes">3.5.2</a> for more information.</p>
<p>The commands below should be invoked in a <code>cmd.exe</code> command prompt window, and the path names should be entered with backslashes as directory separators, and <code>bin\make.bat</code> (a shortcut to the MinGW installation) should be used when instructed to run <code>make</code>.</p>
<h2 id="notes-for-linux-users">3.2 <a href="#notes-for-linux-users">Notes for Linux Users</a></h2>
<p>On Linux, the project makefiles require GNU make (a.k.a. <code>gmake</code>), which is available from <code>ftp.gnu.org/gnu/make</code>. In the following text, when you are asked to run <code>gmake</code>, this refers to running the GNU make binary, which may be called <code>gmake</code> or <code>make</code>, depending on your installation.</p>
<p>Simics supplies own version of libraries, for example libstdc++.so.6, under [simics-base]/[host]/sys/lib/ directory. They are actually for machines with older libraries or none at all. If user has a more recent copy than one supplied with Simics, error like "GLIBCXX... not found" would happen when try to run a binary or load a module compiled from this newer library from within Simics. If this happens the suggested workaround is to remove the older library supplied with Simics.</p>
<h2 id="setting-up-a-project">3.3 <a href="#setting-up-a-project">Setting up a Project</a></h2>
<p>A project is a directory which contains all necessary user-specific files needed to run Simics and develop modules. Setting up a project is done with the <strong>File → Create Project…</strong> or using the <code>project-setup</code> script, like this:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows">Windows</span></p>
<pre><code>&gt; [simics]\bin\project-setup.bat my-simics-project
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux">Linux</span></p>
<pre><code>$ [simics]/bin/project-setup my-simics-project
</code></pre>
</li>
</ul>
</div>
<p>where <em>[simics]</em> is the location of the Simics-installation.</p>
<p>The script will create a project directory with the following contents:</p>
<table><thead><tr><th><code>bin/</code></th><th><code>compiler.mk</code></th><th><code>config.mk</code></th></tr></thead><tbody>
<tr><td><code>doc/</code></td><td><code>GNUmakefile</code></td><td><code>modules/</code></td></tr>
<tr><td><code>.project-properties</code></td><td><code>simics</code></td><td><code>simics-eclipse</code></td></tr>
<tr><td><code>simics-gui</code></td><td><code>targets/</code></td><td><code>host/</code></td></tr>
</tbody></table>
<div class="dl">
<ul>
<li><span class="term" id="dt:simics"><code>simics</code></span><br>
Starts Simics in command line mode. </li>
<li><span class="term" id="dt:simics-gui"><code>simics-gui</code></span><br>
Starts Simics in GUI mode. </li>
<li><span class="term" id="dt:bin"><code>bin/</code></span><br>
Directory with various other tools. </li>
<li><span class="term" id="dt:doc"><code>doc/</code></span><br>
On Linux a directory with links to documentation. On Windows the documentation can be found in the start menu.</li>
<li><span class="term" id="dt:gnumakefile"><code>GNUmakefile</code></span><br>
Makefile to build all modules under the <code>modules</code> directory. The file is called <code>GNUmakefile</code> to signify that it requires GNU make. Do not edit this file: you should probably create the <code>config-user.mk</code> or <code>module-user.mk</code> files to change the compilation parameters </li>
<li><span class="term" id="dt:compiler-mk"><code>compiler.mk</code></span><br>
Makefile that selects the C compiler to use by setting the <code>CC</code> variable. A matching C++ compiler will be searched for by <code>config.mk</code> in the same path as <code>CC</code> if <code>CXX</code> is not set. </li>
<li><span class="term" id="dt:config-mk"><code>config.mk</code></span><br>
Includes <code>[simics]/config/project/config.mk</code> that contains default definition of make flags for different compilers, such as <code>CFLAGS</code>. Do not edit this file: you should probably create the <code>config-user.mk</code> or <code>module-user.mk</code> files to change the compilation parameters </li>
<li><span class="term" id="dt:config-user-mk"><code>config-user.mk</code></span><br>
Optional file that may contain user defined make variables like <code>D</code> or <code>USER_BUILD_ID</code>. For information about <code>USER_BUILD_ID</code>, see chapter <a class="reference" href="checkpoint-compatibility.html">38</a>. </li>
<li><span class="term" id="dt:module-user-mk"><code>module-user.mk</code></span><br>
Optional file that may contain user defined make targets and variables overriding the ones in <code>config.mk</code> and <code>[simics]/config/project/module.mk</code>. </li>
<li><span class="term" id="dt:modules"><code>modules/</code></span><br>
Contains user-developed modules. The default target in <code>GNUmakefile</code> builds all modules in the <code>modules</code> directory. </li>
<li><span class="term" id="dt:targets"><code>targets/</code></span><br>
Contains some pre-configured machines, to be used as examples. </li>
<li><span class="term" id="dt:host"><em>&lt;host&gt;</em>/</span><br>
The build working directory, which is named after the host type, for example <code>linux64</code> or <code>win64</code>. The host directory is not present until a module has been compiled. When a module is compiled, any intermediate build files, like dependency and object files (<code>.d</code> <code>.o</code>) are generated in the <code>&lt;host&gt;/obj/modules/&lt;module&gt;/</code> directory. The resulting module file is placed in <code>&lt;host&gt;/lib/</code>, and the Python command file for the module is placed in the <code>&lt;host&gt;/lib/python/</code> directory.</li>
<li><span class="term" id="dt:project-properties"><code>.project-properties</code></span><br>
For internal use. </li>
</ul>
</div>
<p>When the project has been created, you may type <code>make</code> (or possibly <code>gmake</code>) to build all the modules, or <code>./simics-gui</code> to start Simics.</p>
<p>In order to rebuild all modules, type <code>make clean</code>, followed by <code>make</code>. In order to rebuild just a single module, type <code>make clean-modulename</code>, for example:</p>
<pre><code class="language-simics"> project$ <strong>make # builds all modules</strong>
 project$ <strong>make clean-mymodule # removes all objectfiles for "mymodule"</strong>
 project$ <strong>make mymodule # builds "mymodule"</strong>
</code></pre>
<p>The <code>clean</code> targets only remove object files and similar intermediates for the module not needed when running. To remove the actual module files as well, use <code>make clobber</code> or <code>make clobber-modulename</code>.</p>
<h3 id="project-setup-script-invocation">3.3.1 <a href="#project-setup-script-invocation">Project Setup Script Invocation</a></h3>
<p>The project setup script is used to <em>create</em> and <em>upgrade</em> projects. It can also create module skeletons to start with when writing new devices.</p>
<p>See <em>Simics Reference Manual</em> for the full documentation of the script.</p>
<h3 id="updating-projects">3.3.2 <a href="#updating-projects">Updating Projects</a></h3>
<p>To upgrade your project to a new Simics version, run the script again with no arguments. It is also possible to update the project from the Simics GUI. The project will then be updated to match the version of the running Simics.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows-2">Windows</span></p>
<pre><code class="language-simics">&gt; <strong>cd my-simics-project</strong>
&gt; <strong>[path-to-new-simics]\bin\project-setup.bat</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux-2">Linux</span></p>
<pre><code class="language-simics">$ <strong>cd my-simics-project</strong>
$ <strong>[path-to-new-simics]/bin/project-setup</strong>
</code></pre>
</li>
</ul>
</div>
<p>It will do the necessary updates in the project, but leave the user-modifiable files intact. (Modified files that need to be overwritten are saved in backup versions with the extension "<code>.~N~</code>" (Linux) or "<code>~N~.backup</code>" (Windows), where N is the first free number.)</p>
<p>If you upgrade to Simics with a different major version number, the compiled modules will not be compatible and you need to do a <code>make clobber</code> to force a rebuild when you issue <code>make</code>.</p>
<h2 id="adding-modules-to-a-project">3.4 <a href="#adding-modules-to-a-project">Adding Modules to a Project</a></h2>
<p>The <code>modules</code> subdirectory contains source code for modules, one module per directory entry.</p>
<h3 id="creating-a-new-dml-module">3.4.1 <a href="#creating-a-new-dml-module">Creating a New DML Module</a></h3>
<p>To add a DML module to a project, specify the <em>--device</em> option.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows-3">Windows</span></p>
<pre><code class="language-simics">&gt; <strong>cd my-simics-project</strong>
project&gt; <strong>bin\project-setup.bat --device mydevice</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux-3">Linux</span></p>
<pre><code class="language-simics">$ <strong>cd my-simics-project</strong>
project$ <strong>./bin/project-setup --device mydevice</strong>
</code></pre>
</li>
</ul>
</div>
<p>This will create some skeleton code under the <code>modules/</code> directory.</p>
<p>After adding a module, you can build it using the top-level makefile:</p>
<pre><code class="language-simics">project$ <strong>gmake</strong>
</code></pre>
<p>To emphasize that the makefile require GNU Make, it is called <code>GNUmakefile</code>. The sub-makefiles in the module directories are named <code>Makefile</code>.</p>
<p>When running make, command lines will not be printed by default. To see the commands, pass <code>V=1</code> to make:</p>
<pre><code class="language-simics">project$ <strong>gmake V=1</strong>
</code></pre>
<h3 id="creating-a-new-c-c-module">3.4.2 <a href="#creating-a-new-c-c-module">Creating a New C/C++ Module</a></h3>
<p>An example module written in C can be added in the same way as DML modules, but using the <em>--c-device</em> option. Similarly, a C++ module can be created using <em>--c++-device</em>.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows-4">Windows</span></p>
<pre><code class="language-simics">&gt; <strong>cd my-simics-project</strong>
project&gt; <strong>bin\project-setup.bat --c-device my_c_device</strong>
project&gt; <strong>bin\project-setup.bat --c++-device my_cc_device</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux-4">Linux</span></p>
<pre><code class="language-simics">$ <strong>cd my-simics-project</strong>
project$ <strong>./bin/project-setup --c-device my_c_device</strong>
project$ <strong>./bin/project-setup --c++-device my_cc_device</strong>
</code></pre>
</li>
</ul>
</div>
<h3 id="adding-an-existing-module">3.4.3 <a href="#adding-an-existing-module">Adding an Existing Module</a></h3>
<p>The top-level makefile will automatically attempt to build all modules under the <code>modules/</code> directory. If you have located a module somewhere else, you must create a symlink or junction to the module from there:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows-5">Windows</span></p>
<pre><code class="language-simics">&gt; <strong>junction my-project\modules\mydevice c:\mydevice</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux-5">Linux</span></p>
<pre><code class="language-simics">$ <strong>ln -s $HOME/mydevice ./my-project/modules/</strong>
</code></pre>
</li>
</ul>
</div>
<div class="note">
<p>It is recommended to actually copy or move the module into the modules directory of your project.</p>
</div>
<p>You may need to adapt the Makefile for the project-based build environment. Use a generated skeleton Makefile as a template for your rewrite.</p>
<p>A module to which the source is distributed with Simics, can be copied into the project by using <em>--copy-module</em>.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows-6">Windows</span></p>
<pre><code class="language-simics">&gt; <strong>cd my-simics-project</strong>
project&gt; <strong>bin\project-setup.bat --copy-module sample-memhier</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux-6">Linux</span></p>
<pre><code class="language-simics">$ <strong>cd my-simics-project</strong>
project$ <strong>./bin/project-setup --copy-module sample-memhier</strong>
</code></pre>
</li>
</ul>
</div>
<h2 id="advanced-tweaks">3.5 <a href="#advanced-tweaks">Advanced Tweaks</a></h2>
<h3 id="compiling-modules-in-debug-mode">3.5.1 <a href="#compiling-modules-in-debug-mode">Compiling Modules in Debug Mode</a></h3>
<p>The project makefiles are configured to compile optimized modules by default. To turn off optimization and turn on debugging, set the following line in <code>config-user.mk</code>:</p>
<pre><code>D=1
</code></pre>
<p>Set <code>D=0</code> or remove the line entirely to use optimization again.</p>
<p>The D flag can also be passed on the command line: </p>
<pre><code class="language-simics">project$ <strong>gmake D=1</strong>
</code></pre>
<h3 id="platform-specific-notes">3.5.2 <a href="#platform-specific-notes">Platform Specific Notes</a></h3>
<p>The project setup script has a default set of make-variables (<code>CC</code>, <code>CFLAGS</code>, <code>BLD_CFLAGS</code>, etc.), which are set up in the <code>compiler.mk</code> and <code>[simics]/config/project/config.mk</code> files. The <code>compiler.mk</code> may be edited by the user. Additional options can be specified in <code>config-user.mk</code>.</p>
<p>The makefile with the actual build rules for all modules is <code>[simics]/config/project/module.mk</code>. This file is included at the end of each module <code>Makefile</code>. To override rules or variables in this <code>module.mk</code>, add a <code>module-user.mk</code> file in the project, similar to the <code>config-user.mk</code> file described above.</p>
<p>The default set of variables assumes that you will be using GCC. If you want to use a different compiler, you need to change the <code>CC</code> variable in <code>compiler.mk</code>. The flags for the compiler are set up in <code>[simics]/config/project/config.mk</code>.</p>
<p>On Windows host, the Microsoft Visual C++ compiler is supported for compiling C++ modules. To use it, you have to run all project setup and build commands from a Visual Studio command prompt, which can be started from the Start menu.</p>
<p>The exact names of the menu items varies with the version of Microsoft Visual C++ you have installed. For Visual C++ 2008 Express Edition, it defaults to <strong>Start menu → Microsoft Visual C++ 2008 Express Edition → Visual Studio Tools → Visual Studio 2008 Command Prompt</strong>.</p>
<p>Once you have started the Visual Studio command prompt, set both of the <code>CC</code> and <code>CXX</code> environment variables to <code>cl</code>. This should allow you to run GNU <code>make</code> as usual.</p>
<p>If your compiler is not supported by <code>config.mk</code>, please report to Simics Support.</p>
<h3 id="module-makefiles">3.5.3 <a href="#module-makefiles">Module Makefiles</a></h3>
<p>In order to make the build environment in Simics recognize a module as a build target, there must be a makefile called <code>Makefile</code> in its source directory.</p>
<p>A module makefile must set up a number of make variables and then include the generic makefile for Simics modules. The following is an example of a module's <code>Makefile</code>, for a module written in C:</p>
<pre><code>MODULE_CLASSES=FAS366U

SRC_FILES=esp.c

MODULE_CFLAGS=-DFAS

SIMICS_API = 5

include $(MODULE_MAKEFILE)
</code></pre>
<p>A complete list of the available variables to set is provided below:</p>
<p></p><dl>
<dt id="dt:dmlc_flags"><const><idx>DMLC_FLAGS</idx></const></dt> <dd>(optional) Module-specific
  parameters for the DML dependency generator and compiler</dd>
<dt id="dt:extra_module_vpath"><const><idx>EXTRA_MODULE_VPATH</idx></const></dt> <dd>(optional) space-
  or colon-separated list of module names (optionally followed by a
  subdirectory: <tt><v>modulename</v>/some/path</tt>). The source
  code directory of this module (or the corresponding subdirectory)
  will automatically be added to <cmd>make</cmd>'s VPATH. The
  directories will also be added to the include search path for DML
  and C modules (using the <tt>-I</tt> options to the compilers).
<p>The current project as well as any installed Simics packages will be
searched for the module source code. Note that only the first matching
source code directory found will be used, allowing the project to
override the version of an installed package.</p></dd><p></p>
<dt id="dt:extra_obj_files"><const><idx>EXTRA_OBJ_FILES</idx></const></dt> <dd>(optional)
  Additional object files to link into the module. The module build
  will be dependent on these files, so additional rules can be
  provided in the module's <file>Makefile</file> to build these
  files before linking them.</dd>
<dt id="dt:extra_vpath"><const><idx>EXTRA_VPATH</idx></const></dt> <dd>(optional)
  Directories to add to VPATH when building.</dd>
<dt id="dt:iface_files"><const><idx>IFACE_FILES</idx></const></dt> <dd>Header files to
  compile for an interface module. If <const>IFACE_FILES</const>
  contains <file><v>file-name</v>.h</file>, in a Simics module named
  <tt><v>module-name</v></tt>, then the Python module
  <tt>simmod.<v>module_name</v>.<v>file_name</v></tt> will be
  created, containing the Python bindings for all interfaces and
  types defined in <file><v>file-name</v>.h</file>. The filenames in
  <const>IFACE_FILES</const> must not include any directory
  components; if any files are to be found in another directory,
  then that directory must be included in <tt>VPATH</tt> so the file
  is found correctly; e.g., by setting the
  <tt>EXTRA_MODULE_VPATH</tt> variable.
<p>See also section <cite>Restrictions</cite> in
<cite>Defining New Interface Types</cite>
in Model Builder User's Guide for restrictions and usage
of Python bindings.</p></dd><p></p>
<dt id="dt:module_cflags"><const><idx>MODULE_CFLAGS</idx></const></dt> <dd>(optional)
  Parameters for the C and C++ preprocessor and compiler</dd>
<dt id="dt:module_classes"><const><idx>MODULE_CLASSES</idx></const></dt>
  <dd>Space-separated list of configuration classes that this module
  registers. This information is used by <fun>SIM_get_class()</fun>
  to determine that this module should be automatically loaded when
  one of the listed classes is requested.</dd>
<dt id="dt:module_components"><const><idx>MODULE_COMPONENTS</idx></const></dt>
  <dd>Space-separated list of components that this module
  registers.</dd>
<dt id="dt:module_ldflags"><const><idx>MODULE_LDFLAGS</idx></const></dt> <dd>(optional)
  Module-specific flags for the C and C++ linker.  Any particular
  library linking (such as -lpthread, -lm, or -L to give paths to
  search for libraries) can be included here. If the module has
  dependencies on <const>LD_MODULE_PATH</const>, it is possible to
  specify <arg>-rpath</arg> so that the module will contain the
  paths that were valid at compilation time.</dd>
<dt id="dt:python_files"><const><idx>PYTHON_FILES</idx></const></dt> <dd>Space-separated list of
  Python source files to include. These Python files will be
  copied and potentially compiled (see <const>COMPILE_PYC</const>) and placed
  in a Python package specific to the module. If
  a module <tt>my-module</tt> includes the file <file>file.py</file>
  in <const>PYTHON_FILES</const>, then the resulting Python module
  will be available as <tt>simmod.my_module.file</tt> in Simics. Two
  filenames get special treatment if included in
  <const>PYTHON_FILES</const>:
  <ul><li><tt>simics_start.py</tt> is automatically imported while
          Simics is launched.</li>
      <li><tt>module_load.py</tt> is imported by Simics when the
          Simics module is loaded.</li></ul>
<p>The names <tt>checkpoint_update.py</tt> and <tt><strong>init</strong>.py</tt>
are reserved for future use, and not allowed in the list of files.</p></dd><p></p>
<dt id="dt:module_user_version"><const><idx>MODULE_USER_VERSION</idx></const></dt> <dd>(optional)
  User supplied free-text string describing the module version. The
  version string is available in Simics even without loading the module,
  through the <cmd>list-modules</cmd> command or the
  <fun>SIM_get_all_modules</fun> API function.</dd>
<dt id="dt:simics_api"><const><idx>SIMICS_API</idx></const></dt> <dd>(optional)
  Simics API to use when compiling the module. See the <cite>Simics
  Migration Guide</cite> for a description on how to compile old
  modules with a new Simics version. Valid API settings are listed
  in <file><v>[simics]</v>/<v>[host]</v>/include/api-versions.mk</file>.</dd>
<dt id="dt:src_files"><const><idx>SRC_FILES</idx></const></dt> <dd>Source files to
  compile in the module. C source file names must end in
  <file>.c</file>; C++ source file names must end in
  <file>.cc</file>, <file>.cpp</file>, <file>.cxx</file>
  or <file>.C</file> (the last not allowed on Windows).
  DML file names must have a <file>.dml</file>
  suffix. Any <file>.py</file> files should be listed
  in the <const>PYTHON_FILES</const> variable. For backward compatibility,
  modules using Simics API 4.8 or older may still list Python files
  in the <const>SRC_FILES</const> variable.</dd>
<dt id="dt:src_images"><const><idx>SRC_IMAGES</idx></const></dt> <dd>(optional)
  Images to copy directly in the <file>images</file> subdirectory in
  $(TARGET_DIR)</dd>
<dt id="dt:systemc"><const><idx>SYSTEMC</idx></const></dt> <dd>If set to 'yes', provides
  compiler and linker flags that allow building the SystemC Library adapter
  and SystemC devices. See the <cite>SystemC Library Programming Guide</cite>
  for more information.</dd>
<dt id="dt:systemc_core_cflags"><const><idx>SYSTEMC_CORE_CFLAGS</idx></const></dt>
  <dd>(optional) Parameters for the C and C++ preprocessor and
  compiler when using user-specified SystemC source.</dd>
<dt id="dt:systemc_core_ldflags"><const><idx>SYSTEMC_CORE_LDFLAGS</idx></const></dt>
  <dd>(optional) SystemC core specific flags for the C and C++
  linker. Any particular library linking can be included here.</dd>
<dt id="dt:systemc_module_cflags"><const><idx>SYSTEMC_MODULE_CFLAGS</idx></const></dt>
  <dd>(optional) Parameters for the C and C++ preprocessor and
  compiler when compiling SystemC modules.</dd>
<dt id="dt:thread_safe"><const><idx>THREAD_SAFE</idx></const></dt> <dd>If set to
  <tt>yes</tt>, declare that the module is thread-safe.</dd>
<dt id="dt:use_cc_api"><const><idx>USE_CC_API</idx></const></dt> <dd>It can be set
  to a specific version to select which version of C++ Device API
  to use. Current supported versions are '1' and '2'. See the
  <cite>C++ Device API Programming Guide</cite> for more information.</dd>
<dt id="dt:suppress_device_info"><const><idx>SUPPRESS_DEVICE_INFO</idx></const></dt> <dd>If set to
  'yes', suppress output of the <file>.xml</file> device info file
  by the DML compiler.</dd>
<dt id="dt:compilers"><const><idx>COMPILERS</idx></const></dt> <dd>An optional
  list of compatible compilers, in order of preference. The allowed list
  element values are <tt>gcc</tt> and <tt>cl</tt>, for MinGW and Visual
  Studio respectively. On platforms other than Windows, <tt>cl</tt> is
  ignored.</dd>
<dt id="dt:compile_pyc"><const><idx>COMPILE_PYC</idx></const></dt> <dd>If this is set
  to <tt>1</tt>, then the files listed in <const>PYTHON_FILES</const>
  are compiled, not copied.</dd>
</dl>
<p></p>
<p>The user can also add new rules to the makefile, after the inclusion of the generic <code>$(MODULE_MAKEFILE)</code>. This is usually not needed.</p>
<p>The following variables can be used in the module's makefile (i.e., <code>[project]/modules/&lt;module&gt;/Makefile</code>). They should be considered <em>read-only</em>, i.e., they should not be changed.</p>
<ul>
<li><code>SIMICS_PROJECT</code> is the full path to the project directory.</li>
<li><code>TARGET_DIR</code> is the directory in which compiled modules are placed (<code>[project]/[host-type]/lib</code>).</li>
<li><code>SRC_BASE</code> is the full path to the project modules directory (<code>[project]/modules</code>). </li>
<li><code>HOST_TYPE</code> is the Simics host architecture, i.e., what OS/hardware Simics has been compiled for, such as <code>win64</code> or <code>linux64</code>. </li>
<li><code>LATEST_API_VERSION</code> is the API version you get if 'latest' is specified in the module's makefile. </li>
<li><code>TARGET</code> is the name of the module being compiled. Note that <code>SRC_BASE</code> and <code>TARGET</code> gives you access to the module source code directory, so that you can refer to source code files with absolute paths when necessary, as in <code>$(SRC_BASE)/$(TARGET)/foo.c</code>. </li>
</ul>
<h3 id="standard-module-host-defines-in-c-c">3.5.4 <a href="#standard-module-host-defines-in-c-c">Standard Module Host Defines in C/C++</a></h3>
<p>There are a number of C/C++ pre-processor defines that are set depending on the host that the module is being compiled on. They are usually not needed, but useful in some special cases. Examples: <code>HOST_64_BIT</code>, <code>HOST_BIG_ENDIAN</code> and <code>HOST_LITTLE_ENDIAN</code>. There are also defines specifying the host architecture and host operating system. All these defines are set in the Simics include file <code>global.h</code>.</p>
<h3 id="user-defined-module-version-strings">3.5.5 <a href="#user-defined-module-version-strings">User Defined Module Version Strings</a></h3>
<p>It is possible to set a user defined version string in loadable modules. This is done by setting the <code>MODULE_USER_VERSION</code> variable in the module's <code>Makefile</code>. The version string will be printed by the <code>list-modules</code> and <code>list-failed-modules</code> commands.</p>
<h3 id="module-loading-support">3.5.6 <a href="#module-loading-support">Module Loading Support</a></h3>
<p>When Simics starts, it will read the supported architecture and word size for all modules on the Simics module path. Only modules that match the architecture and word size of the running Simics binary will be available for loading into Simics. While scanning the modules, Simics will also check what classes the module will register when it is loaded. This way modules can be loaded automatically when the classes that they define are used in a configuration.</p>
<p>If a module cannot be loaded into the current Simics, it will be added to the list of failed modules. This list can be displayed with <code>list-failed-modules</code>, that takes an optional parameter <code>-v</code> for more verbose output.</p>
<pre><code class="language-simics">simics&gt; <strong>list-failed-modules</strong>

Current module version number: 1050  Lowest version number supported: 1050

MODULE           DUP  VERSION USR_VERS  LINK
---------------------------------------------
8042                   1040
image                  1040
spitfire-mmu.so                          X
</code></pre>
<p>The columns after the module name (or file name in the case of a link error) indicate different kinds of errors. An <code>X</code> in the <code>DUP</code> column means that this module could not be loaded because this module has the same name as another module found in the Simics module search path, and that this one was overridden. An <code>X</code> in the <code>VERSION</code> column means that the module was created for another, non-compatible, version of Simics. <code>LINK</code> means that this module cannot be loaded into Simics because of unresolved symbols. Use <code>list-failed-modules -v</code> to see the actual error message from the run-time module loader.</p>
<div class="note">
<p>Modules compiled for other architectures or word lengths will not be listed</p>
</div>
<h3 id="extra-libraries">3.5.7 <a href="#extra-libraries">Extra libraries</a></h3>
<p>If a module requires linking against libraries that are not expected to be found on end user's systems, then these libraries can be included in a Simics package. They should be placed in <code>host/sys/lib</code>. For testing and development, this can also be in a Simics project, by adding the project as a package path.</p>
<p>On Windows, Simics will add this directory to the DLL search path for every package.</p>
<p>On Linux, one must also make sure that the Simics module is linked in such a way that the library is found when the module is loaded at run time, by adding this to the module <code>Makefile</code>: </p>
<pre><code>MODULE_LDFLAGS += -Wl,-rpath,'$$ORIGIN/../sys/lib'
</code></pre>
<p>On all platforms, Simics will detect and warn if the same library exists in multiple packages. To avoid such problems, one can for example include a version number in the library filename.</p>
<p>Note that the Simics module resolution logic does not apply to these extra libraries.</p>
<p>If an extra library is dependent on the Simics API, it must link with the Simics library in order to make symbol lookup work correctly. This can be done by building the library as part of the Simics module that uses it, and adding these linker flags: </p>
<pre><code>-L$(SIMICS_BASE)/$(HOST_TYPE)/bin -lsimics-common
</code></pre>
<h2 id="emacs-dml-editing-mode">3.6 <a href="#emacs-dml-editing-mode">Emacs DML Editing Mode</a></h2>
<p>The Emacs (<a href="http://www.gnu.org/software/emacs/" rel="noopener noreferrer" target="_top">http://www.gnu.org/software/emacs/</a>) extensible editor is the first choice for many programmers, and Simics Model Builder includes a customized mode for editing DML source files. The DML mode is an extension of the standard Emacs editing mode for the C programming language.</p>
<p>Simics includes the Emacs file <code>dml-mode.el</code> to add support for the DML major mode. This file can be found in the <code>[simics]/scripts</code> directory. To use it, add the following lines to your Emacs configuration file (usually <code>[home]/.emacs</code> or <code>[home]/.xemacs/init.el</code>): </p>
<pre><code>(setq load-path (cons "[simics]/scripts" load-path))
(autoload 'dml-mode "dml-mode" "DML mode" t)
(add-to-list 'auto-mode-alist '("\\.dml\\'" . dml-mode))
</code></pre>
<p>(you need to replace the text <code>[simics]</code> in the above with the full path to your Simics Base installation which includes Model Builder). After restarting Emacs, the DML mode should be automatically enabled when you open a file whose name ends in "<code>.dml</code>".</p>
<p>For more information, run the command <code>M-x describe-mode</code> in an Emacs buffer using the DML mode, or read the "Editing Programs" section of the Emacs documentation.</p>

<div class="chain">
<a href="modeling-techniques.html">2 Modeling Techniques</a>
<a href="part-device-modeling.html">II Device Modeling</a>
</div>