<!doctype html>
<head>
<meta charset="utf-8">
<title>C++ Device API v2</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<span></span>
</div>
<div class="path"></div>
<h1 id="c-device-api-v2"><a href="#c-device-api-v2">C++ Device API v2</a></h1>
<h2 id="introduction">1 <a href="#introduction">Introduction</a></h2>
<p>This document describes the Simics C++ Device API, which is a C++ layer built on top of the Simics C API. See the 
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a> for more information about the C API. The C++ Device API is also used when integrating SystemC models into the Simics framework. See the 
<a href="../systemc-library/index.html">SystemC Library Programming Guide</a> for more information about Simics and SystemC models.</p>
<p>We recommend that you use DML for writing new simulation models, but it is often necessary to port existing simulations models from a different environment to Simics. If these are written in C++ or SystemC, you can use the <em>C++ Device API</em> to simplify the task. For SystemC there is further support described in the 
<a href="../systemc-library/index.html">SystemC Library Programming Guide</a>.</p>
<p>The Simics C++ Device API is a collection of C++ functions, data types, and templates that make it easier to connect a C++ simulation model to the Simics framework. The C++ Device API is implemented as a layer on top of the Simics C API, and the detailed API documentation is found in the <em>Simics C++ Device API Reference Manual</em>. The source code is found in <code>[simics]/src/devices/c++-api</code>.</p>
<p>While this application note aims to cover most aspects of porting C++ device models to the Simics APIs, it is assumed that you are familiar with the Simics device modeling concepts described in the 
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a>.</p>
<h2 id="about-the-simics-c-device-api-version-2">2 <a href="#about-the-simics-c-device-api-version-2">About the Simics C++ Device API version 2</a></h2>
<p>Version 2 of the Simics C++ Device API replaces the old Simics C++ Device API, which has been retroactively named as the Simics C++ Device API v1. The v1 API was developed before the C++11 standard was introduced. The v1 API also has some technical limitations; for example, no support for Simics port objects that was introduced in Simics version 6.</p>
<h3 id="minimal-requirements">2.1 <a href="#minimal-requirements">Minimal requirements</a></h3>
<p>The v2 API utilizes C++11 and C++14 features to improve productivity. It has been designed to be easier to use and adds support for Simics port objects. To use the v2 API, your C++ compiler must support C++14, which means that the minimal GCC compiler version is 6.3 and the minimal MSVC compiler version is 2015. Later versions are typically used.</p>
<figure id="api-overview">
<p><img alt="" src="block_diagram.svg"> </p><figcaption>Figure 1. Overview of the Simics C++ device API version 2</figcaption> <p></p>
</figure>
<p>Figure <a class="reference" href="#api-overview">1</a> shows the high-level observation of the Simics C++ device API version 2. The v2 API consists of several parts. First it provides support for registration of a Simics class which connects with your C++ device. It also provides <em>Port</em> and <em>Connect</em> concept to communicate with other Simics modules. Then for inspection and checkpointing, it also includes support for <em>Attribute</em>. The <em>Event</em> concept helps to register events which are driven by the Simics scheduler. Last but not the least, a tech-preview feature to support programming registers is included.</p>
<p>To use the v2 API, you must set <code>USE_CC_API = 2</code> in your module's <code>Makefile</code> and <code>#include &lt;simics/cc-api.h&gt;</code> in your C++ source files. The Simics C++ Device API is exported in the <em>simics</em> namespace.</p>
<p>The module <code>sample-device-c++</code> provides source code that shows how to use the API described in this document. Use <code>bin/project-setup --copy-module sample-device-c++</code> to copy the code to your Simics project for easy reference.</p>
<h2 id="preparations">3 <a href="#preparations">Preparations</a></h2>
<p>Before you start to connect your C++ device to the Simics API, you need to consider which the logical components of your device model are, and how they are connected to each other and the rest of the simulation environment.</p>
<p>In Simics, device models are implemented as separate objects that are dynamically connected to each other using the Simics configuration system, and the objects communicate using explicitly requested interfaces. This is in contrast to C++, where the objects are often aggregated at compile time or by running compiled startup code and interfaces are resolved during compilation and linking. The 
<em>Model Builder User's Guide</em> has a more complete description of the Simics object system.</p>
<p>Similar to C++, <em>objects</em> in the Simics simulator are instances of <em>classes</em>. However, Simics classes are not C++ classes but instead defined by Simics <em>modules</em>. Simics modules declare Simics classes by calling the Simics API when the module is loaded. Simics classes have attributes, interfaces, port objects, and callbacks to allocate and delete instances of the class. The C++ API provides a convenient way to express these Simics simulator concepts in C++, but there is not a 1-to-1 correspondence between C++ classes and Simics classes.</p>
<h3 id="designing-the-simics-classes">3.1 <a href="#designing-the-simics-classes">Designing the Simics classes</a></h3>
<p>The first step is to decide how the C++ model should appear within Simics. For a simple C++ model that models a small piece of hardware, it is probably sufficient to make the entire model into a single Simics class.</p>
<p>But for a C++ model that consists of several components connected together, it is worth considering exposing it as several Simics classes. One reason for this is that it makes the Simics configuration more natural by creating a model that fits better with the Simics framework. And it allows for future separation of the model parts without major changes to the configurations.</p>
<p>Simply exposing the model as several classes will not automatically make the classes independent under the surface; they are still implemented as one conglomerate of C++ objects inside the implementation. To fully take advantage of the flexibility of the Simics configuration system, the device should be split it to discrete pieces that communicate only using Simics interfaces. By using well-known interfaces, the devices will become replaceable by newer implementations individually, and will allow experimentation in reconfiguration without having to recompile the model sources, or even having access to the source code.</p>
<p>This document focuses on creating Simics modules wrapping simple C++ models which define a single Simics class, but it easily extends to modules with several classes.</p>
<h3 id="defining-attributes">3.2 <a href="#defining-attributes">Defining Attributes</a></h3>
<p>A Simics object <em>attribute</em> is used to accomplish primarily three things. The first is to specify configuration parameters when initially creating the model instance. This includes connections to other configuration objects, model parameters such as frequencies and buffer sizes, but anything is possible.</p>
<p>The other main purpose of attributes is to allow saving and restoring the model state to support checkpointing. This means that the complete state of the model needs to be available to the Simics configuration system as attribute values. Attributes would be read to save the state of the model, and the attributes would then be written to set the state of a new instance of the model to the same state as saved in the checkpoint.</p>
<p>A third use of attributes is to inspect and control the state of the model. This is usually covered by the same attributes used for checkpointing, as it is about the state of the models. Attributes are <em>read</em> in order to inspect the state, and attributes can also be changed (from scripts or CLI) to force changes to the state of the model during a simulation session.</p>
<p>Attributes should never be used to communicate simulation information between objects after instantiation. They are a model-to-simulator mechanism, not a model-to-model mechanism. Models should communicate over interfaces.</p>
<p>State attributes used for checkpointing and/or inspection could also be used to set the initial state of the model at setup time.</p>
<h4 id="configuration-attributes">3.2.1 <a href="#configuration-attributes">Configuration Attributes</a></h4>
<p>The configurable aspects of the C++ model should be available as configuration attributes. In some cases this will mean small changes to the C++ implementation.</p>
<p>The most common configurable parameter is probably references to other Simics configuration objects, such as interrupt targets, memory spaces, or DMA controllers. All references to other Simics simulation objects have to be provided as configuration parameters. Such references are set using object references when a Simics simulation session is set up. The model must never make any assumptions about which other objects are present in the system configuration or there names.</p>
<p>If the C++ model is written with compile-time configuration using the preprocessor, consider rewriting it to be dynamically reconfigurable. This will make the model more versatile, and potentially much more useful to a broader audience. The overhead of runtime checking of these kinds of configuration parameters is negligible in the vast majority of devices, especially when run in the context of full-system simulation.</p>
<p>For example, a parameter to decide which hardware revision to be compatible with may very well be a run-time parameter. Another option is adding configuration parameters that go outside the scope of the known hardware, by allowing buffer sizes and similar parameters to be reconfigured for experimental purposes.</p>
<h4 id="model-state">3.2.2 <a href="#model-state">Model State</a></h4>
<p>To support checkpointing, the model needs to be able to collect a full description of the current model state and it needs to be able to restore the model to the checkpointed state when the Simics object is created.</p>
<p>To support reversible execution, the requirements are stricter. The object needs to be able to restore from a checkpointed state at any time, even when there is a previous state that must be discarded.</p>
<p>An existing C++ model needs to be examined to find how its simulation state is defined. If the model is not written to handle checkpointing, it may need to be updated with a way to extract and restore the state.</p>
<p>The model state is made available to the Simics configuration system using a number of attributes. There should be one attribute for each piece of the model state. It is a good idea to design the set of attributes for the model in a way that allows some separation of the external, checkpointable representation of the state from the implementation details. Ideally, the checkpoint format should not need to be updated when the implementation is changed, including running on a different host platform, using different C++ classes, internal representation or other structural changes. As a minimum requirement the external representation must not depend on what compiler is used, or whether the model is built for a 32-bit or 64-bit environment. Preferably it should be fully portable between platforms regardless of what CPU architecture the simulation is running on. When changes to the checkpoint format is required, Simics provides ways to still be able to read old checkpoints with updated models.</p>
<p>For example, if the model models a device with 16 32-bit registers with different meaning, it is preferably represented as 16 integer-valued attributes, with names that match those used in the device programming manual.</p>
<p>Never save a copy of the binary in-memory representation of a C++ object or <code>struct</code>. This is highly unportable and may break checkpoint compatibility just by recompiling the source with different compiler flags. Pointer variables obviously break in this case.</p>
<h3 id="interfaces">3.3 <a href="#interfaces">Interfaces</a></h3>
<p>A Simics device model interacts with the rest of the simulation using <em>interfaces</em>. The <em>interfaces</em> can either by implemented on the device model or on a separate <em>port object</em>. There may be several port objects implementing the same interface.</p>
<p>To be useful, the model should implement one or more interfaces. The most commonly implemented interfaces are those used to simulate memory transactions between processors, devices, and memory. The current recommended interface for memory operations in Simics is the <code>transaction</code> interface. The old and still widely used interface for memory operations is called <code>io_memory</code>.</p>
<p>There is a 1-to-1 correspondence between the Simics C interface and the Simics C++ interface. Simics C++ models should use the Simics C++ interfaces instead of the Simics C interfaces. For example, use <code>transaction</code> interface by <code>#include &lt;simics/c++/model-iface/transaction.h&gt;</code> in your C++ source files. See <a class="reference" href="#user-defined-interface">6.4</a> for how to create and use an user defined Simics C++ interface.</p>
<h3 id="register-banks">3.4 <a href="#register-banks">Register Banks</a></h3>
<p>A memory-mapped I/O Simics device model interacts with the memory bus using <em>register banks</em>. Each <em>register bank</em> is a separate <em>port object</em>. One device model can have many <em>register banks</em>.</p>
<p>The <em>register bank</em> processes the received transaction and passes it down to the related <code>register</code>s on the bank. Each <code>register</code> is generally used to model a hardware register. Typically some model behavior is triggered when the <code>register</code> is being accessed. A <code>register</code> can be further divided into <code>field</code>s on the bit level.</p>
<p>By using <em>register banks</em>, the rich Simics features are automatically enabled. The <em>register banks</em> can be easily inspected, traced and manipulated using Simics tools. The <code>register</code>s are registered as Simics <code>attribute</code>s and automatically saved in a Simics checkpoint. See <a class="reference" href="#register-banks-2">7</a> for how to create and use the <em>register banks</em>.</p>
<p>For more information about how to design a model for Simics, see 
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a>.</p>
<h2 id="simics-modules">4 <a href="#simics-modules">Simics Modules</a></h2>
<p>The first step of building a C++ simulation model for Simics is to create a Simics <em>module</em>. Typically, you put each Simics class in a module of its own. It is also common to have multiple closely-related classes in a single module (to simplify distribution if the classes would typically be used together anyway).</p>
<p>To create a Simics C++ module skeleton, you use <code>project-setup</code>: </p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows">Windows</span></p>
<pre><code>&gt; cd my-simics-project
project&gt; bin\project-setup --c++-device my_cc_device
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux">Linux</span></p>
<pre><code>$ cd my-simics-project
project$ ./bin/project-setup --c++-device my_cc_device
</code></pre>
</li>
</ul>
</div>
<p>See the <a href="../model-builder-user-guide/build-environment.html#build-environment">Build Environment chapter in the Model Builder User's Guide</a> for details on how to set up a project and creating Simics module skeletons.</p>
<p>When a Simics module is loaded into Simics, it is initialized by running its <code>init_local</code> function, which must use <em>C</em> linkage; i.e., it must be wrapped by <code>extern "C"</code>. This function is responsible for registering the Simics classes in the module with the Simics core, but you can add any other initialization code needed to that function.</p>
<h3 id="module-configuration">4.1 <a href="#module-configuration">Module Configuration</a></h3>
<p>The standard Simics memory tracking allocator is used by Simics C++ device API by default, by providing it as a custom allocator for new and delete. This is done per module. For a module to use its own custom allocators or even the default new allocator, this feature can be disabled.</p>
<p>To disable the feature, set the <code>USE_CC_MEMORY_MANAGEMENT</code> build parameter to <code>no</code> and rebuild the module.</p>
<h2 id="simics-classes">5 <a href="#simics-classes">Simics Classes</a></h2>
<p>A Simics class has a name, a short description and a documentation string. Its functionality is implemented in a number of configuration attributes and the interfaces.</p>
<p>For each instance of a Simics class defined using the C++ API, there will be a C++ object created to correspond to that Simics configuration object. This C++ object is an instance of a model-defined class that must inherit from the <code>simics::ConfObject</code> class.</p>
<p>The C++ class must have a constructor taking a single parameter of type <code>ConfObjectRef</code> which is passed on to the <code>ConfObject</code> constructor. The C++ class constructor is called internally when the corresponding Simics configuration object is created. The destructor of the C++ class is called internally when the corresponding Simics configuration object is deleted.</p>
<p>In addition of the constructor and destructor, user can override two methods <code>finalize</code> and <code>objects_finalized</code> to register additional functionality if needed. The <code>finalize</code> method is called when all attributes have been initialized in the object, and in all other objects that are created at the same time. This method is supposed to do any object initialization that require attribute values. The <code>objects_finalized</code> method is called after <code>finalize</code> has been called on all objects, so in this method the configuration is ready, and communication with other objects is permitted without restrictions.</p>
<p>
</p><pre><code>#include &lt;simics/cc-api.h&gt;

class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
        : simics::ConfObject(o) {
        // initialize
    }

    static void init_class(simics::ConfClass *cls) {
        // register the class properties to Simics
    }

    // other members
};
</code></pre>
<p></p>
<p>This is the main object of the model instance, and everything goes through this. It should contain or reference anything that the model instance will need. Remember that there can be several instances of the model class, since the configuration allows the user to load multiple systems into the same simulation.</p>
<h3 id="defining-the-simics-class">5.1 <a href="#defining-the-simics-class">Defining the Simics Class</a></h3>
<p>Each Simics module must have <code>init_local</code> function to set up the Simics class. For a C++ module, you should invoke <code>simics::make_class</code> function inside the <code>init_local</code> function to register the Simics class with the Simics core.</p>
<p>
</p><pre><code>extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
        // Simics class name
        "sample_device_auto",
        // short description
        "sample C++ device",
        // class documentation
        "This is a sample Simics device written in C++.");
} 
</code></pre>
<p></p>
<p>The function parameters for <code>simics::make_class</code> are the <code>name</code>, the <code>short_desc</code>, and the <code>description</code>. It also takes an optional forth parameter <code>kind</code> which by default is <code>Sim_Class_Kind_Vanilla</code>. See the documentation of <code>SIM_create_class</code> for more information about these 4 parameters.</p>
<p>The template argument is the C++ class that should be instantiated to represent the Simics object or a port object of the Simics object. It must be derived through public inheritance from <code>simics::ConfObject</code>(for the Simics object) or <code>simics::Port</code>(for port object) as noted above.</p>
<p>Sometimes it is necessary to know the Simics class that is being registered. The function returns a <code>unique_ptr</code> of <code>ConfClass</code> which can be used to register attributes, interfaces, log groups and ports. In the example above, the return value is not used, and only the class is registered.</p>
<p>If, during registration, the class passed as template argument defines a static function <code>init_class</code>; that function is called during the registration. It is recommended to perform any class related registration of properties inside this static function, to improve data encapsulation. Other type of registration can be done inside <code>init_local</code> using the return value from <code>make_class</code>.</p>
<p>
</p><pre><code>extern "C" void init_local() {
    auto cls = simics::make_class&lt;sample_instance&gt;(
        "sample_device_explicit",
        "sample C++ device",
        "This is a sample Simics device written in C++.");

    // use cls to do any other registrations necessary
} 
</code></pre>
<p></p>
<h2 id="ports-and-interfaces">6 <a href="#ports-and-interfaces">Ports and Interfaces</a></h2>
<p>To implement an interface, either on the top level module or a port object, there are three steps needed: </p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:interface-declarations">Interface declarations</span></p>
<p>Declare C++ methods inherited from the interface class.</p>
</li>
<li>
<p><span class="term" id="dt:interface-method-implementation">Interface method implementation</span></p>
<p>Implement the declared C++ methods for the interface.</p>
</li>
<li>
<p><span class="term" id="dt:interface-registration">Interface registration</span></p>
<p>Register the interface with the <code>ConfClass</code> object.</p>
</li>
</ul>
</div>
<h3 id="interface-declarations">6.1 <a href="#interface-declarations">Interface declarations</a></h3>
<p>Your instance class needs to declare the C++ methods inherited from the interface class.</p>
<p>For example: </p>
<p>
</p><pre><code>class sample_interface : public simics::ConfObject,
                         public simics::iface::IoMemoryInterface {
  public:
    explicit sample_interface(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls);

    // interface method declarations
    exception_type_t operation(generic_transaction_t *mem_op,
                               map_info_t map_info) override;
};
</code></pre>
<p></p>
<p>For a Simics public interface, its C++ interface header is already part of the <code>Simics-Base</code> package and can be included directly. For a user defined interface, the C++ interface header can be generated from its C interface header by a help script. See <a class="reference" href="#user-defined-interface">6.4</a>.</p>
<p>The interface method declarations are straight-forward. They should have the same signature as the interface method in the 
<em>Simics Reference Manual</em> (or as shown with the Simics command <code>api-help</code>), except that the first C argument of type <code>conf_object_t *</code> is left out, as it corresponds to the C++ class instance. With the C++ <code>override</code> keyword, compiler checks if the signature matches.</p>
<h3 id="interface-method-implementation">6.2 <a href="#interface-method-implementation">Interface method implementation</a></h3>
<p>The interface method is called when the Simics interface is accessed. The implementation should handle the call in a device specific manner. </p>
<p>
</p><pre><code>exception_type_t sample_interface::operation(generic_transaction_t *mop,
                                             map_info_t info) {
    // implement behavior here
    return Sim_PE_No_Exception;
}
</code></pre>
<p></p>
<h3 id="interface-registration">6.3 <a href="#interface-registration">Interface registration</a></h3>
<p>Interface is registered on the <code>ConfClass</code> object using the <code>add</code> function, just like registering a Simics attribute: </p>
<p>
</p><pre><code>void sample_interface::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::iface::IoMemoryInterface::Info());
}
</code></pre>
<p></p>
<p>The only parameter is an instance of <code>IoMemoryInterface::Info</code>. It provides the registry support for the <code>io_memory</code> interface.</p>
<p>For better data encapsulation, it is recommended to register the interface in the instance's static method <code>init_class</code>.</p>
<h3 id="user-defined-interface">6.4 <a href="#user-defined-interface">User defined interface</a></h3>
<p>The C++ bindings for interfaces are only available for standard Simics interfaces. To support user defined interfaces new C++ bindings in the form of C++ interface classes must be generated. These classes can either be copied and edited from existing headers, or generated by the <code>bin/gen-cc-interface</code> tool.</p>
<p>For example, <code>example.h</code> defines the C interface type <code>example_interface_t</code>. </p>
<p>
</p><pre><code>extern "C" {
    SIM_INTERFACE(example) {
        void (*iface_fun)(conf_object_t *obj);
    };
    #define EXAMPLE_INTERFACE "example"
}
</code></pre>
<p></p>
<p>The C interface type <code>example_interface_t</code> needs to be converted to C++ interface class <code>ExampleInterface</code>. This can be done by running the <code>gen-cc-interface</code> tool(for usage, see <a class="reference" href="#generator-of-simics-c-interface-header">11.1</a>): </p>
<pre><code>  project&gt; bin/gen-cc-interface modules/example-interface/example.h
</code></pre>
<p>Now the <code>c++/example.h</code> can be included in the device model providing <code>ExampleInterface</code>. </p>
<p>
</p><pre><code>// This c++ file is generated from example.h by gen_cc_interface.py
#include "c++/example.h"

class sample_user_interface : public simics::ConfObject,
                              public simics::iface::ExampleInterface {
  public:
    explicit sample_user_interface(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(ExampleInterface::Info());
    }

    // Interface method declarations
    void iface_fun() override {
        // TODO: implement
    }
};

extern "C" void init_local() {
    simics::make_class&lt;sample_user_interface&gt;(
            "sample_user_interface",
            "sample user interface",
            "N/A");
}
</code></pre>
<p></p>
<h3 id="port-registration">6.5 <a href="#port-registration">Port registration</a></h3>
<p>Port objects are like normal Simics objects. A port class is declared by inheriting from the <code>simics::Port</code> class and one or more interface classes. The port class implements the C++ methods in the same way as the C++ device class. The port class is then registered with its parent ConfClass using the <code>add</code> function. The name of the port object is passed as the second parameter to the <code>add</code> function. The registration of the port class to its parent requires both classes are created. Thus the registration should be placed inside the <code>init_local</code> function after the creation of classes. A port array can be easily created using an array name as shown in the example code. </p>
<p>
</p><pre><code>class IoPort : public simics::Port&lt;sample_interface&gt;,
               public simics::iface::IoMemoryInterface {
  public:
    explicit IoPort(simics::ConfObjectRef o)
        : simics::Port&lt;sample_interface&gt;(o) {}

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::iface::IoMemoryInterface::Info());
    }

    // interface method declarations
    exception_type_t operation(generic_transaction_t *mem_op,
                               map_info_t map_info) override;
};

exception_type_t IoPort::operation(generic_transaction_t *mop,
                                   map_info_t info) {
    // implement behavior here
    return Sim_PE_No_Exception;
}

extern "C" void init_local() {
    auto cls = simics::make_class&lt;sample_interface&gt;(
            "sample_port_object",
            "sample interface with port",
            "N/A");
    auto port = simics::make_class&lt;IoPort&gt;(
            "sample_port_object.port",
            "sample port object port",
            "Sample port object port");

    // A single port under port namespace
    cls-&gt;add(port, "port.single");

    // A port array
    cls-&gt;add(port, "port.array[10]");
}
</code></pre>
<p></p>
<p>If the port class needs to access the C++ parent class's internal state variables, it can be defined inside the C++ parent class. There is a help method <code>parent_data</code> that returns the parent object pointer. </p>
<p>
</p><pre><code>class Parent : public simics::ConfObject {
  public:
    explicit Parent(simics::ConfObjectRef o)
        : simics::ConfObject(o) {}

    class IoPort : public simics::Port&lt;Parent&gt; {
      public:
        explicit IoPort(simics::ConfObjectRef o)
            : simics::Port&lt;Parent&gt;(o) {}
    };
};
</code></pre>
<p></p>
<h3 id="methods-collision">6.6 <a href="#methods-collision">Methods collision</a></h3>
<p>In C++ two overloaded functions must not have the same signature. When implementing interfaces that expose the same function this collision can be avoided by introducing an intermediate class that provides the implementation and then inherit from these intermediate classes as shown in the following example. Another option is to implement the interface in a port object.</p>
<p>
</p><pre><code>extern "C" {
SIM_INTERFACE(one) {
    void (*iface_fun)(conf_object_t*);
};
SIM_INTERFACE(another) {
    void (*iface_fun)(conf_object_t*);
};
}

namespace simics {
namespace iface {

class OneInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

class AnotherInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

}  // namespace iface
}  // namespace simics

class ImplementOne : public simics::iface::OneInterface {
    void iface_fun() override {
        // This is implementation for OneInterface
    }
};

class ImplementAnother : public simics::iface::AnotherInterface {
    void iface_fun() override {
        // This is implementation for AnotherInterface
    }
};

class MethodsCollision : public simics::ConfObject,
                         public ImplementOne,
                         public ImplementAnother {
  public:
    explicit MethodsCollision(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }
};

</code></pre>
<p></p>
<h2 id="register-banks-2">7 <a href="#register-banks-2">Register Banks</a></h2>
<div class="note">
<b>Note:</b>
The C++ device API for register banks is currently considered as a technology preview feature and is subject to change without notice.
</div>
<p>Memory-mapped I/O (MMIO) devices are mapped to (associated with) an address space with an address value. The device connects the data bus to the desired device's hardware register banks. In C++, the device API for register banks makes the connection and modeling of such MMIO devices easier.</p>
<p>To enable the support for register banks, <code>cc-modeling-api.h</code> needs to be imported and the C++ compiler must support C++17. This header provides several objects types similar to the DML, including <code>bank</code>, <code>register</code> and <code>field</code>. <code>Bank</code> models a hardware register bank but can also contain unmapped registers to help with the modeling. It contains a set of <code>register</code>s. Each <code>register</code> is generally used to model a hardware register. A <code>register</code> can be further divided into <code>field</code>s on the bit level. As the scope of these types represents a hierarchy, they are referred to as <code>hierarchical object</code>s. In addition, the C++ device class needs to be a <code>MappableConfObject</code> to support device level configuration. All these types are described further in the sub sections.</p>
<h3 id="mappableconfobject">7.1 <a href="#mappableconfobject">MappableConfObject</a></h3>
<p>To model an MMIO device, the C++ device class needs to inherit from class <code>simics::MappableConfObject</code> instead of class <code>simics::ConfObject</code>. The class <code>simics::MappableConfObject</code> extends <code>simics::ConfObject</code> class with the support for device level configurations. For example, the bit order representation used for the device. The <code>simics::MappableConfObject</code> class should be the first base class of the C++ device class to setup the required framework.</p>
<p>The bit fields is by default represented in the little endian bit order, i.e, bit number 0 is the least significant bit. It can be changed to big endian bit order by overriding the function <code>big_endian_bitorder</code> from class <code>simics::MappableConfObject</code>. This only affects how bits are represented but not the internal bits implementation.</p>
<p>An instance of the class <code>simics::MappableConfObject</code> also keeps track of a one to one map from the full name of a hierarchical object to its corresponding access interface. The map is updated whenever a new hierarchical object instance is created. The hierarchical object instance can be created in different locations, e.g, inside the constructor of base classes of the C++ device class, as class member of the C++ device class or inside the constructor body of the C++ device class. It is allowed to create hierarchical objects with the same hierarchical name multiple times. In this case, based on the C++ object creation order, the last created instance wins. This is useful for replacing the behavior of an existing hierarchical object without the need of modifying the original behavior; it can simply be replaced instead. When a bank is initialized in the <code>BankPort</code> class, it is no longer possible to replace existing entries in the map. New entries can stil be added to the map up until the Simics object has been finalized. See Figure <a class="reference" href="#creation-flow">2</a> for a simple diagram of the creation flow.</p>
<figure id="creation-flow">
<p><img alt="" src="creation_flow.svg"> </p><figcaption>Figure 2. Creation flow of C++ device and its port object instances</figcaption> <p></p>
</figure>
<div class="note">
<b>Note:</b>
The access interface to the hierarchical object saved in the <tt>map</tt> must be available during the life cycle of the <tt>MappableConfObject</tt>. One way to guarantee that is to instantiate the object as a class member of the C++ device class.
</div>
<p>During the simulation, the access interface for a hierarchical object can be easily retrieved from the map using its name. This is useful for cross-object access inside the device. For example, a register's access side-effect could be to update a field in some other register. If this is a common access pattern this lookup should be cached by storing the interface as a private member.</p>
<h3 id="bank-port-object">7.2 <a href="#bank-port-object">Bank Port Object</a></h3>
<p>A register bank (or simply bank) is an abstraction that is used to group registers, and to expose these to the outside world. A bank is implemented as a port object of the C++ device class. Registers are exposed to the rest of the simulated system through the Simics <code>transaction</code> interface, and exposed to scripting and user interfaces through the <code>register_view</code>, <code>register_view_read_only</code> and <code>bank_instrumentation_subscribe</code> Simics interfaces.</p>
<p>The <code>simics::BankPort</code> template class is used to model the bank port object. It inherits from <code>simics::Port</code> and implements the above required Simics interfaces. The type template parameter must be set to the C++ device class.</p>
<p>Besides the required <code>ConfObjectRef</code> parameter, the constructor of the class can optionally take a second parameter to pass the bank mapping information. It defaults to <code>nullptr</code> which means the bank mapping information is passed in another way as described in <a class="reference" href="#by-code-when-information-is-provided-by-the-c-classes-and-the-class-hierarchy">7.4.1</a>.</p>
<p>The function <code>make_bank_port</code> helps to create a Simics port class. The port class is then registered with its parent ConfClass using the <code>add</code> function. And this registration is typically done inside the <code>init_class</code> function from the device model class.</p>
<p>Simics attributes can be registered directly on the bank port. This is useful for storing the bank's (or any of the register's and field's) state. The bank attributes are automatically saved to the Simics checkpoint by <code>write-configuration</code>. To register an attribute, simply add an <code>Attribute</code> instance (see <a class="reference" href="#attributes">8</a> for more details).</p>
<p>Banks can also be grouped into an array. Each element in the bank array is a separate configuration object in Simics, and can thus be individually mapped in a memory space. See <a class="reference" href="#port-registration">6.5</a> for how to easily register a bank array.</p>
<div class="note">
<b>Note:</b>
Multidimensional bank array is not supported.
</div>
<h3 id="hierarchical-object">7.3 <a href="#hierarchical-object">Hierarchical object</a></h3>
<p>There are 3 kinds of hierarchical objects: <code>bank</code>, <code>register</code> and <code>field</code>. These concepts are the same as the concepts used in the DML. The class hierarchy is shown in <a class="reference" href="#hierarchical-objects">3</a>. The generic <code>HierarchicalObject</code> class serves as the abstract base class.</p>
<figure id="hierarchical-objects">
<p><img alt="" src="hierarchicalobject_classes.svg"> </p><figcaption>Figure 3. Class hierarchy for hierarchical object classes</figcaption> <p></p>
</figure>
<p>A hierarchical object is instantiated with a pointer to a <code>MappableConfObject</code> instance and a unique name. As described in the previous section, the <code>MappableConfObject</code> instance maintains a map from the hierarchical object's name to its access interface.</p>
<p>All hierarchical objects in a device should have a unique name that begins with the bank's name. The name should consist of a sequence of characters from the character set [A–Z][a–z][0–9], underscore(<code>_</code>), square brackets (<code>[]</code>) and dot (<code>.</code>). Square brackets should only be used to represent items in an array. A dot (<code>.</code>) can only be used between different hierarchical levels. For example, following names are invalid to use as a hierarchical object's name: </p>
<pre><code>.bank_x
bank[1].reg2.
_x.._y
*.reg_?.+
</code></pre>
<h4 id="bank">7.3.1 <a href="#bank">Bank</a></h4>
<p>Bank is a hierarchical object that implements the <code>simics::BankInterface</code> interface. Its main role is dispatching the incoming transaction access to the corresponding registers on the bank. The entry point for the transaction access is the function <code>transaction_access</code>.</p>
<p>Simics configuration objects for bank instances are named like the bank but with a <code>bank</code> prefix. For instance, if a device class has added a bank with declaration <code>bank.regs[2]</code>, and a device instance is named <code>dev</code> in Simics, then the two banks are represented in Simics by configuration objects named <code>dev.bank.regs[0]</code> and <code>dev.bank.regs[1]</code>.</p>
<h4 id="register">7.3.2 <a href="#register">Register</a></h4>
<p>A register is an object that contains an integer value. Normally, a register corresponds to a segment of consecutive locations in the address space of the bank; however, it is also possible (and often useful) to have registers that are not mapped to any address within the bank. All registers must be part of a register bank.</p>
<p>The following information is needed in order to map a register to an address space of the enclosing bank.</p>
<ul>
<li>Name </li>
<li>Description </li>
<li>Offset </li>
<li>Size </li>
<li>Initial value </li>
<li>Fields(could be empty) </li>
</ul>
<p>The name of a register follows the Simics naming rules. Description is a short description of the register. Offset is the address of the bank where the register is mapped at. The size is an integral, nonzero number of 8-bit bytes. A single register cannot be wider than 8 bytes. The initial value defines the register's value when the object is created. A register may be optionally divided into several fields. The fields are described in the next section.</p>
<p>To indicate an array, similar to a C array, specify the number of registers between a pair of square brackets, e.g., <code>r[8]</code>. By default the stride of the array is the size of the register, but other values can be chosen as follows, <code>r[8 stride 4]</code>. For multidimensional array, the default stride is deduced from the size of all the registers in the inner dimension. For example, the stride of the outmost dimension for <code>r[2][8 stride 4]</code> is 8 * 4 = 32 bytes.</p>
<h5 id="register-attribute">7.3.2.1 <a href="#register-attribute">Register Attribute</a></h5>
<p>For every register, an attribute of integer type is automatically added to the containing bank. The name of the register is used as the name of the attribute; e.g., a register named <code>r1</code> will get a corresponding attribute on the bank named <code>r1</code>. The register value is automatically saved when Simics creates a checkpoint.</p>
<h5 id="not-mapping-addresses-to-registers">7.3.2.2 <a href="#not-mapping-addresses-to-registers">Not Mapping Addresses To Registers</a></h5>
<p>An important thing to note is that registers do not have to be mapped at all. This may be useful for internal registers that are not directly accessible from software. By using an unmapped register, you can get the advantages of using register, such as automatic checkpointing and register fields. This internal register can then be used from the implementations of other registers, or other parts of the model. For simply storing state, consider using bank port attributes instead.</p>
<p>Please note that <code>register_view</code> interface and breakpoints only work on mapped registers.</p>
<p>To create an unmapped register, simply instantiate a register of type <code>UnmappedRegister</code> (or a subtype of it).</p>
<h4 id="field">7.3.3 <a href="#field">Field</a></h4>
<p>Real hardware registers often have a number of fields with separate meaning. For example, the lowest three bits of the register could be a status code, the next six bits could be a set of flags, and the rest of the bits could be reserved.</p>
<p>To make this easy to express, a <code>register</code> object can contain a number of <code>field</code> objects. Each <code>field</code> corresponds to a bit range of the enclosing register.</p>
<p>The value of a field is stored in the corresponding bits of the containing register's storage. The easiest way to access the value of a register or field is to use the <code>get</code> and <code>set</code> methods.</p>
<p>To indicate an array, similar to a C array, specify the number of fields between a pair of square brackets, e.g., <code>f[8]</code>. By default the stride of the array is the size of the field, but other values can be chosen as follows, <code>f[8 stride 4]</code>. For multidimensional array, the default stride is deduced from the size of all the fields in the inner dimension. For example, the stride of the outmost dimension for <code>f[2][8 stride 4]</code> is 8 * 4 = 32 bits.</p>
<h4 id="standard-templates">7.3.4 <a href="#standard-templates">Standard Templates</a></h4>
<p>This chapter describes the standard templates for C++ registers and fields.</p>
<p>Note that many standard templates have the same functionality and only differ by name or log-messages printed when writing or reading them. The name of the template helps developers to get a quick overview of the device functionality. Two such examples are the <code>undocumented</code> and <code>reserved</code> templates. Both have the same functionality. However, the <code>undocumented</code> template hints that something in the device documentation is unclear or missing, and the <code>reserved</code> template that the register or field should not be used by software.</p>
<p>Software reads and writes are defined as accesses using the <code>transaction</code> interface (write/reads to memory/io mapped device). Software reads and writes use the built-in <code>read</code> and <code>write</code> methods. Hardware access is defined as access made from within the model itself, using either <code>set/get</code> for side-effect free access or <code>read/write</code> for an access with side-effects.</p>
<h5 id="templates-for-banks">7.3.4.1 <a href="#templates-for-banks">Templates for banks</a></h5>
<p>The default class <code>Bank</code> models a bank of little endian byte order. To model a big endian byte order bank, the class <code>BigEndianBank</code> can be used. It does not affect the internal data representation, only matters when the data is read out and presented in some format. For example, the <code>Bank</code> method <code>read</code> returns a vector of <code>uint8_t</code>. The output of this method is by default a little endian byte ordered vector of bytes, while a big endian byte order bank has the order reversed.</p>
<p>By default, reading an address range on a bank which is not fully mapped by registers triggers <code>unmapped_read</code>. It prints a spec-violation log and fail the read transaction. This behavior can be altered by using class <code>MissPatternBank</code>. Its constructor takes an extra third parameter called <code>miss_pattern</code> which is used to fill the unmapped bytes in the read transaction. With this, the function <code>unmapped_read</code> is not triggered, thus no spec-violation log is printed and the read transaction does not fail. This parameter defaults to zero if not set.</p>
<h5 id="templates-for-registers-and-fields">7.3.4.2 <a href="#templates-for-registers-and-fields">Templates for registers and fields</a></h5>
<p>The read and write behaviour of registers and fields is in most cases controlled by class inheritance and method overriding. The <code>read</code> and <code>write</code> provided in <code>Register</code> and <code>Field</code> is virtual and can be override by an implementation in a derived class. The default implementation can still be referenced using a explicit namespace from the base class.</p>
<p>The following templates are provided and most of them can be applied to both registers and fields. The section use <code>object</code> as a combined name for registers and fields. Most of them affect either the write or read operation; if applied on a register it will disregard fields. For instance, when inheriting from the <code>ReadUnimplRegister</code> class on a register with fields, then the read will ignore any implementations of read overrides in fields, and return the current register value (through <code>get</code>). However, writes will still propagate to the fields.</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>Class name</td><td>Description</td><td>Log output</td></tr>
<tr><td><code>IgnoreWriteRegister</code>, <code>IgnoreWriteField</code></td><td>Writes are ignored. This template might also be useful for read-only fields inside an otherwise writable register. See the documentation for the <code>ReadOnlyRegister</code> template for more information.</td><td>/</td></tr>
<tr><td><code>Read0Register</code>, <code>Read0Field</code></td><td>Reads return 0, regardless of register/field value. Writes are unaffected by this template.</td><td>/</td></tr>
<tr><td><code>ReadOnlyRegister</code>, <code>ReadOnlyField</code></td><td>The object value is read-only for software, the object value can be modified by hardware.</td><td>First software write results in a spec_violation log-message on log-level 1, remaining writes on log-level 2. Fields will only log if the written value is different from the old value. <br><br> If the register containing the read-only field also contains writable fields, it may be better to use the <code>IgnoreWriteRegister</code> template instead, since software often do not care about what gets written to a read-only field, causing unnecessary logging.</td></tr>
<tr><td><code>WriteOnlyRegister</code>, <code>WriteOnlyField</code></td><td>The register/field value can be modified by software but can't be read back, reads return 0 regardless of register/field value. Writes are unaffected by this template.</td><td>For register, the first time the object is read there is a spec_violation log-message on log-level 1, remaining reads on log-level 2. For field, only logs on log-level 4.</td></tr>
<tr><td><code>Write1ClearsRegister</code>, <code>Write1ClearsField</code></td><td>Software can only clear bits. This feature is often used when hardware sets bits and software clears them to acknowledge. Software write 1's to clear bits. The new object value is a bitwise AND of the old object value and the bitwise complement of the value written by software.</td><td>/</td></tr>
<tr><td><code>ClearOnReadRegister</code>, <code>ClearOnReadField</code></td><td>Software reads return the object value. The object value is then reset to 0 as a side-effect of the read.</td><td>/</td></tr>
<tr><td><code>Write1OnlyRegister</code>, <code>Write1OnlyField</code></td><td>Software can only set bits to 1. The new object value is the bitwise OR of the old object value and the value written by software.</td><td>/</td></tr>
<tr><td><code>Write0OnlyRegister</code>, <code>Write0OnlyField</code></td><td>Software can only set bits to 0. The new object value is the bitwise AND of the old object value and the value written by software.</td><td>/</td></tr>
<tr><td><code>ReadConstantRegister</code>, <code>ReadConstantField</code></td><td>Reads return a constant value. <br><br> Writes are unaffected by this template. The read value is unaffected by the value of the register or field. <br><br> The template is intended for registers or fields that have a stored value that is affected by writes, but where reads disregard the stored value and return a constant value. The attribute for the register will reflect the stored value, not the value that is returned by read operations. For constant registers or fields that do not store a value, use the <code>Constant</code> template instead.</td><td>/</td></tr>
<tr><td><code>ConstantRegister</code>, <code>ConstantField</code></td><td>Writes are forbidden and have no effect. <br><br> The object still has backing storage, which affects the value being read. Thus, an end-user can modify the constant value by writing to the register's attribute. Such tweaks will survive a reset. <br><br> Using the <code>Constant</code> template marks that the object is intended to stay constant, so the model should not update the register value, and not override the <code>read</code> method. Use the template <code>ReadOnly</code> if that is desired.</td><td>First write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td><code>SilentConstantRegister</code>, <code>SilentConstantField</code></td><td>The object value will remain constant. Writes are ignored and do not update the object value. <br><br> The end-user can tweak the constant value; any tweaks will survive a reset. <br><br> By convention, the object value should not be modified by the model; if that behaviour is wanted, use the <code>IgnoreWrite</code> template instead.</td><td>/</td></tr>
<tr><td><code>ZerosRegister</code>, <code>ZerosField</code></td><td>The object value is constant 0. Software writes are forbidden and do not update the object value.</td><td>First software write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td><code>OnesRegister</code>, <code>OnesField</code></td><td>The object is constant all 1's. Software writes do not update the object value. The object value is all 1's.</td><td>First software write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td><code>IgnoreRegister</code>, <code>IgnoreField</code></td><td>The object's functionality is unimportant. Reads return 0. Writes are ignored.</td><td>/</td></tr>
<tr><td><code>ReservedRegister</code>, <code>ReservedField</code></td><td>The object is marked reserved and should not be used by software. Writes update the object value. Reads return the object value.</td><td>First software write to register or field (if field value is not equal to write value) results in a `spec-viol` log-message on log-level 2. No logs on subsequent writes.</td></tr>
<tr><td><code>UnimplRegister</code>, <code>UnimplField</code></td><td>The object functionality is unimplemented. Warn when software is using the object. Writes and reads are implemented as default writes and reads.</td><td>First read from a register results in an unimplemented log-message on log-level 1, remaining reads on log-level 3. Reads from a field does not result in a log-message. First write to a register results in an unimplemented log-message on log-level 1, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 1, remaining writes on log-level 3.</td></tr>
<tr><td><code>ReadUnimplRegister</code>, <code>ReadUnimplField</code></td><td>The object functionality associated to a read access is unimplemented. Write access is using default implementation and can be overridden (for instance by the <code>ReadOnly</code> template).</td><td>First software read to a register results in an unimplemented log-message on log-level 1, remaining reads on log-level 3. Software reads to fields does not result in a log-message.</td></tr>
<tr><td><code>WriteUnimplRegister</code>, <code>WriteUnimplField</code></td><td>The object functionality associated to a write access is unimplemented. Read access is using default implementation and can be overridden (for instance by the <code>WriteOnly</code> template).</td><td>First software write to registers results in an unimplemented log-message on log-level 1, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 1, remaining writes on log-level 3.</td></tr>
<tr><td><code>SilentUnimplRegister</code>, <code>SilentUnimplField</code></td><td>The object functionality is unimplemented, but do not print a lot of log-messages when reading or writing. Writes and reads are implemented as default writes and reads.</td><td>First software read to a register results in an unimplemented log-message on log-level 2, remaining reads on log-level 3. Software reads to fields does not result in a log-message. First software write to a register results in an unimplemented log-message on log-level 2, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 2, remaining writes on log-level 3.</td></tr>
<tr><td><code>UndocumentedRegister</code>, <code>UndocumentedField</code></td><td>The object functionality is undocumented or poorly documented. Writes and reads are implemented as default writes and reads.</td><td>First software write and read result in a spec_violation log-message on log-level 1, remaining on log-level 2.</td></tr>
<tr><td><code>UnmappedRegister</code></td><td>The register is excluded from the address space of the containing bank.</td><td>/</td></tr>
<tr><td><code>DesignLimitationRegister</code>, <code>DesignLimitationField</code></td><td>The object's functionality is not in the model's scope and has been left unimplemented as a design decision. Software and hardware writes and reads are implemented as default writes and reads. Debug registers are a prime example of when to use this template. This is different from <em>unimplemented</em> which is intended to be implement (if required) but is a limitation in the current model.</td><td>/</td></tr>
<tr><td><code>AliasRegister</code></td><td>The register is an alias for another register. All operations are forwarded to the other register.</td><td>/</td></tr>
</tbody></table>
<h3 id="modeling-the-register-banks">7.4 <a href="#modeling-the-register-banks">Modeling the register banks</a></h3>
<p>In C++ API, two options are provided to model the register bank. They differ in how the mapping and hierarchy information is provided. For the first option, the mapping information is provided as input to class members of a class hierarchy constructed from C++ code. This will be referred to as the "by code" option. For the other option, both the mapping and hierarchy information is provided in a separate data structure. This will be referred to as the "by data" option.</p>
<h4 id="by-code-when-information-is-provided-by-the-c-classes-and-the-class-hierarchy">7.4.1 <a href="#by-code-when-information-is-provided-by-the-c-classes-and-the-class-hierarchy">By code; when information is provided by the C++ classes and the class hierarchy</a></h4>
<p>A device has one or many ports, each port has one (and only one) bank, each bank has one or many registers and each register may have one or many fields. In C++, this <em>Has-A</em> relationship is typically modelled by declaring one or more class members of the other class. This modeling methodology is used in this so-called "by code" option. Note that the port objects are registered on the device. See <a class="reference" href="#bank-port-object">7.2</a> for what is a bank port object and how to register it on the C++ device.</p>
<p>As a convenience layer, several C++ classes are provided to make the modeling easier. The <code>PortBank&lt;TBank&gt;</code> class helps to create and add a bank in a port. The <code>BankRegister&lt;TRegister&gt;</code> class helps to create and add a register in a bank. The <code>RegisterField&lt;TField&gt;</code> class helps to create and add a field in a register. The template type parameter in these classes can be used to create different type of objects. It defaults to the basic hierarchical object type, e.g., <code>TBank</code> defaults to <code>simics::Bank</code>. The parameter can be any of the provided classes like <code>ReadOnlyRegister</code> or it could be a user defined class. See <a class="reference" href="#standard-templates">7.3.4</a> for complete list of the provided classes.</p>
<p>The classes for the bank, register and field can be nested using C++ <em>nested class</em> but it is not required to do so. This code style helps to reduce the scope of the nested class and makes it look similar to how a corresponding DML device would look like.</p>
<p>Below is an example using this option. Note that only the part related with the mapping information registration is shown. </p>
<p>
</p><pre><code>// example bank with a register
class SampleBankPort : public simics::BankPort&lt;SampleDevice&gt; {
  public:
    using BankPort&lt;SampleDevice&gt;::BankPort;

  private:
    SampleBank b {this, Description("a user defined bank")};
};

void SampleDevice::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::make_bank_port&lt;SampleBankPort&gt;(
                     cls-&gt;name() + ".SampleBank", "sample bank"), "bank.b[2]");
</code></pre>
<p></p>
<p>With this option, the hierarchy of port, bank, register and field is embedded in the C++ class. Both the mapping information and the behavior are provided in the code when creating the object. This option is referred to as "by code" option.</p>
<h4 id="by-data-when-information-is-provided-as-a-struct">7.4.2 <a href="#by-data-when-information-is-provided-as-a-struct">By data; when information is provided as a struct</a></h4>
<p>In the second option, the bank/register/field resource mapping information is provided as <em>data</em> using an arbitrary format. A data importer needs to convert the data and call the C++ device API to register the mapping. This keeps the resource mapping separated from its behavior and makes it possible for user to write their own generator to generate the data in the required format. This also makes it possible to create an importer that reads the data from a file, allowing the mapping to be changed without recompiling the model.</p>
<div class="note">
<b>Note:</b>
No ready-to-use generators are provided in the Simics package; only the API to register the mapping produced by the user-defined generator.
</div>
<p>The API method to register the mapping is <code>create_hierarchy_from_register_data</code>. The first function parameter type is a pointer to <code>ConfClass</code>. The second function parameter type can be either <code>simics::bank_t</code> or braced-init-list of <code>simics::bank_t</code>. Since the API method must be invoked when the module is loaded into Simics, the most suitable place to call it is <code>init_class</code>. It can be invoked multiple times with different register data. The address of the <code>simics::bank_t</code> variable is saved in the device class and used for creating the device instance. This requires the register information being accessible through the lifetime of the Simics session. One way to achieve this is define the bank information as a global const variable.</p>
<p>The required type <code>simics::bank_t</code> is used to describe the bank's information including name of the bank, description of the bank and the registers information on the bank. The register information is defined using <code>simics::register_t</code>. It includes name, description, memory address offset, size in bytes, initialized value and the fields information of the register. The field information is defined using <code>simics::field_t</code>. It includes name, description, bit offset and bit width of the field.</p>
<p>Using the second option, without user defined behaviors, a C++ model with default read/write behavior can be run in a Simics simulation. To change the default behavior, user can either use a standard class provided in the modeling library or subclass it. See <a class="reference" href="#standard-templates">7.3.4</a> for a complete list of the standard classes. If no customized behavior is registered, the default base class for the corresponding resource is used.</p>
<p>Below is an example using this option. The mapping information for the <code>SampleDeviceWithRegisterAsData</code> is registered by calling the method <code>import_data</code> from a data importer. Within the method, <code>create_hierarchy_from_register_data</code> is called with the mapping data. Each resource in the example will be assigned the default behavior (read and write) except for registers <code>b[0].r[0]</code>, <code>b[0].r[1]</code>, <code>b[1].r[0]</code> and <code>b[1].r[1]</code> which are defined as a custom write-clear register.</p>
<div class="note">
<b>Note:</b>
This example shows how to provide a customized subclass; for write-clear there is already a <tt>Write1ClearsRegister</tt> class in the modeling library.
</div>
<p>
</p><pre><code>#include &lt;simics/cc-modeling-api.h&gt;

#include "register-as-data.h"

class SampleRegister : public simics::Register {
  public:
    using Register::Register;

    class SampleField : public simics::Field {
      public:
        using Field::Field;

        void write(uint64_t value, uint64_t enabled_bits) override {
            const char *msg = "Write to SampleField";
            SIM_LOG_INFO(3, bank_obj_ref(), 0, "%s", msg);
            return simics::Field::write(value, enabled_bits);
        }
    };

    uint64_t read(uint64_t enabled_bits) override {
        return 42;
    }

  private:
    SampleField f0 {dev_obj(), hierarchical_name() + ".f0"};
};

class DataImporter {
  public:
    explicit DataImporter(simics::MappableConfObject *obj)
        : obj_(obj) {}

    template &lt;typename T&gt;
    static void import_data(simics::ConfClass *cls) {
        simics::create_hierarchy_from_register_data&lt;T&gt;(cls, register_as_data);
    }

  private:
    simics::MappableConfObject *obj_;
    SampleRegister b0_r0 {obj_, "b[0].r[0]"};
    SampleRegister b0_r1 {obj_, "b[0].r[1]"};
    SampleRegister b1_r0 {obj_, "b[1].r[0]"};
    SampleRegister b1_r1 {obj_, "b[1].r[1]"};
};
</code></pre>
<p></p>
<p>
</p><pre><code>#include &lt;simics/cc-api.h&gt;
#include &lt;simics/cc-modeling-api.h&gt;
#include &lt;iostream&gt;
#include "data-importer.h"

class SampleDeviceWithRegisterAsData : public simics::MappableConfObject,
                                       public DataImporter {
  public:
    explicit SampleDeviceWithRegisterAsData(simics::ConfObjectRef obj)
        : MappableConfObject(obj),
          DataImporter(this) {}

    static void init_class(simics::ConfClass *cls) {
        DataImporter::import_data&lt;SampleDeviceWithRegisterAsData&gt;(cls);
    }
};

extern "C" void init_sample_device_with_register_as_data() try {
    simics::make_class&lt;SampleDeviceWithRegisterAsData&gt;(
            "sample_device_cpp_with_register_as_data",
            "sample C++ device",
            "This is a sample Simics device written in C++.");
} catch(const std::exception&amp; e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
}
</code></pre>
<p></p>
<p>In Simics, the device model is instantiated before the port objects. Thus the hierarchical objects defined in the device model are instantiated first. Hierarchical objects with same name can be instantiated multiple times. The behavior is then defined by the last instantiation based on C++ object instantiation order.</p>
<p>The instantiation of the default behavior hierarchical objects happens during the instantiation of the port object if there is no behavior already defined for them. They are allocated on the heap memory.</p>
<h2 id="attributes">8 <a href="#attributes">Attributes</a></h2>
<p>Unlike previous C++ API, there is only one way to define attributes. The attribute is defined by creating an object of type <code>Attribute</code> and adding it to the <code>ConfClass</code> instance using the <code>add</code> function.</p>
<p>There are several constructors with different sets of parameters. The following parameters must be provided for all constructors: a string <code>name</code>, a string <code>type</code> and a string <code>doc</code>. These parameters have the same meaning as in <code>SIM_register_attribute</code>. The <code>name</code> specifies the attribute name, and must be unique for the class and stable between revisions of the model. The <code>type</code> is the type which describes the data type of the attribute, and should also be stable between revisions of the model to support Simics configuration scripts and checkpointing. The macro <code>ATTR_TYPE_STR</code> can be used to auto generate the type string from a C++ variable. The <code>doc</code> describes the attribute.</p>
<p>Get and set callbacks can be registered for the attribute through <code>getter</code> and <code>setter</code> parameters. For a C++ class member variable, <code>AttributeAccessor</code> can be used for the registration.</p>
<p>There is an optional <code>attr</code> parameter which is one of <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code> or <code>Sim_Attr_Pseudo</code>. This can be used to indicate that an attribute is required (<code>Sim_Attr_Required</code>) or that it should not be part of checkpoints (<code>Sim_Attr_Pseudo</code>). The default value is <code>Sim_Attr_Optional</code> if no explicit value is set.</p>
<p>Depending on how the state variable is stored in the C++ class, there are different ways to register the attribute.</p>
<p>
</p><pre><code>class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("value", "i", "A value.",
                                   ATTR_CLS_VAR(sample_instance, value)));
    }

    int value;
};
                        //...
extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
            "sample_simple_attrib",
            "simple attribute", "...");
}
</code></pre>
<p></p>
<p>This example uses <code>ATTR_CLS_VAR(sample_instance, value)</code> to locate the state variable, given an instance of <code>sample_instance</code>. The macro <code>ATTR_CLS_VAR</code> expands to an <code>AttributeAccessor</code>.</p>
<p>A public state variable member of a C++ build-in type or a C++ standard container of build-in type can be registered directly using <code>ATTR_CLS_VAR</code>. For example, an <code>array</code> of two boolean values.</p>
<p>
</p><pre><code>class sample_flag : public simics::ConfObject {
  public:
    explicit sample_flag(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("flags", "[bb]", "Two boolean flags in a list",
                                   ATTR_CLS_VAR(sample_flag, flags)));
    }

    std::array&lt;bool, 2&gt; flags {false, false};
};

extern "C" void init_local() {
    simics::make_class&lt;sample_flag&gt;(
            "sample_flag",
            "sample flag device",
            "N/A");
}
</code></pre>
<p></p>
<p>If a state variable is not in public scope, indirect access is needed. It is quite common that a C++ class provides a public get and set function for its private state variable member. To register the variable as a Simics attribute, simply wrap the public get and set function pointers using macro <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> respectively and pass them as the parameters to the <code>Attribute</code> constructor.</p>
<p>
</p><pre><code>class sample_get_set_attrib : public simics::ConfObject {
  public:
    explicit sample_get_set_attrib(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                         "value", "i", "A value.",
                         ATTR_GETTER(sample_get_set_attrib, get_value),
                         ATTR_SETTER(sample_get_set_attrib, set_value)));
    }

    int get_value() const;
    void set_value(const int &amp;v);

  private:
    int value;
};

// ...

int sample_get_set_attrib::get_value() const {
    return value;
}

void sample_get_set_attrib::set_value(const int &amp;v) {
    if (v &lt; 256) {
        value = v;
    } else {
        throw std::runtime_error("Too large value");
    }
}

extern "C" void init_local() {
    simics::make_class&lt;sample_get_set_attrib&gt;(
            "sample_get_set_attrib",
            "sample get/set attribute device",
            "N/A");
}
</code></pre>
<p></p>
<p>By wrapping the value with functions, it is also possible to add extra checks. The getter function simply returns the value. The setter function takes a reference to a value, and can accept or reject it by throwing a runtime_error with a string message describing why it was rejected. The exception is caught in the Simics attribute setter function and converted to a proper Simics log message.</p>
<p>The getter and setter functions can be global functions as well. Then they should take the main C++ object as a function parameter.</p>
<p>
</p><pre><code>class sample_proxy_attrib : public simics::ConfObject {
  public:
    explicit sample_proxy_attrib(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls);

    void set_hidden_value(int v) { value = v; }
    const int &amp;get_hidden_value() const { return value; }

  private:
    int value;
};

// ...

int get_value(const sample_proxy_attrib &amp;obj) {
    return -obj.get_hidden_value();
}

void set_value(sample_proxy_attrib &amp;obj, const int &amp;v) {
    obj.set_hidden_value(-v);
}

void sample_proxy_attrib::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("value", "i", "A value.",
                               ATTR_GETTER(get_value),
                               ATTR_SETTER(set_value)));
}

extern "C" void init_local() {
    simics::make_class&lt;sample_proxy_attrib&gt;(
            "sample_proxy_attrib",
            "sample proxy attributes device",
            "N/A");
}
</code></pre>
<p></p>
<p>The same macros, <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> are used to help convert getters and setters into the functions required by the Simics attribute.</p>
<p>If the getter is <code>nullptr</code>, it means that the attribute is write-only. If the setter is <code>nullptr</code>, it means that it is read-only. If either is <code>nullptr</code>, the attribute cannot be checkpointed and if <code>attr</code> is left out, <code>Sim_Attr_Pseudo</code> is automatically chosen.</p>
<h3 id="creating-custom-get-and-set-functions">8.1 <a href="#creating-custom-get-and-set-functions">Creating Custom get and set functions</a></h3>
<p>The help macros <code>ATTR_CLS_VAR</code>, <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> support all C++ native build-in types or STL containers that consist of them. A complete list of equivalent types supported by the help macros are listed in the following table. The pointer, the C++ containers including <code>array</code>, <code>list</code>, <code>vector</code>, <code>deque</code>, <code>pair</code>, <code>map</code>, the <code>enum</code> are supported if the underlying type is one of the types listed in the table.</p>
<table><thead><tr><th><strong>Boolean type</strong></th><th><strong>Character types</strong></th><th><strong>Integer types</strong></th><th><strong>Floating-point types</strong></th><th><strong>Object type</strong></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>char</code>, <code>signed char</code>, <code>unsigned char</code></td><td><code>short int</code>, <code>unsigned short int</code>, <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>, <code>long long int</code>, <code>unsigned long long int</code></td><td><code>float</code>, <code>double</code></td><td><code>simics::ConfObjectRef</code>, <code>simics::Connect</code></td></tr>
</tbody></table>
<div class="note">
<b>Note:</b>
Traditional C-style arrays, or Raw Arrays, are not supported by the help macros. Either replace them with C++ <tt>array</tt>, or use custom get and set functions as described below. 
</div>
<p>For other types not listed here, including user defined types, it is possible to create custom get and set functions. For example, the model may need to use a traditional C-style array of integers. All that is required to perform this translation is to create new get and set functions and implement them as shown in the example below: </p>
<p>
</p><pre><code>#include &lt;simics/cc-api.h&gt;

class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
            : simics::ConfObject(o) {
        value[0] = 0;
        value[1] = 0;
    }

    static void init_class(simics::ConfClass *cls);

    int value[2];
};

attr_value_t get_value(conf_object_t *obj) {
    auto *o = simics::from_obj&lt;sample_instance&gt;(obj);
    return SIM_make_attr_list(
            2,
            SIM_make_attr_uint64(o-&gt;value[0]),
            SIM_make_attr_uint64(o-&gt;value[1]));
}

set_error_t set_value(conf_object_t *obj, attr_value_t *attr) {
    auto *o = simics::from_obj&lt;sample_instance&gt;(obj);
    o-&gt;value[0] = SIM_attr_integer(SIM_attr_list_item(*attr, 0));
    o-&gt;value[1] = SIM_attr_integer(SIM_attr_list_item(*attr, 1));
    return Sim_Set_Ok;
}

void sample_instance::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("value", "[ii]", "A value.",
                               &amp;get_value, &amp;set_value));
}

extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
            "sample_custom_get_set",
            "sample custom get&amp;set functions", "...");
}
</code></pre>
<p></p>
<h3 id="calling-interfaces-on-connected-configuration-objects">8.2 <a href="#calling-interfaces-on-connected-configuration-objects">Calling interfaces on connected configuration objects</a></h3>
<p>To call a Simics interface on another configuration object, the other object must be <code>connected</code> with the current object. This connection is represented by having an attribute that points to the other object. The attribute is then used to extract the interface pointer used in the interface call.</p>
<p>The template based class <code>Connect</code> performs these two things; it defines an attribute that can take an object (explicit registration of this attribute is still needed) and it extracts the interfaces requested from this object. If the object passed to the attribute does not provide all required interfaces a Simics log message is emitted indicating which interface is missing and the <code>set</code> ignores the object passed. The <code>Connect</code> class optionally takes a parameter of type <code>ConnectConfig</code>. It can be used to specify optional interfaces.</p>
<div class="note">
<b>Note:</b>
The Simics interface is a C struct data type of function pointers. It can be fetched by invoking <tt>ConfObjectRef::get_interface()</tt> function. The <tt>Connect</tt> class caches the interface as a member variable for performance reasons.
</div>
<p>The following code will create an <code>irq_dev</code> attribute that only accepts objects implementing the <code>SimpleInterruptInterface</code> as a value. The object can optionally implement <code>SignalInterface</code>. </p>
<p>
</p><pre><code>#include &lt;simics/c++/devs/signal.h&gt;
#include &lt;simics/c++/devs/interrupt.h&gt;

class sample_connect : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;  // re-use the Base-class CTOR

    void objects_finalized() override;  // use the connect after finalize

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("irq_dev", "o|n",
                                   "IRQ device",
                                   ATTR_CLS_VAR(sample_connect, irq_dev)));
    }

    simics::Connect&lt;simics::iface::SimpleInterruptInterface,
                    simics::iface::SignalInterface&gt; irq_dev {
        simics::ConnectConfig::optional&lt;simics::iface::SignalInterface&gt;()
    };
};
</code></pre>
<p></p>
<p>If the attribute is set to an object, that object is guaranteed to implement the <code>SimpleInterruptInterface</code> interface but not required to implement <code>SignalInterface</code> interface. So using that optional interface requires an extra check by checking if the interface is implemented. </p>
<p>
</p><pre><code>void sample_connect::objects_finalized() {
    if (irq_dev) {
        if (irq_dev.iface&lt;simics::iface::SignalInterface&gt;().get_iface()) {
            irq_dev.iface&lt;simics::iface::SignalInterface&gt;().signal_raise();
        } else {
            irq_dev.iface().interrupt(0);
        }
    }
}
</code></pre>
<p></p>
<p>The Simics C++ interface struct is fetched through a template based function <code>iface</code>. The template parameter can be omitted when fetching the first interface type of the template parameter list. </p>
<pre><code>    if(target_dev) {
        target_dev.iface&lt;simics::iface::PulseInterface&gt;().pulse();
        target_dev.iface().signal_raise();
    }
</code></pre>
<h2 id="logging">9 <a href="#logging">Logging</a></h2>
<p>Logging from within a Simics module written in C++ should, for performance reasons, use the logging macros.</p>
<p>There are two types of macros:
the basic <code>SIM_LOG_&lt;type&gt;()</code> macros provided by Simics supporting C types and printf-like formatting.
the extended <code>SIM_LOG_&lt;type&gt;_STR()</code> macros provided by Simics C++ API supporting C++ string-like objects.
Both type of macros will invoke the corresponding <code>SIM_log_&lt;type&gt;()</code> functions internally, but is wrapped in an additional layer that does not expand the code if log-level is not enough.</p>
<p>The macros expect:</p>
<ul>
<li>1st argument is the log-level/verbosity</li>
<li>2nd argument is the log object</li>
<li>3rd argument is the log group (can be ORd to log for multiple groups)</li>
<li>4th argument is the message.</li>
<li>For the C macros 5+ arguments are varargs for the printf-like formatting passed as 4th argument</li>
</ul>
<p>An example using C++ logging:
</p><pre><code>    /// Logging with SIM_LOG_&lt;type&gt;_STR
    void logging_by_cc_macro() {
        SIM_LOG_SPEC_VIOLATION_STR(4, obj(), 0,
                                   fmt::format("The class contains an unsigned"
                                               " integer ({}), a string ({}) and"
                                               " a vector of float ({})",
                                               an_unsigned, a_str,
                                               fmt::join(a_float_vector, ", ")));
    }
</code></pre>
<p></p>
<p>An example using C logging:
</p><pre><code>    /// Logging with SIM_LOG_&lt;type&gt;
    void logging_by_c_macro() {
        SIM_LOG_INFO(4, obj(), 0,
                     "The class contains an unsigned integer (%d),"
                     " a string (%s) and a vector of float (%f, %f)",
                     an_unsigned, a_str.c_str(), a_float_vector[0],
                     a_float_vector[1]);
    }
</code></pre>
<p></p>
<h2 id="event">10 <a href="#event">Event</a></h2>
<p>Event is useful to let something happen only after a certain amount of (simulated) time. By posting an event on a queue, a callback function is placed on the queue and will be called later in the simulation. The amount of time can be specified in different units, e.g, seconds, cycles or steps.</p>
<p>Event support in the C++ API contains several aspects: Declare the behavior of an event, register the event, define and manage it. </p>
<h3 id="declare-the-behavior-of-an-event">10.1 <a href="#declare-the-behavior-of-an-event">Declare the behavior of an event</a></h3>
<p>The callback is defined in an user defined event class. Depends on the <em>timebase</em>, it should inherit from one of the following Simics provided classes: <strong>simics::TimeEvent</strong>, <strong>simics::CycleEvent</strong> and <strong>simics::StepEvent</strong>. A simple example event class looks like this:</p>
<p>
</p><pre><code>    class UserTimeEvent : public simics::TimeEvent&lt;sample_event&gt; {
      public:
        explicit UserTimeEvent(simics::ConfObject *obj)
            : TimeEvent(obj, event_cls) {}

        inline static event_class_t *event_cls = nullptr;

        void callback(lang_void *data = nullptr) override {
            dev_-&gt;some_side_effects();
        }
    };
</code></pre>
<p></p>
<p>There are several requirements on the event class:</p>
<ol>
<li>
<p>The base class <strong>simics::TimeEvent</strong> is a template class. The template type is used as the type of class member variable <strong>dev_</strong> which is a pointer to the C++ device class contains this event. Thus the template type should be the type of the C++ device class.</p>
</li>
<li>
<p>The event class should have a constructor taking a pointer of object reference (<strong>simics::ConfObject</strong>).</p>
</li>
<li>
<p>The event class should have a static class member variable with the name <strong>event_cls</strong>. This fixed name is later used by some MACROs when registering the event. </p>
</li>
<li>
<p>The static variable <strong>event_cls</strong> should be passed to the constructor of the base class <strong>simics::TimeEvent</strong>. This is a pointer to the <strong>event_class_t</strong> used in the calls to the Simics API. Most user code doesn't need to access this, but it can be used when calling the Simics Event API functions directly.</p>
</li>
<li>
<p>The event class should override method <strong>callback</strong>. This method is called when the event is triggered.</p>
</li>
</ol>
<p>It is optional to override following methods:</p>
<ol>
<li><code>void destroy(void *data)</code> is called when the event is removed from the queue without being called.</li>
<li><code>attr_value_t get_value(void *data)</code> is called to convert the event data into a value that can be saved in a configuration.</li>
<li><code>void *set_value(attr_value_t value)</code> is called to convert a configuration value into event data.</li>
<li><code>char *describe(void *data)</code> is called to generate a human-readable description of the event to be used in the <strong>print-event-queue</strong> command.</li>
</ol>
<h3 id="register-the-event">10.2 <a href="#register-the-event">Register the event</a></h3>
<p>The event registration is done by calling <strong>add</strong> on the <strong>ConfClass</strong> object. See an example of how to register an event.</p>
<p>
</p><pre><code>    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::EventInfo("user_event",
                                   EVENT_CALLBACK(sample_event,
                                                  user_event)));
    }
</code></pre>
<p></p>
<p>An object of type <code>simics::EventInfo</code> is constructed with the event registration information and passed to the <strong>add</strong> function. Internally, registration is done with <strong>SIM_register_event</strong>; see the documentation for that API function for detailed information.</p>
<p>The <code>simics::EventInfo</code> class has two constructors. The first one <code>EventInfo(name, ev, callback)</code> has 3 parameters. The <strong>name</strong> parameter specified the name of the registered Simics event class. The <strong>ev</strong> points to the declared static member <strong>event_cls</strong> in the C++ event class. The <strong>callback</strong> is a function pointer of the callback. The latter two parameters can be replaced by a help MACRO <strong>EVENT_CALLBACK</strong> which takes the C++ device class and the defined event variable's name.</p>
<p>The other constructor takes 8 parameters, see the documentation for API <strong>SIM_register_event</strong> for the detailed parameter information. The latter 6 parameters can be replaced by another help MACRO <strong>EVENT_CLS_VAR</strong> which takes the C++ device class and the defined event variable's name.</p>
<h3 id="define-and-manage-the-event">10.3 <a href="#define-and-manage-the-event">Define and manage the event</a></h3>
<p>An event is defined as a class member variable which is created when creating a device object. The event object is initialized with the <strong>this</strong> pointer which is used to point back to the device object. See an example of how to define an event.</p>
<p>
</p><pre><code>    UserTimeEvent user_event {this};
</code></pre>
<p></p>
<p>Events are posted with the <code>post(duration)</code> method. The <strong>duration</strong> parameter is the number of seconds, cycles, or steps until the event triggers, depends on the event class type. See an example of how to post an event.</p>
<p>
</p><pre><code>        user_event.post(1.0);
</code></pre>
<p></p>
<p>Events can be cancelled before they trigger with the <code>remove(match_data)</code> method. The <strong>match_data</strong> argument is optional: if given, it should be an event data used to match a particular event. if not given, all events are cancelled.</p>
<p>Besides <strong>post</strong> and <strong>remove</strong>, user can also use <code>posted(match_data)</code> to check if an event has been posted and <code>next(match_data)</code> to fetch the time to the next event on the queue.</p>
<h2 id="utilities">11 <a href="#utilities">Utilities</a></h2>
<h3 id="generator-of-simics-c-interface-header">11.1 <a href="#generator-of-simics-c-interface-header">Generator of Simics C++ interface header</a></h3>
<p>The file <code>bin/gen-cc-interface</code> (or <code>bin/gen-cc-interface.bat</code> on Windows) is used to generate a Simics C++ interface header which is used for a Simics C++ module from the given Simics C interface header. Required argument is the path to the C interface header file.</p>
<p>For instance the following line specifies that <code>example.h</code> should be parsed by the tool and converted to a C++ interface header file. </p>
<pre><code>  project&gt; bin/gen-cc-interface modules/example-interface/example.h
</code></pre>
<p>The generator parses the C interface header, searches for <code>SIM_INTERFACE</code> and generates corresponding C++ interface class to the output C++ header file.</p>
<p>By default, the output C++ interface header is generated under <em>c++</em> subdirectory of where the input C header file is located. This can be altered by providing an optional argument by <code>-o</code> with the desired output location.</p>
<p>By default, the following code is generated to locate the original C interface header in the parent folder: </p>
<pre><code>    #include "../c-header.h"
</code></pre>
<p>When <code>-o</code> is used, the desired include path must be provided by the optional argument <code>-p</code>.</p>
<!--- begin documentation from C++ extension --->
<!--- if updated, please push changes upstream --->
<h2 id="simics-c-api-modeling-extension">12 <a href="#simics-c-api-modeling-extension">Simics C++ API Modeling Extension</a></h2>
<p>The Simics C++ API Modeling Extension (SME) complements the Simics C++ API but is not required for modeling.  The SME adds notification rules, expression logic rules &amp; state machine modeling (using Boost SML) to create a comprehensive behavioral modeling method which can ease the implementation of complex hardware modules.</p>
<h3 id="scaffolding">12.1 <a href="#scaffolding">Scaffolding</a></h3>
<p>Additional information is required by the SME to facilitate consistent execution order of notifications between Register &amp; Field rules which exist for the same field.  Scaffolding provides these mechanics by introducing logic on read/write methods which determines the origin of execution and ensure consistent ordering of rules along with some additional book-keeping.</p>
<p>To enable SME the developer will wrap any register type with <code>sme::reg&lt;&gt;</code> or <code>sme::field&lt;&gt;</code> as appropriate.  Using this approach also allows the developer  to selectively add the CEA capability only to those registers where notification rules are useful.</p>
<div class="note">
<p>WARNING: When enabling SME for any entity, the register and all fields associated must be wrapped or the code will not compile.</p>
</div>
<p><em>Register declaration example</em></p>
<pre><code>class EXAMPLE_REGISTER : public simics::BankRegister&lt; sme::reg&lt; simics::Register &gt; &gt; { ... }
</code></pre>
<p><em>Field declaration example</em></p>
<pre><code>class EXAMPLE_FIELD : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; { ... }
</code></pre>
<p>Below is a full declaration example within a <code>PortBank</code>.  Note that any <code>simics::Register</code> subtype or <code>simics::Field</code> subtype may be utilized, the <code>sme::reg</code> &amp; <code>sme::field</code> declarations enable scaffolding for notification rules without affecting type customization.</p>
<pre><code class="language-C">class SampleDevice : public simics::MappableConfObject {
public:
    explicit SampleDevice( simics::ConfObjectRef o)
        : simics::MappableConfObject(o) {
    }
    static void init_class(simics::ConfClass *cls);
};

class SampleBank : public simics::PortBank&lt;&gt; {
public:
    using PortBank::PortBank;

    class EXAMPLE_REGISTER : public simics::BankRegister&lt; sme::reg&lt; simics::Register &gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class EXAMPLE_FIELD_1 : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

            class EXAMPLE_FIELD_2 : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        EXAMPLE_FIELD_1 example_field_1 {                                
            this, simics::Name("example_field_1"),                 
            simics::Description("example_field_1"),
            simics::Offset(0), 
            simics::BitWidth(16)
        };
        EXAMPLE_FIELD_2 example_field_2 {                                
            this, simics::Name("example_field_2"),                 
            simics::Description("example_field_2"),
            simics::Offset(15), 
            simics::BitWidth(16)
        };
    };

    EXAMPLE_REGISTER example_register {
        this, simics::Name("example_register"),
        simics::Description("example_register"),
        simics::Offset(0x04),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
};

class SampleBankPort : public simics::BankPort&lt;SampleDevice&gt; {
    public:
    using BankPort&lt;SampleDevice&gt;::BankPort;

    SampleBank bank {
        this, simics::Description("Sample Bank")
    };
};
</code></pre>
<p>There is no difference to the actual device initialization code, so this modification is to declaration code only.</p>
<h3 id="notification-rules">12.2 <a href="#notification-rules">Notification Rules</a></h3>
<p>Notification rules provide a means to register a callback at a certain stage of processing register/field transactions, and may include content matching in the form of masks or patterns so that the logic is declarative in nature rather than in algorithm code.</p>
<p>Notification rules must be registered to a particular stage which determines when the rule will be evaluated.  When a notification rule resolves to true, then its associated callback is executed.</p>
<table>
    <tbody><tr>
        <td>Stage</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>sme::stage::PRE_READ</td>
        <td>Occurs prior to the actual data read taking place. <br>
        Only useful in rare cases where a check is required before allowing data to be read. <br>
        NOTE: should only utilize a rule Type of sme::type::NOTIFY, other rule type behavior is undefined.
        </td>
    </tr>
    <tr>
        <td>sme::stage::POST_READ</td>
        <td>Occurs after the read of data and will allow modification of the data to be returned.<br>
        Often utilized to effect state of device when content may need to be flushed or reset.</td>
    </tr>
    <tr>
        <td>sme::stage::PRE_WRITE</td>
        <td>Occurs before the data is committed.<br>
        Useful if particular modes of operation will force particular bits not to accept writes.</td>
    </tr>
    <tr>
        <td>sme::stage::POST_WRITE</td>
        <td>Occurs after data has been committed (write complete) to the register/field.<br>
        Important to note control has not returned to the bus at time of execution.<br>
        Most common stage used to declare notification rules.</td>
    </tr>
</tbody></table>
<p>Notification rules must also define the Type of rule which defines how data will be evaluated to determine if the rule should execute the assigned callback.  The below table provides a reasonable description and details extended parameters required for each type (when necessary).</p>
<table>
    <tbody><tr>
        <td>Type</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>sme::type::NOTIFY</td>
        <td>Executes with no logic evaluation applied.
        </td>
    </tr>
    <tr>
        <td>sme::type::MASKED</td>
        <td>Executes only if positive masked bits change.<br>
        <br>
        PARAMETERS<br>
        uint64_t _mask :: a binary mask which enabled bits (1) will be evaluated.
        </td>
    </tr>
    <tr>
        <td>sme::type::PATTERN</td>
        <td>Executes if masked bits change from one value combination to another value combination.<br>
        Useful for multi-bit changes which modify state or mode of IP.<br>
        <br>
        PARAMETERS<br>
        uint64_t _mask  :: a binary mask which enabled bits (1) will be evaluated.<br>
        uint64_t _start :: value which must match existing stored value with _mask applied.<br>
        uint64_t _end   :: value which must match data (being written) with _mask applied.<br>
        </td>
    </tr>
    <tr>
        <td>sme::type::RISING_BIT</td>
        <td>Executes when the specified bit transitions from 0 to 1.<br>
        <br>
        PARAMETERS<br>
        uint8_t _bit :: bit to evaluate.<br>
        </td>
    </tr>
    <tr>
        <td>sme::type::FALLING_BIT</td>
        <td>Executes when the specified bit transitions from 1 to 0.<br>
        <br>
        PARAMETERS<br>
        uint8_t _bit :: bit to evaluate.<br>
        </td>
    </tr>
</tbody></table>
<h4 id="behavior-model">12.2.1 <a href="#behavior-model">Behavior Model</a></h4>
<p>Before creating notification rules it is common place to create a stand alone class for the behavior so that stimulation from the simulator and the behavior are separated.  This is useful in cases where device/register/field frameworks are auto-generated.</p>
<pre><code class="language-C">class example_behavior {
protected:
    SampleBank * m_bank {nullptr};

public:
    void init( SampleBank * _bank) { m_bank = _bank; }
    
};
</code></pre>
<p>Behavior is implemented in the form of callbacks which the notification rules can execute.  Right now only simple behavior is needed to demonstrate notification rule connectivity.</p>
<pre><code class="language-C">    void on_reg_pre_read() {
        std::cout &lt;&lt; "on_reg_pre_read()" &lt;&lt; std::endl;
    }

    void on_reg_post_read() {
        std::cout &lt;&lt; "on_reg_post_read()" &lt;&lt; std::endl;
    }

    void on_reg_pre_write() {
        std::cout &lt;&lt; "on_reg_pre_write()" &lt;&lt; std::endl;
    }

    void on_reg_post_write() {
        std::cout &lt;&lt; "on_reg_post_write()" &lt;&lt; std::endl;
    }

    on_reg_mask_change() {
        std::cout &lt;&lt; "on_reg_mask_change()" &lt;&lt; std::endl;
    }

    on_reg_pattern_change() {
        std::cout &lt;&lt; "on_reg_pattern_change()" &lt;&lt; std::endl;
    }

    void on_enable_field_1() {
        std::cout &lt;&lt; "on_enable_field_1()" &lt;&lt; std::endl;
        uint16_t temp = m_bank-&gt;example_register.example_field_1.get() &amp; 0x7fff;
        m_bank-&gt;example_register.example_field_1.set(temp);
    }

    void on_enable_field_2() {
        std::cout &lt;&lt; "on_enable_field_2()" &lt;&lt; std::endl;
        uint16_t temp = m_bank-&gt;example_register.example_field_2.get() &amp; 0x7fff;
        m_bank-&gt;example_register.example_field_2.set(0);
    }
</code></pre>
<h4 id="creating-notification-rules">12.2.2 <a href="#creating-notification-rules">Creating Notification Rules</a></h4>
<p>The behavior model can be instantiated in Simics Device or as another class which ties the two together.  For this example an example model will be created.</p>
<pre><code class="language-C">class example_model {
public:
    example_model( SampleDevice * _dev) {
        dev = _dev;
        bank_port = new SampleBankPort { _dev-&gt;obj() };
        beh.init( &amp;bank_port-&gt;bank)
    }

    virtual ~example_model() {
        if( bank_port) {
            delete bank_port;
            bank_port = nullptr;
        }
    }

    void bind() {
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pre_read(); },
            sme::stage::PRE_READ, sme::type::NOTIFY, "on_reg_pre_read"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_post_read(); },
            sme::stage::POST_READ, sme::type::NOTIFY, "on_reg_post_read"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pre_write(); },
            sme::stage::PRE_WRITE, sme::type::NOTIFY, "on_reg_pre_write"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_post_write(); },
            sme::stage::POST_WRITE, sme::type::NOTIFY, "on_reg_post_write"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_mask_change(); },
            sme::stage::POST_WRITE, sme::type::MASKED, "on_reg_mask_change", 0x0ff00ff0
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pattern_change(); },
            sme::stage::POST_WRITE, sme::type::PATTERN, "on_reg_pattern_change", 0x000f000f, 0x00030002, 0x00040005
        );
        bank_port-&gt;bank.example_register.example_field_1.add_rule(
            [this]()-&gt;void { beh.on_enable_field_1(); },
            sme::stage::POST_WRITE, sme::type::RISING_BIT, "on_enable_field_1", 15
        );
        bank_port-&gt;bank.example_register.example_field_2.add_rule(
            [this]()-&gt;void { beh.on_enable_field_2(); },
            sme::stage::POST_WRITE, sme::type::LOWERING_BIT, "on_enable_field_2", 15
        );
    }

protected:
    SampleDevice * dev;
    SampleBankPort * bank_port;
    example_behavior beh;
}
</code></pre>
<p>The example demonstrates how additional parameters for rule types are added to the end of the list.  Notice that bit based field rules are relative to the field width and not the register width.</p>
<h4 id="advanced-features">12.2.3 <a href="#advanced-features">Advanced Features</a></h4>
<p>Notification rules can also be deactivated from within a behavioral callback.</p>
<pre><code class="language-C">    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::PRE_READ, "on_reg_pre_read");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::POST_READ, "on_reg_post_read");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::PRE_WRITE, "on_reg_pre_write");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::POST_WRITE, "on_reg_post_write");
</code></pre>
<p>And those rules can be re-activated as well, this provides a great deal of flexibility for mode based IP configuration.</p>
<pre><code class="language-C">    bank_port-&gt;bank.example_register.activate_rule( sme::stage::POST_WRITE, "on_reg_post_write");
</code></pre>
<h3 id="expressions">12.3 <a href="#expressions">Expressions</a></h3>
<p>Expression rules provide a way to listen to register, field and (eventually) signal notification rules and then evaluate a compound expression which mirrors a HW SPEC definition.  When the expression evaluates to true a callback is executed where the user only has to be concerned with coding the specific behavior/functionality.  These compound expressions can also be used to walk a state machine.</p>
<p>Expressions will typically be declared in the MODEL definition.</p>
<pre><code class="language-C">    sme::expression expression_example { "expression_example"};
</code></pre>
<p>The <code>sensitive_to</code> statement can bind another expression (via an expression vector) or create a notification rule and bind the notification to this expression (automatically).  The parameter list determines what type of notification rule or binding will occur.</p>
<pre><code class="language-C">		// DEFINE EXPRESSION SENSITIVITIES
            // NOTIFY
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE);
            // MASK
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE, 0x0003);
            // PATTERN
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE, 0x0030, 0x0020, 0x0010);
</code></pre>
<p>The expression does not use a DSL, equation parser or other complex notion.  Instead a standard C boolean expression is used and defined as a lambda to keep the code concise.  This evaluation is defined as the "logic" statement of the expression.  The logic statement may utilize other registers, fields, even banks if you have a reference to them; so it is possible to build very complex logic analysis statements.</p>
<pre><code class="language-C">		// DEFINE EXPRESSION TO EVALUATE
        expression_example.logic( [this]() -&gt; bool {
            bool result = 
                (bank.example_register.example_field_1.get() == 1 &amp;&amp; bank.example_register.example_field_2.get() == 0x011) ||
                (bank.example_register.get() == 0x03320110);
            return( result);
        });
</code></pre>
<p>The 'logic' statement is actually part of an evaluation flow which can activate many different vectors.</p>
<table>
    <tbody><tr>
        <td>Expression Vector</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>eval_true</td>
        <td>Executes every time the logic evaluates to true.</td>
    </tr>
    <tr>
        <td>eval_false</td>
        <td>Executes every time the logic evaluates to false.</td>
    </tr>
    <tr>
        <td>change</td>
        <td>Executes every time the logic changes (true-&gt;false), (false-&gt;true)</td>
    </tr>
    <tr>
        <td>rising</td>
        <td>Executes every time the logic changes from false-&gt;true</td>
    </tr>
    <tr>
        <td>falling</td>
        <td>Executes every time the logic changes from true-&gt;false</td>
    </tr>
</tbody></table>
<p>These expression vectors allow for behavior definition relative to how expression logic should drive the underlying implementation.</p>
<pre><code class="language-C">		// BIND TO DEVELOPER METHOD for FUNCTIONALITY
        expression_example.eval_true.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.eval_true" &lt;&lt; std::endl;
        });
        expression_example.eval_false.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.eval_false" &lt;&lt; std::endl;
        });
        expression_example.change.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.change" &lt;&lt; std::endl;
        });
        expression_example.rising.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.rising" &lt;&lt; std::endl;
        });
        expression_example.falling.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.falling" &lt;&lt; std::endl;
        });
</code></pre>
<p>It is also possible to make an expression sensitive to another expression via an expression vector.  Imagine if a second register existed, and <code>expression_example_2</code> is only sensitive to <code>expression_example.rising</code>.  One could do 
the following to check <code>example_register_2</code> value only when the rising condition of the first expression was met.</p>
<pre><code class="language-C">    sme::expression expression_example_2 { "expression_example_2"};

    expression_example_2.sensitive_to( expression_example.rising);

    expression_example_2.logic( [this]() -&gt; bool {
        bool result = (bank.example_register_2.get() == 0x12345678);
        return( result);
    });
</code></pre>
<p>It is good to make note that you typically will use either notification rules or expressions (which are composed of notification rules) based on the complexity of content evaluation needed.  It may be easier to just use expressions in most cases, but for simple tasks notification rules work fine.</p>
<h3 id="boost-sml-state-machine-library">12.4 <a href="#boost-sml-state-machine-library">Boost SML (State Machine Library)</a></h3>
<p>State machines have long been a cornerstone of modeling complex HW flows in virtual platforms.  Simics currently lacks any API that specifically defines a state machine.  Luckily for us there are several API's developed in the last decade which excel at state machine definition and keeping the footprint and executable code size to a minimum.</p>
<p>Boost SML is probably the most advanced implementation, a highly template meta-programming based implementation which actually treats each state as a type; and the binary code inherently is executing from its state.  This creates a bit of a headache in capturing the active state for save/restore, but otherwise the framework is completely UML declaration compliant and is amazing to work with.</p>
<p>This example will showcase the implementation of a minimal state loop of the following state machine:
<img alt="" src="ip_fsm.svg"></p>
<p>IP_ON_BUSY -&gt; DEASSERT_RESET         : by sending command DEASSERT_RESET</p>
<p>DEASSERT_RESET -&gt; IP_READY_2_RESET   : internal acknowledge of state entered</p>
<p>IP_READY_2_RESET -&gt; IP_RESET_COMPLETE: internal bit write (IP has no power cycle)</p>
<p>IP_RESET_COMPLETE -&gt; IP_ON_BUSY      : timer expired</p>
<p>most of the transitions are pseudo-code because this is C++ test-harness based example.</p>
<p>Example top level: <code>&lt;Simics Base Package&gt;/src/devices/c++-api/extensions/unittests/doc_example.cxx</code></p>
<p>Example sub files:  <code>&lt;Simics Base Package&gt;/src/devices/c++-api/extensions/unittests/doc_example</code></p>
<h4 id="example-logger">12.4.1 <a href="#example-logger">Example Logger</a></h4>
<p>There is an example logger for the state machine events and transitions under <code>third_party_integration/fsm_logger.hpp</code>.  While this is somewhat useful, it may be desirable to create your own logger for BOOST SML, this is defined in the declaration of the SM instance which is covered further down.</p>
<h4 id="example-register-set">12.4.2 <a href="#example-register-set">Example Register Set</a></h4>
<p>For this example we need a few registers (to begin with) that will enable the need for complex expressions to drive the state machine.</p>
<pre><code class="language-C">// Device container class
class FsmRegDevice : public simics::MappableConfObject {
public:
    explicit FsmRegDevice(simics::ConfObjectRef o)
        : simics::MappableConfObject(o) {
    }
    static void init_class(simics::ConfClass *cls);
};

class FsmRegBank : public simics::PortBank&lt;&gt; {
public:
    using PortBank::PortBank;


    void resetAllRegisters() {
        unsigned numOfRegs = number_of_registers();
        for (unsigned i = 0; i &lt; numOfRegs; ++i) {
            std::pair&lt;size_t, simics::RegisterInterface *&gt; reg_pair = register_at_index(i);
            reg_pair.second-&gt;reset();
        }
    }

    class IP_MASK : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class IP_BIT : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        IP_BIT IP_BIT {                                
            this, simics::Name("IP_BIT"),                 
            simics::Description("Mask bit for IP selection"),
            simics::Offset(15), 
            simics::BitWidth(1)
        };
        
    };

    class STATE_CONTROL : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class COMMAND : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

            class EXECUTE : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        COMMAND COMMAND {                                
            this, simics::Name("COMMAND"),                 
            simics::Description("When set, requests IPs move into this state"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };

        EXECUTE EXECUTE {                                
            this, simics::Name("EXECUTE"),                 
            simics::Description("sets command to be executed upon..."),
            simics::Offset(7), 
            simics::BitWidth(1)
        };
    };

    class FSM_ACTIONS : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class GATE_CLK : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        GATE_CLK GATE_CLK {
            this, simics::Name("GATE_CLK"),                 
            simics::Description("1: Gate output clock, 0: No action"),
            simics::Offset(16), 
            simics::BitWidth(1)
        };
        
    };

    class IP_SLEEP : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class IP_BIT : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        IP_BIT IP_BIT {                                
            this, simics::Name("IP_BIT"),                 
            simics::Description("IP_BIT will go to sleep"),
            simics::Offset(15), 
            simics::BitWidth(1)
        };
        
    };

    class DRIVER_FSM_STATE_IP_1 : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class state : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        state state {                                
            this, simics::Name("state"),                 
            simics::Description("IP driver FSM Status"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };
    };

    class DRIVER_FSM_STATE_IP_2 : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class state : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        state state {                                
            this, simics::Name("state"),                 
            simics::Description("IP 2 driver FSM Status"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };
    };

    IP_MASK ip_mask {
        this, simics::Name("ip_mask"),
        simics::Description("Mask to target specific IP."),
        simics::Offset(0xddc),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
                            
    STATE_CONTROL state_control {
        this, simics::Name("state_control"),
        simics::Description("desired state"),
        simics::Offset(0xde4),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    FSM_ACTIONS fsm_actions {
        this, simics::Name("fsm_actions"),
        simics::Description("fsm actions"),
        simics::Offset(0xb4),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    IP_SLEEP ip_sleep {
        this, simics::Name("ip_sleep"),
        simics::Description("sets which IP will go to sleep."),
        simics::Offset(0x1054),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
                            
    DRIVER_FSM_STATE_IP_1 driver_fsm_state_ip_1 {
        this, simics::Name("driver_fsm_state_ip_1"),
        simics::Description("Read IP 1 Driver FSM state"),
        simics::Offset(0xf44),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    DRIVER_FSM_STATE_IP_2 driver_fsm_state_ip_2 {
        this, simics::Name("driver_fsm_state_ip_2"),
        simics::Description("Read IP 2 Driver FSM state"),
        simics::Offset(0xf4c),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

};

// BankPort container class
class FsmRegBankPort : public simics::BankPort&lt;FsmRegDevice&gt; {
    public:
    using BankPort&lt;FsmRegDevice&gt;::BankPort;

    FsmRegBank bank {
        this, simics::Description("FSM Register bank")
    };
};
</code></pre>
<h4 id="recommended-source-structure">12.4.3 <a href="#recommended-source-structure">Recommended Source Structure</a></h4>
<p>There are a few additional features which need to be implemented such as save/restore of the state which requires extra work outside of the standard Boost SML definition.  There is also some implications with scoping of callbacks which must be considered.</p>
<ul>
<li>
<p>Declaration - <code>device_declaration.hpp</code> - Declaration of the event &amp; state types, state machine, data &amp; callback target</p>
</li>
<li>
<p>Definition - <code>SM_device_declaration.hpp</code> - Brings the callbacks, state machine instantiation, and get/set state capabilities into a single class for use by developer.</p>
</li>
<li>
<p>Developer Source - As defined above, is the source that the developer should be concerned with, knowing the state machine is declared and defined correctly.</p>
</li>
</ul>
<h5 id="declaration">12.4.3.1 <a href="#declaration">Declaration</a></h5>
<p>The code below defines an enumeration of states, and TYPES for all events and states of the state machine definition.</p>
<pre><code class="language-C">#include &lt;boost/sml.hpp&gt;
#include &lt;iostream&gt;
#include &lt;stdint.h&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

#ifndef __IP_DECLARATION_HPP__
#define __IP_DECLARATION_HPP__

class SM_DEFINITION;

namespace IP
{

struct SM {
    enum E { // This E is a designation for ENUMERATION, not event!!!
        START = 0,
        IP_ON_BUSY,
        DEASSERT_RESET,
        IP_READY_2_RESET,
        IP_RESET_COMPLETE,
        SEND_RESET_PREP,
        WAIT_FOR_ACKNOWLEDGE,
        SEND_POWER_CYCLE,
        RESTORE_IP,
        ERROR_COULD_NOT_DETECT_STATE
    };
};

// special for START state
struct E_INIT {};

// hierarchical events - used at top level and within sub sm
struct E_GOTO_ON_AVAILABLE {};
struct E_TIMER_EXPIRED {};

// top level only events
struct E_FSM_RESET_ASSERTED {};
struct E_ENTER_RESET{};

// sub sm only events
struct E_ENABLE_LOCK {};
struct E_IP_GO_TO_SLEEP {};
struct E_EXECUTE_RESET {};
struct E_RESET_PREP_SENT {};
struct E_ACKNOWLEDGE_RECEIVED {};
struct E_POWER_UP {};
struct E_LOCK_DEASSERTED {};

// states
class START;
class IP_ON_BUSY;

struct IP_IMPL; // sub state machine
class DEASSERT_RESET;
class IP_READY_2_RESET;
class IP_RESET_COMPLETE;
class SEND_RESET_PREP;
class WAIT_FOR_ACKNOWLEDGE;
class SEND_POWER_CYCLE;
class RESTORE_IP;
</code></pre>
<p>Below the type definitions a data type (for storage of interesting SM relevant data) and a bevior class (to facilitate callbacks) are provided as constructs which will be utilized by the state machine.</p>
<pre><code class="language-C">// data and behavior declaration
class behavior_t;

class data_t {
public:
    SM::E state;
    bool lock_in_effect {false};
    bool power_cycle_bypassed {false};
    behavior_t * beh;
};

class behavior_t {
public:
    data_t d;

    behavior_t() { d.beh = this; }

    // State entry / exit callbacks
    virtual void DEASSERT_RESET_on_enter() = 0;
    virtual void DEASSERT_RESET_on_exit() = 0;
    virtual void IP_RESET_COMPLETE_on_enter() = 0;
    virtual void IP_RESET_COMPLETE_on_exit() = 0;
    virtual void IP_ON_BUSY_on_enter() = 0;
    virtual void IP_ON_BUSY_on_exit() = 0;
    virtual void IP_IMPL_on_enter() = 0;
    virtual void IP_IMPL_on_exit() = 0;

    // event callbacks
    virtual void do_initialize() = 0;
    virtual void do_complete_request() = 0;
    virtual void do_deassert_reset() = 0;
    virtual void do_set_lock() = 0;
    virtual void do_send_reset_prep() = 0;
    virtual void do_no_power_cycle() = 0;
    virtual void do_cycle_power() = 0;
    virtual void do_restore_state_if_needed() = 0;
    virtual void do_trigger_timer() = 0;
    virtual void do_is_not_powering_down() = 0;
    
    // Save &amp; Restore methods
    virtual IP::SM::E get_current_state() = 0;
    virtual void set_current_state( IP::SM::E _state) = 0;

    // Accessor Methods
    std::string state_to_string( IP::SM::E _state) {
        std::string retval = "";        
        switch( _state) {
            case IP::SM::E::START:
                retval = "START";
                break;
            case IP::SM::E::IP_ON_BUSY:
                retval = "IP_ON_BUSY";
                break;
            case IP::SM::E::DEASSERT_RESET:
                retval = "DEASSERT_RESET";
                break;
            case IP::SM::E::IP_READY_2_RESET:
                retval = "IP_READY_2_RESET";
                break;
            case IP::SM::E::IP_RESET_COMPLETE:
                retval = "IP_RESET_COMPLETE";
                break;
            case IP::SM::E::SEND_RESET_PREP:
                retval = "SEND_RESET_PREP";
                break;
            case IP::SM::E::WAIT_FOR_ACKNOWLEDGE:
                retval = "WAIT_FOR_ACKNOWLEDGE";
                break;
            case IP::SM::E::SEND_POWER_CYCLE:
                retval = "SEND_POWER_CYCLE";
                break;
            case IP::SM::E::RESTORE_IP:
                retval = "RESTORE_IP";
                break;
            default:
                retval = "ERROR: COULD NOT DETECT STATE";
                break;
        }
        return( retval);
    }

    IP::SM::E string_to_state( std::string _str) {
        if( _str == "START")                        return( IP::SM::E::START);        
        else if( _str == "IP_ON_BUSY")              return( IP::SM::E::IP_ON_BUSY);        
        else if( _str == "DEASSERT_RESET")          return( IP::SM::E::DEASSERT_RESET);        
        else if( _str == "IP_READY_2_RESET")        return( IP::SM::E::IP_READY_2_RESET);        
        else if( _str == "IP_RESET_COMPLETE")       return( IP::SM::E::IP_RESET_COMPLETE);        
        else if( _str == "SEND_RESET_PREP")         return( IP::SM::E::SEND_RESET_PREP);        
        else if( _str == "WAIT_FOR_ACKNOWLEDGE")    return( IP::SM::E::WAIT_FOR_ACKNOWLEDGE);        
        else if( _str == "SEND_POWER_CYCLE")        return( IP::SM::E::SEND_POWER_CYCLE);        
        else if( _str == "RESTORE_IP")              return( IP::SM::E::RESTORE_IP);        
        else                                        return( IP::SM::E::ERROR_COULD_NOT_DETECT_STATE);        
    }
};
</code></pre>
<p>Finally the flow of the state machine is described in BOOST SML which follows a near UML style of definition and includes both sub-state machines and guards.  Notice that lambda's are used to pass the SM data reference to the events, and the actual callback is executed from the data object handler.  This keeps the definition of the state machine clear and separate from the implementation of behavior.</p>
<pre><code class="language-C">struct IP_IMPL
{
    auto operator()() const noexcept {
        using namespace sml;
        return make_transition_table(
            * state&lt;DEASSERT_RESET&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;DEASSERT_RESET_on_enter(); }
            , state&lt;DEASSERT_RESET&gt; + event&lt;E_ENABLE_LOCK&gt; / []( data_t &amp; d) { d.beh-&gt;do_set_lock(); } = state&lt;IP_READY_2_RESET&gt;
            , state&lt;DEASSERT_RESET&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;DEASSERT_RESET_on_exit(); }

            , state&lt;IP_READY_2_RESET&gt; + event&lt;E_EXECUTE_RESET&gt; / []( data_t &amp; d) { d.beh-&gt;do_send_reset_prep(); } = state&lt;SEND_RESET_PREP&gt;
            , state&lt;IP_READY_2_RESET&gt; + event&lt;E_IP_GO_TO_SLEEP&gt; / []( data_t &amp; d) { d.beh-&gt;do_no_power_cycle(); } = state&lt;IP_RESET_COMPLETE&gt;

            , state&lt;SEND_RESET_PREP&gt; + event&lt;E_RESET_PREP_SENT&gt; = state&lt;WAIT_FOR_ACKNOWLEDGE&gt;

            , state&lt;WAIT_FOR_ACKNOWLEDGE&gt; + event&lt;E_ACKNOWLEDGE_RECEIVED&gt; / []( data_t &amp; d) { d.beh-&gt;do_cycle_power(); } = state&lt;SEND_POWER_CYCLE&gt;

            , state&lt;SEND_POWER_CYCLE&gt; + event&lt;E_POWER_UP&gt; / []( data_t &amp; d) { d.beh-&gt;do_restore_state_if_needed(); } = state&lt;RESTORE_IP&gt;

            , state&lt;RESTORE_IP&gt; + event&lt;E_LOCK_DEASSERTED&gt; / []( data_t &amp; d) { d.beh-&gt;do_trigger_timer(); } = state&lt;IP_RESET_COMPLETE&gt;

            , state&lt;IP_RESET_COMPLETE&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_RESET_COMPLETE_on_enter(); }
            , state&lt;IP_RESET_COMPLETE&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_RESET_COMPLETE_on_exit(); }
        );
    }
};

const auto guard_state_IP_RESET_COMPLETE = []( const auto &amp; event, data_t &amp; d) { return( d.beh-&gt;get_current_state() == IP::SM::E::IP_RESET_COMPLETE); };

struct IP
{
    auto operator()() const noexcept {
        using namespace sml;
        return make_transition_table(

            * state&lt;START&gt; + event&lt;E_INIT&gt; / []( data_t &amp; d) {d.beh-&gt;do_initialize(); } = state&lt;IP_ON_BUSY&gt;

            , state&lt;IP_ON_BUSY&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_ON_BUSY_on_enter(); }
            , state&lt;IP_ON_BUSY&gt; + event&lt;E_ENTER_RESET&gt; / []( data_t &amp; d) { d.beh-&gt;do_complete_request(); } = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_ON_BUSY&gt; + event&lt;E_GOTO_ON_AVAILABLE&gt; / []( data_t &amp; d) { d.beh-&gt;do_deassert_reset(); } = state&lt;IP_IMPL&gt;
            , state&lt;IP_ON_BUSY&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_ON_BUSY_on_exit(); }

            , state&lt;IP_IMPL&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_IMPL_on_enter(); }
            , state&lt;IP_IMPL&gt; + event&lt;E_TIMER_EXPIRED&gt; [guard_state_IP_RESET_COMPLETE] = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_IMPL&gt; + event&lt;E_FSM_RESET_ASSERTED&gt; / []( data_t &amp; d) { d.beh-&gt;do_is_not_powering_down(); } = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_IMPL&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_IMPL_on_exit(); }
        );
    }
};

}

</code></pre>
<h5 id="definition">12.4.3.2 <a href="#definition">Definition</a></h5>
<p>The <code>SM_DEFINITION</code> is an extension of the <code>IP::behavior_t</code>; where the logger (optional) and state machine instance are declared.</p>
<p>To work with simics replay/stop/reverse a state machine must have a mechanism to save &amp; restore state.  The enumerstion for the state targets is utilized here with developer required methods which must be implemented for Simics.</p>
<pre><code class="language-C">class SM_DEFINITION : public IP::behavior_t {
public:
    extras::fsm_logger logger;
    sml::sm&lt; IP::IP, sml::testing, sml::logger&lt; extras::fsm_logger&gt; &gt; sm{ d, logger};

    SM_DEFINITION() {;}

    IP::SM::E get_current_state() override {
        using namespace sml;
        using namespace IP;
        IP::SM::E retval = IP::SM::E::ERROR_COULD_NOT_DETECT_STATE;
        if( sm.is( state&lt;IP_ON_BUSY&gt;))                                                  retval = IP::SM::E::IP_ON_BUSY; 
        else if( sm.is( state&lt;START&gt;))                                                  retval = IP::SM::E::START; 
        else if( sm.is( state&lt;IP_IMPL&gt;)) {
            if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;DEASSERT_RESET&gt;))               retval = IP::SM::E::DEASSERT_RESET; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_READY_2_RESET&gt;))        retval = IP::SM::E::IP_READY_2_RESET; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_RESET_COMPLETE&gt;))       retval = IP::SM::E::IP_RESET_COMPLETE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_RESET_PREP&gt;))         retval = IP::SM::E::SEND_RESET_PREP; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;WAIT_FOR_ACKNOWLEDGE&gt;))    retval = IP::SM::E::WAIT_FOR_ACKNOWLEDGE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_POWER_CYCLE&gt;))        retval = IP::SM::E::SEND_POWER_CYCLE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;RESTORE_IP&gt;))              retval = IP::SM::E::RESTORE_IP; 
        }
        return( retval);
    }

    void set_current_state( IP::SM::E _state) override {
        using namespace sml;
        using namespace IP;
        if( _state == IP::SM::E::IP_ON_BUSY)                        sm.set_current_states( state&lt;IP_ON_BUSY&gt;);
        else if( _state == IP::SM::E::START)                        sm.set_current_states( state&lt;START&gt;);
        else {
            sm.set_current_states( state&lt;IP_IMPL&gt;);
            if( _state == IP::SM::E::DEASSERT_RESET)                sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;DEASSERT_RESET&gt;);
            else if( _state == IP::SM::E::IP_READY_2_RESET)         sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_READY_2_RESET&gt;);
            else if( _state == IP::SM::E::IP_RESET_COMPLETE)        sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_RESET_COMPLETE&gt;);
            else if( _state == IP::SM::E::SEND_RESET_PREP)          sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_RESET_PREP&gt;);
            else if( _state == IP::SM::E::WAIT_FOR_ACKNOWLEDGE)     sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;WAIT_FOR_ACKNOWLEDGE&gt;);
            else if( _state == IP::SM::E::SEND_POWER_CYCLE)         sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_POWER_CYCLE&gt;);
            else if( _state == IP::SM::E::RESTORE_IP)               sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;RESTORE_IP&gt;);
        }
    }

};
</code></pre>
<h5 id="developer-behavior-source">12.4.3.3 <a href="#developer-behavior-source">Developer (Behavior) Source</a></h5>
<p>Developer source is the implementation of behavior for the state machine.  Because this is a unit test (C++) the code will simply print basic messages.</p>
<pre><code class="language-C">class SM_Behavior : public SM_DEFINITION {
public:
    SM_Behavior() : SM_DEFINITION() 
    {;}

    // Developer would override callbacks here...
    // State entry / exit callbacks
    void DEASSERT_RESET_on_enter() override     { std::cout &lt;&lt; "DEASSERT_RESET ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void DEASSERT_RESET_on_exit() override      { std::cout &lt;&lt; "DEASSERT_RESET ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_RESET_COMPLETE_on_enter() override  { std::cout &lt;&lt; "IP_RESET_COMPLETE ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_RESET_COMPLETE_on_exit() override   { std::cout &lt;&lt; "IP_RESET_COMPLETE ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_ON_BUSY_on_enter() override         { std::cout &lt;&lt; "IP_ON_BUSY ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_ON_BUSY_on_exit() override          { std::cout &lt;&lt; "IP_ON_BUSY ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_IMPL_on_enter() override            { std::cout &lt;&lt; "IP_IMPL ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_IMPL_on_exit() override             { std::cout &lt;&lt; "IP_IMPL ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }

    // event callbacks
    void do_initialize() override               { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_initialize" &lt;&lt; std::endl; }
    void do_complete_request() override         { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_complete_request" &lt;&lt; std::endl; }
    void do_deassert_reset() override           { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_deassert_reset" &lt;&lt; std::endl; }
    void do_set_lock() override                 { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_set_lock" &lt;&lt; std::endl; }
    void do_send_reset_prep() override          { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_send_reset_prep" &lt;&lt; std::endl; }
    void do_no_power_cycle() override           { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_no_power_cycle" &lt;&lt; std::endl; }
    void do_cycle_power() override              { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_cycle_power" &lt;&lt; std::endl; }
    void do_restore_state_if_needed() override  { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_restore_state_if_needed" &lt;&lt; std::endl; }
    void do_trigger_timer() override            { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_trigger_timer" &lt;&lt; std::endl; }
    void do_is_not_powering_down() override     { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_is_not_powering_down" &lt;&lt; std::endl; }
};
</code></pre>
<h4 id="implementing-expressions">12.4.4 <a href="#implementing-expressions">Implementing Expressions</a></h4>
<p>For this example the behavior code is written inside the expressions, but in many cases one would want more of the behavior code to exist in the behavior callbacks of the state machine.</p>
<p>Only 2 expressions are required to define the 4 state transitions based on the description in <a class="reference" href="#boost-sml-state-machine-library">12.4</a>.</p>
<p>The <code>...</code> in the code is where you would place your simics module parent type / implementations</p>
<pre><code class="language-C">class doc_example : public ::testing::Test, ... {
  public:
    virtual ~doc_example() {
        if (bank_parent) {
            delete bank_parent;
            bank_parent = nullptr;
        }
        if (bp) {
            delete bp;
            bp = nullptr;
        }
    }

	MockObject *bank_parent;
    FsmRegBankPort *bp;
    SM_Behavior        ip;

    sme::expression     ex__deassert_reset          {"ex__deassert_reset"};
    sme::expression     ex__ip_goto_sleep           {"ex__ip_goto_sleep"};
</code></pre>
<p>The <code>ex__deassert_reset</code> will define both a rising and falling edge event capture.  Technically the "process_event" methods are the only code which should exist in the execute.  Other code should be implemented in the behavior callbacks defined in section <a class="reference" href="#developer-behavior-source">12.4.3.3</a>.</p>
<pre><code class="language-C">    explicit doc_example(const std::string &amp;name = "") {
        ...
		bp = new FsmRegBankPort { bank_parent-&gt;obj() }; 

        // ex_goto_deassert_reset
        ex__deassert_reset.sensitive_to( bp-&gt;bank.state_control.EXECUTE, stage::POST_WRITE);
        ex__deassert_reset.logic( [this]() -&gt; bool {
            bool result = ( bp-&gt;bank.ip_mask.IP_BIT.get() == 1 &amp;&amp; 
                            bp-&gt;bank.state_control.COMMAND.get() == IP::SM::E::DEASSERT_RESET &amp;&amp;
                            bp-&gt;bank.state_control.EXECUTE.get() == 0x01);
            return( result);
        });

        ex__deassert_reset.rising.execute( [this]() -&gt; void {
            bp-&gt;bank.state_control.EXECUTE.set (0);             // reset control (should be a scheduled event as shown in comments below)
//            ex__deassert_reset.process( 1); // which should execute the next line in theory...
//            SIM_realtime_event( 1, &amp;process_ex_goto_deassert_reset, reinterpret_cast&lt; void *&gt;(this),  0, ex_goto_deassert_reset.name().c_str());
            ip.sm.process_event( IP::E_GOTO_ON_AVAILABLE{});    // this will change the SM current state
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state()); // relay the new state for driver to read
        });

        // the falling edge can only happen if true was entered, so this is valid assumption caused by timed event
        ex__deassert_reset.falling.execute( [this]() -&gt; void {
            ip.sm.process_event( IP::E_ENABLE_LOCK{});    // this will change the SM current state
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state()); // relay the new state for driver to read
        });

        // IP GOTO SLEEP as an expression        
        ex__ip_goto_sleep.sensitive_to( bp-&gt;bank.ip_sleep.IP_BIT, stage::POST_WRITE);
        ex__ip_goto_sleep.logic( [this]() -&gt; bool { 
            return((ip.get_current_state() == IP::SM::E::IP_READY_2_RESET) &amp;&amp; (bp-&gt;bank.ip_sleep.IP_BIT.get() == 1)); 
        });
        ex__ip_goto_sleep.rising.execute( [this]() -&gt; void { 
            bp-&gt;bank.ip_sleep.IP_BIT.set(0);
            ip.sm.process_event( IP::E_IP_GO_TO_SLEEP{});
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state());
            // ideally this would schedule a timer before auto-returning to IP_ON_BUSY
            // flush the state &amp; ensure that the falling edge is recorded (i.e. reset)
            ex__ip_goto_sleep.evaluate(true);
        });

    }
};
</code></pre>
<p>Finally we get to the unit test code itself, which is mocking a few different styles of transitions.</p>
<pre><code class="language-C">TEST_F(doc_example, example_bank_created) {
    // GLOBAL INIT
	EXPECT_EQ(bp-&gt;bank.bank_name(), "bar");
    ip.set_current_state( IP::SM::E::START);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::START);

    // transition to state IP_ON_BUSY
    ip.sm.process_event( IP::E_INIT{});
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);

    // transition to state DEASSERT_RESET
    bp-&gt;bank.ip_mask.IP_BIT.wr( 0x01);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
    bp-&gt;bank.state_control.COMMAND.wr( IP::SM::E::DEASSERT_RESET);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
    bp-&gt;bank.state_control.EXECUTE.wr( 1); // &lt;-- fire expression.rising
    EXPECT_EQ( bp-&gt;bank.driver_fsm_state_ip_1.state.get(), IP::SM::E::DEASSERT_RESET);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::DEASSERT_RESET);

    // verify execute cleared but evaluation status unchanged
    EXPECT_EQ( bp-&gt;bank.state_control.EXECUTE.get(), 0);
    EXPECT_EQ( ex__deassert_reset.last_state(), true);
    EXPECT_EQ( ex__deassert_reset.evaluate(), false);
    EXPECT_EQ( ex__deassert_reset.last_state(), true);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::DEASSERT_RESET);

    // simulate a timed event                          
    ex__deassert_reset.on_sensitivity(); // execute ex__deassert_reset.falling

    // that should have triggered a transition to IP_READY_2_RESET
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_READY_2_RESET);

    // now simulate a go to sleep (short path)
    bp-&gt;bank.ip_sleep.IP_BIT.wr( 1);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_RESET_COMPLETE);

    {    // simulate a timer expiring
        ip.sm.process_event( IP::E_TIMER_EXPIRED{});
    }

    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
}
</code></pre>
<!--- end documentation from C++ extension --->
<h2 id="migration-guide-from-c-api-v1">13 <a href="#migration-guide-from-c-api-v1">Migration Guide from C++ API V1</a></h2>
<p>From a device model's point of view there are only a few incompatible changes between Simics C++ API v1 and v2 to consider. Migration should thus be straight forward and trivial.</p>
<p>Here is the list of known changes that can cause problems when migrating from Simics C++ API v1:</p>
<ul>
<li>The C++ compiler must support C++14</li>
<li>Set <code>USE_CC_API</code> to 2 in the Makefile. </li>
<li>The header to include has been changed to <code>simics/cc-api.h</code> instead of <code>simics/c++/device-api.h</code>. </li>
<li>A model-defined class inherits from the <code>simics::ConfObject</code> class instead of <code>simics::SimicsObject</code>. </li>
<li>The C++ class constructor argument type is changed to <code>simics::ConfObjectRef</code> instead of <code>simics::SimicsObjectRef</code>.</li>
<li>Method <code>simics_obj</code> of <code>ConfObject</code> has been renamed to <code>obj</code>.</li>
<li>Use <code>make_class</code> to register a class. The parameters are same as the previous <code>ClassDef</code>.</li>
<li>Simics attribute registration uses only one type, <code>simics::Attribute</code>.</li>
<li>Add attributes, interfaces, port objects and log groups via the <code>add</code> method.</li>
<li>Interfaces are registered with the help of an interface info class.</li>
<li>Port interface is no longer supported. Use port object instead.</li>
<li>The model-defined class is recommended to register its property through its static function <code>init_class</code>, but can use the old way of registering everything in the <code>init_local</code> static function </li>
<li>The state variable set function, i.e. the attribute setter, should return <code>void</code> instead of <code>simics::SetResult</code>. </li>
<li>There is no need for <code>state_mapper</code> anymore. Any existing <code>state_mapper</code> is dead code and can be removed.</li>
</ul>

<div class="chain">
<span></span>
</div>